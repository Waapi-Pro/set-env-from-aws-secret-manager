import { a as __toCommonJS, i as __require, n as __esmMin, o as __toDynamicImportESM, r as __export, t as __commonJSMin } from "./rolldown-runtime-waC_Q_pm.js";

//#region node_modules/@actions/core/lib/utils.js
var require_utils$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toCommandProperties = exports.toCommandValue = void 0;
	/**
	* Sanitizes an input into a string so it can be passed into issueCommand safely
	* @param input input to sanitize into a string
	*/
	function toCommandValue(input) {
		if (input === null || input === void 0) return "";
		else if (typeof input === "string" || input instanceof String) return input;
		return JSON.stringify(input);
	}
	exports.toCommandValue = toCommandValue;
	/**
	*
	* @param annotationProperties
	* @returns The command properties to send with the actual annotation command
	* See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
	*/
	function toCommandProperties(annotationProperties) {
		if (!Object.keys(annotationProperties).length) return {};
		return {
			title: annotationProperties.title,
			file: annotationProperties.file,
			line: annotationProperties.startLine,
			endLine: annotationProperties.endLine,
			col: annotationProperties.startColumn,
			endColumn: annotationProperties.endColumn
		};
	}
	exports.toCommandProperties = toCommandProperties;
}));

//#endregion
//#region node_modules/@actions/core/lib/command.js
var require_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$11 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$11 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$11 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$11(result, mod, k$5);
		}
		__setModuleDefault$11(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.issue = exports.issueCommand = void 0;
	const os$4 = __importStar$11(__require("os"));
	const utils_1$3 = require_utils$1();
	/**
	* Commands
	*
	* Command Format:
	*   ::name key=value,key=value::message
	*
	* Examples:
	*   ::warning::This is the message
	*   ::set-env name=MY_VAR::some value
	*/
	function issueCommand(command, properties, message) {
		const cmd = new Command$1(command, properties, message);
		process.stdout.write(cmd.toString() + os$4.EOL);
	}
	exports.issueCommand = issueCommand;
	function issue(name, message = "") {
		issueCommand(name, {}, message);
	}
	exports.issue = issue;
	const CMD_STRING = "::";
	var Command$1 = class {
		constructor(command, properties, message) {
			if (!command) command = "missing.command";
			this.command = command;
			this.properties = properties;
			this.message = message;
		}
		toString() {
			let cmdStr = CMD_STRING + this.command;
			if (this.properties && Object.keys(this.properties).length > 0) {
				cmdStr += " ";
				let first = true;
				for (const key in this.properties) if (this.properties.hasOwnProperty(key)) {
					const val = this.properties[key];
					if (val) {
						if (first) first = false;
						else cmdStr += ",";
						cmdStr += `${key}=${escapeProperty(val)}`;
					}
				}
			}
			cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
			return cmdStr;
		}
	};
	function escapeData(s$5) {
		return (0, utils_1$3.toCommandValue)(s$5).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
	}
	function escapeProperty(s$5) {
		return (0, utils_1$3.toCommandValue)(s$5).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
	}
}));

//#endregion
//#region node_modules/@actions/core/lib/file-command.js
var require_file_command = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$10 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$10 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$10 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$10(result, mod, k$5);
		}
		__setModuleDefault$10(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
	const crypto$5 = __importStar$10(__require("crypto"));
	const fs$2 = __importStar$10(__require("fs"));
	const os$3 = __importStar$10(__require("os"));
	const utils_1$2 = require_utils$1();
	function issueFileCommand(command, message) {
		const filePath = process.env[`GITHUB_${command}`];
		if (!filePath) throw new Error(`Unable to find environment variable for file command ${command}`);
		if (!fs$2.existsSync(filePath)) throw new Error(`Missing file at path: ${filePath}`);
		fs$2.appendFileSync(filePath, `${(0, utils_1$2.toCommandValue)(message)}${os$3.EOL}`, { encoding: "utf8" });
	}
	exports.issueFileCommand = issueFileCommand;
	function prepareKeyValueMessage(key, value) {
		const delimiter = `ghadelimiter_${crypto$5.randomUUID()}`;
		const convertedValue = (0, utils_1$2.toCommandValue)(value);
		if (key.includes(delimiter)) throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
		if (convertedValue.includes(delimiter)) throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
		return `${key}<<${delimiter}${os$3.EOL}${convertedValue}${os$3.EOL}${delimiter}`;
	}
	exports.prepareKeyValueMessage = prepareKeyValueMessage;
}));

//#endregion
//#region node_modules/@actions/http-client/lib/proxy.js
var require_proxy = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkBypass = exports.getProxyUrl = void 0;
	function getProxyUrl$1(reqUrl) {
		const usingSsl = reqUrl.protocol === "https:";
		if (checkBypass(reqUrl)) return;
		const proxyVar = (() => {
			if (usingSsl) return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
			else return process.env["http_proxy"] || process.env["HTTP_PROXY"];
		})();
		if (proxyVar) try {
			return new DecodedURL(proxyVar);
		} catch (_a$2) {
			if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://")) return new DecodedURL(`http://${proxyVar}`);
		}
		else return;
	}
	exports.getProxyUrl = getProxyUrl$1;
	function checkBypass(reqUrl) {
		if (!reqUrl.hostname) return false;
		const reqHost = reqUrl.hostname;
		if (isLoopbackAddress(reqHost)) return true;
		const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
		if (!noProxy) return false;
		let reqPort;
		if (reqUrl.port) reqPort = Number(reqUrl.port);
		else if (reqUrl.protocol === "http:") reqPort = 80;
		else if (reqUrl.protocol === "https:") reqPort = 443;
		const upperReqHosts = [reqUrl.hostname.toUpperCase()];
		if (typeof reqPort === "number") upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
		for (const upperNoProxyItem of noProxy.split(",").map((x$5) => x$5.trim().toUpperCase()).filter((x$5) => x$5)) if (upperNoProxyItem === "*" || upperReqHosts.some((x$5) => x$5 === upperNoProxyItem || x$5.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x$5.endsWith(`${upperNoProxyItem}`))) return true;
		return false;
	}
	exports.checkBypass = checkBypass;
	function isLoopbackAddress(host) {
		const hostLower = host.toLowerCase();
		return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
	}
	var DecodedURL = class extends URL {
		constructor(url$1, base) {
			super(url$1, base);
			this._decodedUsername = decodeURIComponent(super.username);
			this._decodedPassword = decodeURIComponent(super.password);
		}
		get username() {
			return this._decodedUsername;
		}
		get password() {
			return this._decodedPassword;
		}
	};
}));

//#endregion
//#region node_modules/tunnel/lib/tunnel.js
var require_tunnel$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	__require("net");
	var tls$1 = __require("tls");
	var http$4 = __require("http");
	var https$2 = __require("https");
	var events$1 = __require("events");
	__require("assert");
	var util$18 = __require("util");
	exports.httpOverHttp = httpOverHttp;
	exports.httpsOverHttp = httpsOverHttp;
	exports.httpOverHttps = httpOverHttps;
	exports.httpsOverHttps = httpsOverHttps;
	function httpOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$4.request;
		return agent;
	}
	function httpsOverHttp(options) {
		var agent = new TunnelingAgent(options);
		agent.request = http$4.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function httpOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$2.request;
		return agent;
	}
	function httpsOverHttps(options) {
		var agent = new TunnelingAgent(options);
		agent.request = https$2.request;
		agent.createSocket = createSecureSocket;
		agent.defaultPort = 443;
		return agent;
	}
	function TunnelingAgent(options) {
		var self = this;
		self.options = options || {};
		self.proxyOptions = self.options.proxy || {};
		self.maxSockets = self.options.maxSockets || http$4.Agent.defaultMaxSockets;
		self.requests = [];
		self.sockets = [];
		self.on("free", function onFree(socket, host, port, localAddress) {
			var options$1 = toOptions(host, port, localAddress);
			for (var i$5 = 0, len = self.requests.length; i$5 < len; ++i$5) {
				var pending = self.requests[i$5];
				if (pending.host === options$1.host && pending.port === options$1.port) {
					self.requests.splice(i$5, 1);
					pending.request.onSocket(socket);
					return;
				}
			}
			socket.destroy();
			self.removeSocket(socket);
		});
	}
	util$18.inherits(TunnelingAgent, events$1.EventEmitter);
	TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
		var self = this;
		var options = mergeOptions({ request: req }, self.options, toOptions(host, port, localAddress));
		if (self.sockets.length >= this.maxSockets) {
			self.requests.push(options);
			return;
		}
		self.createSocket(options, function(socket) {
			socket.on("free", onFree);
			socket.on("close", onCloseOrRemove);
			socket.on("agentRemove", onCloseOrRemove);
			req.onSocket(socket);
			function onFree() {
				self.emit("free", socket, options);
			}
			function onCloseOrRemove(err) {
				self.removeSocket(socket);
				socket.removeListener("free", onFree);
				socket.removeListener("close", onCloseOrRemove);
				socket.removeListener("agentRemove", onCloseOrRemove);
			}
		});
	};
	TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
		var self = this;
		var placeholder = {};
		self.sockets.push(placeholder);
		var connectOptions = mergeOptions({}, self.proxyOptions, {
			method: "CONNECT",
			path: options.host + ":" + options.port,
			agent: false,
			headers: { host: options.host + ":" + options.port }
		});
		if (options.localAddress) connectOptions.localAddress = options.localAddress;
		if (connectOptions.proxyAuth) {
			connectOptions.headers = connectOptions.headers || {};
			connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
		}
		debug$1("making CONNECT request");
		var connectReq = self.request(connectOptions);
		connectReq.useChunkedEncodingByDefault = false;
		connectReq.once("response", onResponse);
		connectReq.once("upgrade", onUpgrade);
		connectReq.once("connect", onConnect);
		connectReq.once("error", onError$1);
		connectReq.end();
		function onResponse(res) {
			res.upgrade = true;
		}
		function onUpgrade(res, socket, head) {
			process.nextTick(function() {
				onConnect(res, socket, head);
			});
		}
		function onConnect(res, socket, head) {
			connectReq.removeAllListeners();
			socket.removeAllListeners();
			if (res.statusCode !== 200) {
				debug$1("tunneling socket could not be established, statusCode=%d", res.statusCode);
				socket.destroy();
				var error$2 = /* @__PURE__ */ new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
				error$2.code = "ECONNRESET";
				options.request.emit("error", error$2);
				self.removeSocket(placeholder);
				return;
			}
			if (head.length > 0) {
				debug$1("got illegal response body from proxy");
				socket.destroy();
				var error$2 = /* @__PURE__ */ new Error("got illegal response body from proxy");
				error$2.code = "ECONNRESET";
				options.request.emit("error", error$2);
				self.removeSocket(placeholder);
				return;
			}
			debug$1("tunneling connection has established");
			self.sockets[self.sockets.indexOf(placeholder)] = socket;
			return cb(socket);
		}
		function onError$1(cause) {
			connectReq.removeAllListeners();
			debug$1("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
			var error$2 = /* @__PURE__ */ new Error("tunneling socket could not be established, cause=" + cause.message);
			error$2.code = "ECONNRESET";
			options.request.emit("error", error$2);
			self.removeSocket(placeholder);
		}
	};
	TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
		var pos = this.sockets.indexOf(socket);
		if (pos === -1) return;
		this.sockets.splice(pos, 1);
		var pending = this.requests.shift();
		if (pending) this.createSocket(pending, function(socket$1) {
			pending.request.onSocket(socket$1);
		});
	};
	function createSecureSocket(options, cb) {
		var self = this;
		TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
			var hostHeader = options.request.getHeader("host");
			var tlsOptions = mergeOptions({}, self.options, {
				socket,
				servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
			});
			var secureSocket = tls$1.connect(0, tlsOptions);
			self.sockets[self.sockets.indexOf(socket)] = secureSocket;
			cb(secureSocket);
		});
	}
	function toOptions(host, port, localAddress) {
		if (typeof host === "string") return {
			host,
			port,
			localAddress
		};
		return host;
	}
	function mergeOptions(target) {
		for (var i$5 = 1, len = arguments.length; i$5 < len; ++i$5) {
			var overrides = arguments[i$5];
			if (typeof overrides === "object") {
				var keys = Object.keys(overrides);
				for (var j$5 = 0, keyLen = keys.length; j$5 < keyLen; ++j$5) {
					var k$5 = keys[j$5];
					if (overrides[k$5] !== void 0) target[k$5] = overrides[k$5];
				}
			}
		}
		return target;
	}
	var debug$1;
	if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) debug$1 = function() {
		var args = Array.prototype.slice.call(arguments);
		if (typeof args[0] === "string") args[0] = "TUNNEL: " + args[0];
		else args.unshift("TUNNEL:");
		console.error.apply(console, args);
	};
	else debug$1 = function() {};
	exports.debug = debug$1;
}));

//#endregion
//#region node_modules/tunnel/index.js
var require_tunnel = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = require_tunnel$1();
}));

//#endregion
//#region node_modules/undici/lib/core/symbols.js
var require_symbols$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kClose: Symbol("close"),
		kDestroy: Symbol("destroy"),
		kDispatch: Symbol("dispatch"),
		kUrl: Symbol("url"),
		kWriting: Symbol("writing"),
		kResuming: Symbol("resuming"),
		kQueue: Symbol("queue"),
		kConnect: Symbol("connect"),
		kConnecting: Symbol("connecting"),
		kHeadersList: Symbol("headers list"),
		kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
		kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
		kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
		kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
		kKeepAlive: Symbol("keep alive"),
		kHeadersTimeout: Symbol("headers timeout"),
		kBodyTimeout: Symbol("body timeout"),
		kServerName: Symbol("server name"),
		kLocalAddress: Symbol("local address"),
		kHost: Symbol("host"),
		kNoRef: Symbol("no ref"),
		kBodyUsed: Symbol("used"),
		kRunning: Symbol("running"),
		kBlocking: Symbol("blocking"),
		kPending: Symbol("pending"),
		kSize: Symbol("size"),
		kBusy: Symbol("busy"),
		kQueued: Symbol("queued"),
		kFree: Symbol("free"),
		kConnected: Symbol("connected"),
		kClosed: Symbol("closed"),
		kNeedDrain: Symbol("need drain"),
		kReset: Symbol("reset"),
		kDestroyed: Symbol.for("nodejs.stream.destroyed"),
		kMaxHeadersSize: Symbol("max headers size"),
		kRunningIdx: Symbol("running index"),
		kPendingIdx: Symbol("pending index"),
		kError: Symbol("error"),
		kClients: Symbol("clients"),
		kClient: Symbol("client"),
		kParser: Symbol("parser"),
		kOnDestroyed: Symbol("destroy callbacks"),
		kPipelining: Symbol("pipelining"),
		kSocket: Symbol("socket"),
		kHostHeader: Symbol("host header"),
		kConnector: Symbol("connector"),
		kStrictContentLength: Symbol("strict content length"),
		kMaxRedirections: Symbol("maxRedirections"),
		kMaxRequests: Symbol("maxRequestsPerClient"),
		kProxy: Symbol("proxy agent options"),
		kCounter: Symbol("socket request counter"),
		kInterceptors: Symbol("dispatch interceptors"),
		kMaxResponseSize: Symbol("max response size"),
		kHTTP2Session: Symbol("http2Session"),
		kHTTP2SessionState: Symbol("http2Session state"),
		kHTTP2BuildRequest: Symbol("http2 build request"),
		kHTTP1BuildRequest: Symbol("http1 build request"),
		kHTTP2CopyHeaders: Symbol("http2 copy headers"),
		kHTTPConnVersion: Symbol("http connection version"),
		kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
		kConstruct: Symbol("constructable")
	};
}));

//#endregion
//#region node_modules/undici/lib/core/errors.js
var require_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	var UndiciError$2 = class extends Error {
		constructor(message) {
			super(message);
			this.name = "UndiciError";
			this.code = "UND_ERR";
		}
	};
	var ConnectTimeoutError$1 = class ConnectTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ConnectTimeoutError$1);
			this.name = "ConnectTimeoutError";
			this.message = message || "Connect Timeout Error";
			this.code = "UND_ERR_CONNECT_TIMEOUT";
		}
	};
	var HeadersTimeoutError$1 = class HeadersTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersTimeoutError$1);
			this.name = "HeadersTimeoutError";
			this.message = message || "Headers Timeout Error";
			this.code = "UND_ERR_HEADERS_TIMEOUT";
		}
	};
	var HeadersOverflowError$1 = class HeadersOverflowError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, HeadersOverflowError$1);
			this.name = "HeadersOverflowError";
			this.message = message || "Headers Overflow Error";
			this.code = "UND_ERR_HEADERS_OVERFLOW";
		}
	};
	var BodyTimeoutError$1 = class BodyTimeoutError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, BodyTimeoutError$1);
			this.name = "BodyTimeoutError";
			this.message = message || "Body Timeout Error";
			this.code = "UND_ERR_BODY_TIMEOUT";
		}
	};
	var ResponseStatusCodeError$1 = class ResponseStatusCodeError$1 extends UndiciError$2 {
		constructor(message, statusCode, headers, body) {
			super(message);
			Error.captureStackTrace(this, ResponseStatusCodeError$1);
			this.name = "ResponseStatusCodeError";
			this.message = message || "Response Status Code Error";
			this.code = "UND_ERR_RESPONSE_STATUS_CODE";
			this.body = body;
			this.status = statusCode;
			this.statusCode = statusCode;
			this.headers = headers;
		}
	};
	var InvalidArgumentError$22 = class InvalidArgumentError$22 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidArgumentError$22);
			this.name = "InvalidArgumentError";
			this.message = message || "Invalid Argument Error";
			this.code = "UND_ERR_INVALID_ARG";
		}
	};
	var InvalidReturnValueError$2 = class InvalidReturnValueError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InvalidReturnValueError$2);
			this.name = "InvalidReturnValueError";
			this.message = message || "Invalid Return Value Error";
			this.code = "UND_ERR_INVALID_RETURN_VALUE";
		}
	};
	var RequestAbortedError$9 = class RequestAbortedError$9 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestAbortedError$9);
			this.name = "AbortError";
			this.message = message || "Request aborted";
			this.code = "UND_ERR_ABORTED";
		}
	};
	var InformationalError$1 = class InformationalError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, InformationalError$1);
			this.name = "InformationalError";
			this.message = message || "Request information";
			this.code = "UND_ERR_INFO";
		}
	};
	var RequestContentLengthMismatchError$1 = class RequestContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, RequestContentLengthMismatchError$1);
			this.name = "RequestContentLengthMismatchError";
			this.message = message || "Request body length does not match content-length header";
			this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ResponseContentLengthMismatchError$1 = class ResponseContentLengthMismatchError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseContentLengthMismatchError$1);
			this.name = "ResponseContentLengthMismatchError";
			this.message = message || "Response body length does not match content-length header";
			this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
		}
	};
	var ClientDestroyedError$2 = class ClientDestroyedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientDestroyedError$2);
			this.name = "ClientDestroyedError";
			this.message = message || "The client is destroyed";
			this.code = "UND_ERR_DESTROYED";
		}
	};
	var ClientClosedError$1 = class ClientClosedError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ClientClosedError$1);
			this.name = "ClientClosedError";
			this.message = message || "The client is closed";
			this.code = "UND_ERR_CLOSED";
		}
	};
	var SocketError$3 = class SocketError$3 extends UndiciError$2 {
		constructor(message, socket) {
			super(message);
			Error.captureStackTrace(this, SocketError$3);
			this.name = "SocketError";
			this.message = message || "Socket error";
			this.code = "UND_ERR_SOCKET";
			this.socket = socket;
		}
	};
	var NotSupportedError$2 = class NotSupportedError$2 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "NotSupportedError";
			this.message = message || "Not supported error";
			this.code = "UND_ERR_NOT_SUPPORTED";
		}
	};
	var BalancedPoolMissingUpstreamError$1 = class extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, NotSupportedError$2);
			this.name = "MissingUpstreamError";
			this.message = message || "No upstream has been added to the BalancedPool";
			this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
		}
	};
	var HTTPParserError$1 = class HTTPParserError$1 extends Error {
		constructor(message, code, data$1) {
			super(message);
			Error.captureStackTrace(this, HTTPParserError$1);
			this.name = "HTTPParserError";
			this.code = code ? `HPE_${code}` : void 0;
			this.data = data$1 ? data$1.toString() : void 0;
		}
	};
	var ResponseExceededMaxSizeError$1 = class ResponseExceededMaxSizeError$1 extends UndiciError$2 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, ResponseExceededMaxSizeError$1);
			this.name = "ResponseExceededMaxSizeError";
			this.message = message || "Response content exceeded max size";
			this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
		}
	};
	var RequestRetryError$1 = class RequestRetryError$1 extends UndiciError$2 {
		constructor(message, code, { headers, data: data$1 }) {
			super(message);
			Error.captureStackTrace(this, RequestRetryError$1);
			this.name = "RequestRetryError";
			this.message = message || "Request retry error";
			this.code = "UND_ERR_REQ_RETRY";
			this.statusCode = code;
			this.data = data$1;
			this.headers = headers;
		}
	};
	module.exports = {
		HTTPParserError: HTTPParserError$1,
		UndiciError: UndiciError$2,
		HeadersTimeoutError: HeadersTimeoutError$1,
		HeadersOverflowError: HeadersOverflowError$1,
		BodyTimeoutError: BodyTimeoutError$1,
		RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
		ConnectTimeoutError: ConnectTimeoutError$1,
		ResponseStatusCodeError: ResponseStatusCodeError$1,
		InvalidArgumentError: InvalidArgumentError$22,
		InvalidReturnValueError: InvalidReturnValueError$2,
		RequestAbortedError: RequestAbortedError$9,
		ClientDestroyedError: ClientDestroyedError$2,
		ClientClosedError: ClientClosedError$1,
		InformationalError: InformationalError$1,
		SocketError: SocketError$3,
		NotSupportedError: NotSupportedError$2,
		ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
		BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError$1,
		ResponseExceededMaxSizeError: ResponseExceededMaxSizeError$1,
		RequestRetryError: RequestRetryError$1
	};
}));

//#endregion
//#region node_modules/undici/lib/core/constants.js
var require_constants$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/** @type {Record<string, string | undefined>} */
	const headerNameLowerCasedRecord$1 = {};
	const wellknownHeaderNames = [
		"Accept",
		"Accept-Encoding",
		"Accept-Language",
		"Accept-Ranges",
		"Access-Control-Allow-Credentials",
		"Access-Control-Allow-Headers",
		"Access-Control-Allow-Methods",
		"Access-Control-Allow-Origin",
		"Access-Control-Expose-Headers",
		"Access-Control-Max-Age",
		"Access-Control-Request-Headers",
		"Access-Control-Request-Method",
		"Age",
		"Allow",
		"Alt-Svc",
		"Alt-Used",
		"Authorization",
		"Cache-Control",
		"Clear-Site-Data",
		"Connection",
		"Content-Disposition",
		"Content-Encoding",
		"Content-Language",
		"Content-Length",
		"Content-Location",
		"Content-Range",
		"Content-Security-Policy",
		"Content-Security-Policy-Report-Only",
		"Content-Type",
		"Cookie",
		"Cross-Origin-Embedder-Policy",
		"Cross-Origin-Opener-Policy",
		"Cross-Origin-Resource-Policy",
		"Date",
		"Device-Memory",
		"Downlink",
		"ECT",
		"ETag",
		"Expect",
		"Expect-CT",
		"Expires",
		"Forwarded",
		"From",
		"Host",
		"If-Match",
		"If-Modified-Since",
		"If-None-Match",
		"If-Range",
		"If-Unmodified-Since",
		"Keep-Alive",
		"Last-Modified",
		"Link",
		"Location",
		"Max-Forwards",
		"Origin",
		"Permissions-Policy",
		"Pragma",
		"Proxy-Authenticate",
		"Proxy-Authorization",
		"RTT",
		"Range",
		"Referer",
		"Referrer-Policy",
		"Refresh",
		"Retry-After",
		"Sec-WebSocket-Accept",
		"Sec-WebSocket-Extensions",
		"Sec-WebSocket-Key",
		"Sec-WebSocket-Protocol",
		"Sec-WebSocket-Version",
		"Server",
		"Server-Timing",
		"Service-Worker-Allowed",
		"Service-Worker-Navigation-Preload",
		"Set-Cookie",
		"SourceMap",
		"Strict-Transport-Security",
		"Supports-Loading-Mode",
		"TE",
		"Timing-Allow-Origin",
		"Trailer",
		"Transfer-Encoding",
		"Upgrade",
		"Upgrade-Insecure-Requests",
		"User-Agent",
		"Vary",
		"Via",
		"WWW-Authenticate",
		"X-Content-Type-Options",
		"X-DNS-Prefetch-Control",
		"X-Frame-Options",
		"X-Permitted-Cross-Domain-Policies",
		"X-Powered-By",
		"X-Requested-With",
		"X-XSS-Protection"
	];
	for (let i$5 = 0; i$5 < wellknownHeaderNames.length; ++i$5) {
		const key = wellknownHeaderNames[i$5];
		const lowerCasedKey = key.toLowerCase();
		headerNameLowerCasedRecord$1[key] = headerNameLowerCasedRecord$1[lowerCasedKey] = lowerCasedKey;
	}
	Object.setPrototypeOf(headerNameLowerCasedRecord$1, null);
	module.exports = {
		wellknownHeaderNames,
		headerNameLowerCasedRecord: headerNameLowerCasedRecord$1
	};
}));

//#endregion
//#region node_modules/undici/lib/core/util.js
var require_util$6 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$19 = __require("assert");
	const { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$2 } = require_symbols$4();
	const { IncomingMessage } = __require("http");
	const stream$2 = __require("stream");
	const net$2 = __require("net");
	const { InvalidArgumentError: InvalidArgumentError$21 } = require_errors();
	const { Blob: Blob$5 } = __require("buffer");
	const nodeUtil = __require("util");
	const { stringify: stringify$2 } = __require("querystring");
	const { headerNameLowerCasedRecord } = require_constants$4();
	const [nodeMajor$1, nodeMinor$1] = process.versions.node.split(".").map((v$5) => Number(v$5));
	function nop$1() {}
	function isStream(obj) {
		return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
	}
	function isBlobLike$7(object) {
		return Blob$5 && object instanceof Blob$5 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
	}
	function buildURL$2(url$1, queryParams) {
		if (url$1.includes("?") || url$1.includes("#")) throw new Error("Query params cannot be passed when url already contains \"?\" or \"#\".");
		const stringified = stringify$2(queryParams);
		if (stringified) url$1 += "?" + stringified;
		return url$1;
	}
	function parseURL$1(url$1) {
		if (typeof url$1 === "string") {
			url$1 = new URL(url$1);
			if (!/^https?:/.test(url$1.origin || url$1.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
			return url$1;
		}
		if (!url$1 || typeof url$1 !== "object") throw new InvalidArgumentError$21("Invalid URL: The URL argument must be a non-null object.");
		if (!/^https?:/.test(url$1.origin || url$1.protocol)) throw new InvalidArgumentError$21("Invalid URL protocol: the URL must start with `http:` or `https:`.");
		if (!(url$1 instanceof URL)) {
			if (url$1.port != null && url$1.port !== "" && !Number.isFinite(parseInt(url$1.port))) throw new InvalidArgumentError$21("Invalid URL: port must be a valid integer or a string representation of an integer.");
			if (url$1.path != null && typeof url$1.path !== "string") throw new InvalidArgumentError$21("Invalid URL path: the path must be a string or null/undefined.");
			if (url$1.pathname != null && typeof url$1.pathname !== "string") throw new InvalidArgumentError$21("Invalid URL pathname: the pathname must be a string or null/undefined.");
			if (url$1.hostname != null && typeof url$1.hostname !== "string") throw new InvalidArgumentError$21("Invalid URL hostname: the hostname must be a string or null/undefined.");
			if (url$1.origin != null && typeof url$1.origin !== "string") throw new InvalidArgumentError$21("Invalid URL origin: the origin must be a string or null/undefined.");
			const port = url$1.port != null ? url$1.port : url$1.protocol === "https:" ? 443 : 80;
			let origin = url$1.origin != null ? url$1.origin : `${url$1.protocol}//${url$1.hostname}:${port}`;
			let path$6 = url$1.path != null ? url$1.path : `${url$1.pathname || ""}${url$1.search || ""}`;
			if (origin.endsWith("/")) origin = origin.substring(0, origin.length - 1);
			if (path$6 && !path$6.startsWith("/")) path$6 = `/${path$6}`;
			url$1 = new URL(origin + path$6);
		}
		return url$1;
	}
	function parseOrigin$1(url$1) {
		url$1 = parseURL$1(url$1);
		if (url$1.pathname !== "/" || url$1.search || url$1.hash) throw new InvalidArgumentError$21("invalid url");
		return url$1;
	}
	function getHostname(host) {
		if (host[0] === "[") {
			const idx$1 = host.indexOf("]");
			assert$19(idx$1 !== -1);
			return host.substring(1, idx$1);
		}
		const idx = host.indexOf(":");
		if (idx === -1) return host;
		return host.substring(0, idx);
	}
	function getServerName(host) {
		if (!host) return null;
		assert$19.strictEqual(typeof host, "string");
		const servername = getHostname(host);
		if (net$2.isIP(servername)) return "";
		return servername;
	}
	function deepClone(obj) {
		return JSON.parse(JSON.stringify(obj));
	}
	function isAsyncIterable(obj) {
		return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
	}
	function isIterable(obj) {
		return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
	}
	function bodyLength(body) {
		if (body == null) return 0;
		else if (isStream(body)) {
			const state$1 = body._readableState;
			return state$1 && state$1.objectMode === false && state$1.ended === true && Number.isFinite(state$1.length) ? state$1.length : null;
		} else if (isBlobLike$7(body)) return body.size != null ? body.size : null;
		else if (isBuffer(body)) return body.byteLength;
		return null;
	}
	function isDestroyed(stream$3) {
		return !stream$3 || !!(stream$3.destroyed || stream$3[kDestroyed$1]);
	}
	function isReadableAborted(stream$3) {
		const state$1 = stream$3 && stream$3._readableState;
		return isDestroyed(stream$3) && state$1 && !state$1.endEmitted;
	}
	function destroy(stream$3, err) {
		if (stream$3 == null || !isStream(stream$3) || isDestroyed(stream$3)) return;
		if (typeof stream$3.destroy === "function") {
			if (Object.getPrototypeOf(stream$3).constructor === IncomingMessage) stream$3.socket = null;
			stream$3.destroy(err);
		} else if (err) process.nextTick((stream$4, err$1) => {
			stream$4.emit("error", err$1);
		}, stream$3, err);
		if (stream$3.destroyed !== true) stream$3[kDestroyed$1] = true;
	}
	const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
	function parseKeepAliveTimeout(val) {
		const m$5 = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
		return m$5 ? parseInt(m$5[1], 10) * 1e3 : null;
	}
	/**
	* Retrieves a header name and returns its lowercase value.
	* @param {string | Buffer} value Header name
	* @returns {string}
	*/
	function headerNameToString(value) {
		return headerNameLowerCasedRecord[value] || value.toLowerCase();
	}
	function parseHeaders$1(headers, obj = {}) {
		if (!Array.isArray(headers)) return headers;
		for (let i$5 = 0; i$5 < headers.length; i$5 += 2) {
			const key = headers[i$5].toString().toLowerCase();
			let val = obj[key];
			if (!val) if (Array.isArray(headers[i$5 + 1])) obj[key] = headers[i$5 + 1].map((x$5) => x$5.toString("utf8"));
			else obj[key] = headers[i$5 + 1].toString("utf8");
			else {
				if (!Array.isArray(val)) {
					val = [val];
					obj[key] = val;
				}
				val.push(headers[i$5 + 1].toString("utf8"));
			}
		}
		if ("content-length" in obj && "content-disposition" in obj) obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
		return obj;
	}
	function parseRawHeaders(headers) {
		const ret = [];
		let hasContentLength = false;
		let contentDispositionIdx = -1;
		for (let n$5 = 0; n$5 < headers.length; n$5 += 2) {
			const key = headers[n$5 + 0].toString();
			const val = headers[n$5 + 1].toString("utf8");
			if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
				ret.push(key, val);
				hasContentLength = true;
			} else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) contentDispositionIdx = ret.push(key, val) - 1;
			else ret.push(key, val);
		}
		if (hasContentLength && contentDispositionIdx !== -1) ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
		return ret;
	}
	function isBuffer(buffer$3) {
		return buffer$3 instanceof Uint8Array || Buffer.isBuffer(buffer$3);
	}
	function validateHandler(handler, method, upgrade$1) {
		if (!handler || typeof handler !== "object") throw new InvalidArgumentError$21("handler must be an object");
		if (typeof handler.onConnect !== "function") throw new InvalidArgumentError$21("invalid onConnect method");
		if (typeof handler.onError !== "function") throw new InvalidArgumentError$21("invalid onError method");
		if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) throw new InvalidArgumentError$21("invalid onBodySent method");
		if (upgrade$1 || method === "CONNECT") {
			if (typeof handler.onUpgrade !== "function") throw new InvalidArgumentError$21("invalid onUpgrade method");
		} else {
			if (typeof handler.onHeaders !== "function") throw new InvalidArgumentError$21("invalid onHeaders method");
			if (typeof handler.onData !== "function") throw new InvalidArgumentError$21("invalid onData method");
			if (typeof handler.onComplete !== "function") throw new InvalidArgumentError$21("invalid onComplete method");
		}
	}
	function isDisturbed$2(body) {
		return !!(body && (stream$2.isDisturbed ? stream$2.isDisturbed(body) || body[kBodyUsed$2] : body[kBodyUsed$2] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
	}
	function isErrored$2(body) {
		return !!(body && (stream$2.isErrored ? stream$2.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
	}
	function isReadable$1(body) {
		return !!(body && (stream$2.isReadable ? stream$2.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
	}
	function getSocketInfo(socket) {
		return {
			localAddress: socket.localAddress,
			localPort: socket.localPort,
			remoteAddress: socket.remoteAddress,
			remotePort: socket.remotePort,
			remoteFamily: socket.remoteFamily,
			timeout: socket.timeout,
			bytesWritten: socket.bytesWritten,
			bytesRead: socket.bytesRead
		};
	}
	async function* convertIterableToBuffer(iterable) {
		for await (const chunk of iterable) yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
	}
	let ReadableStream$6;
	function ReadableStreamFrom$3(iterable) {
		if (!ReadableStream$6) ReadableStream$6 = __require("stream/web").ReadableStream;
		if (ReadableStream$6.from) return ReadableStream$6.from(convertIterableToBuffer(iterable));
		let iterator;
		return new ReadableStream$6({
			async start() {
				iterator = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done, value } = await iterator.next();
				if (done) queueMicrotask(() => {
					controller.close();
				});
				else {
					const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator.return();
			}
		}, 0);
	}
	function isFormDataLike(object) {
		return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
	}
	function throwIfAborted$1(signal) {
		if (!signal) return;
		if (typeof signal.throwIfAborted === "function") signal.throwIfAborted();
		else if (signal.aborted) {
			const err = /* @__PURE__ */ new Error("The operation was aborted");
			err.name = "AbortError";
			throw err;
		}
	}
	function addAbortListener$2(signal, listener) {
		if ("addEventListener" in signal) {
			signal.addEventListener("abort", listener, { once: true });
			return () => signal.removeEventListener("abort", listener);
		}
		signal.addListener("abort", listener);
		return () => signal.removeListener("abort", listener);
	}
	const hasToWellFormed = !!String.prototype.toWellFormed;
	/**
	* @param {string} val
	*/
	function toUSVString$5(val) {
		if (hasToWellFormed) return `${val}`.toWellFormed();
		else if (nodeUtil.toUSVString) return nodeUtil.toUSVString(val);
		return `${val}`;
	}
	function parseRangeHeader$1(range$1) {
		if (range$1 == null || range$1 === "") return {
			start: 0,
			end: null,
			size: null
		};
		const m$5 = range$1 ? range$1.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
		return m$5 ? {
			start: parseInt(m$5[1]),
			end: m$5[2] ? parseInt(m$5[2]) : null,
			size: m$5[3] ? parseInt(m$5[3]) : null
		} : null;
	}
	const kEnumerableProperty$9 = Object.create(null);
	kEnumerableProperty$9.enumerable = true;
	module.exports = {
		kEnumerableProperty: kEnumerableProperty$9,
		nop: nop$1,
		isDisturbed: isDisturbed$2,
		isErrored: isErrored$2,
		isReadable: isReadable$1,
		toUSVString: toUSVString$5,
		isReadableAborted,
		isBlobLike: isBlobLike$7,
		parseOrigin: parseOrigin$1,
		parseURL: parseURL$1,
		getServerName,
		isStream,
		isIterable,
		isAsyncIterable,
		isDestroyed,
		headerNameToString,
		parseRawHeaders,
		parseHeaders: parseHeaders$1,
		parseKeepAliveTimeout,
		destroy,
		bodyLength,
		deepClone,
		ReadableStreamFrom: ReadableStreamFrom$3,
		isBuffer,
		validateHandler,
		getSocketInfo,
		isFormDataLike,
		buildURL: buildURL$2,
		throwIfAborted: throwIfAborted$1,
		addAbortListener: addAbortListener$2,
		parseRangeHeader: parseRangeHeader$1,
		nodeMajor: nodeMajor$1,
		nodeMinor: nodeMinor$1,
		nodeHasAutoSelectFamily: nodeMajor$1 > 18 || nodeMajor$1 === 18 && nodeMinor$1 >= 13,
		safeHTTPMethods: [
			"GET",
			"HEAD",
			"OPTIONS",
			"TRACE"
		]
	};
}));

//#endregion
//#region node_modules/undici/lib/timers.js
var require_timers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	let fastNow = Date.now();
	let fastNowTimeout;
	const fastTimers = [];
	function onTimeout() {
		fastNow = Date.now();
		let len = fastTimers.length;
		let idx = 0;
		while (idx < len) {
			const timer = fastTimers[idx];
			if (timer.state === 0) timer.state = fastNow + timer.delay;
			else if (timer.state > 0 && fastNow >= timer.state) {
				timer.state = -1;
				timer.callback(timer.opaque);
			}
			if (timer.state === -1) {
				timer.state = -2;
				if (idx !== len - 1) fastTimers[idx] = fastTimers.pop();
				else fastTimers.pop();
				len -= 1;
			} else idx += 1;
		}
		if (fastTimers.length > 0) refreshTimeout();
	}
	function refreshTimeout() {
		if (fastNowTimeout && fastNowTimeout.refresh) fastNowTimeout.refresh();
		else {
			clearTimeout(fastNowTimeout);
			fastNowTimeout = setTimeout(onTimeout, 1e3);
			if (fastNowTimeout.unref) fastNowTimeout.unref();
		}
	}
	var Timeout = class {
		constructor(callback, delay, opaque) {
			this.callback = callback;
			this.delay = delay;
			this.opaque = opaque;
			this.state = -2;
			this.refresh();
		}
		refresh() {
			if (this.state === -2) {
				fastTimers.push(this);
				if (!fastNowTimeout || fastTimers.length === 1) refreshTimeout();
			}
			this.state = 0;
		}
		clear() {
			this.state = -1;
		}
	};
	module.exports = {
		setTimeout(callback, delay, opaque) {
			return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
		},
		clearTimeout(timeout) {
			if (timeout instanceof Timeout) timeout.clear();
			else clearTimeout(timeout);
		}
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* Copyright Brian White. All rights reserved.
	*
	* @see https://github.com/mscdex/streamsearch
	*
	* Permission is hereby granted, free of charge, to any person obtaining a copy
	* of this software and associated documentation files (the "Software"), to
	* deal in the Software without restriction, including without limitation the
	* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	* sell copies of the Software, and to permit persons to whom the Software is
	* furnished to do so, subject to the following conditions:
	*
	* The above copyright notice and this permission notice shall be included in
	* all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	* IN THE SOFTWARE.
	*
	* Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation
	* by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool
	*/
	const EventEmitter$2 = __require("node:events").EventEmitter;
	const inherits$5 = __require("node:util").inherits;
	function SBMH(needle) {
		if (typeof needle === "string") needle = Buffer.from(needle);
		if (!Buffer.isBuffer(needle)) throw new TypeError("The needle has to be a String or a Buffer.");
		const needleLength = needle.length;
		if (needleLength === 0) throw new Error("The needle cannot be an empty String/Buffer.");
		if (needleLength > 256) throw new Error("The needle cannot have a length bigger than 256.");
		this.maxMatches = Infinity;
		this.matches = 0;
		this._occ = new Array(256).fill(needleLength);
		this._lookbehind_size = 0;
		this._needle = needle;
		this._bufpos = 0;
		this._lookbehind = Buffer.alloc(needleLength);
		for (var i$5 = 0; i$5 < needleLength - 1; ++i$5) this._occ[needle[i$5]] = needleLength - 1 - i$5;
	}
	inherits$5(SBMH, EventEmitter$2);
	SBMH.prototype.reset = function() {
		this._lookbehind_size = 0;
		this.matches = 0;
		this._bufpos = 0;
	};
	SBMH.prototype.push = function(chunk, pos) {
		if (!Buffer.isBuffer(chunk)) chunk = Buffer.from(chunk, "binary");
		const chlen = chunk.length;
		this._bufpos = pos || 0;
		let r$5;
		while (r$5 !== chlen && this.matches < this.maxMatches) r$5 = this._sbmh_feed(chunk);
		return r$5;
	};
	SBMH.prototype._sbmh_feed = function(data$1) {
		const len = data$1.length;
		const needle = this._needle;
		const needleLength = needle.length;
		const lastNeedleChar = needle[needleLength - 1];
		let pos = -this._lookbehind_size;
		let ch;
		if (pos < 0) {
			while (pos < 0 && pos <= len - needleLength) {
				ch = this._sbmh_lookup_char(data$1, pos + needleLength - 1);
				if (ch === lastNeedleChar && this._sbmh_memcmp(data$1, pos, needleLength - 1)) {
					this._lookbehind_size = 0;
					++this.matches;
					this.emit("info", true);
					return this._bufpos = pos + needleLength;
				}
				pos += this._occ[ch];
			}
			if (pos < 0) while (pos < 0 && !this._sbmh_memcmp(data$1, pos, len - pos)) ++pos;
			if (pos >= 0) {
				this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
				this._lookbehind_size = 0;
			} else {
				const bytesToCutOff = this._lookbehind_size + pos;
				if (bytesToCutOff > 0) this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
				this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size - bytesToCutOff);
				this._lookbehind_size -= bytesToCutOff;
				data$1.copy(this._lookbehind, this._lookbehind_size);
				this._lookbehind_size += len;
				this._bufpos = len;
				return len;
			}
		}
		pos += (pos >= 0) * this._bufpos;
		if (data$1.indexOf(needle, pos) !== -1) {
			pos = data$1.indexOf(needle, pos);
			++this.matches;
			if (pos > 0) this.emit("info", true, data$1, this._bufpos, pos);
			else this.emit("info", true);
			return this._bufpos = pos + needleLength;
		} else pos = len - needleLength;
		while (pos < len && (data$1[pos] !== needle[0] || Buffer.compare(data$1.subarray(pos, pos + len - pos), needle.subarray(0, len - pos)) !== 0)) ++pos;
		if (pos < len) {
			data$1.copy(this._lookbehind, 0, pos, pos + (len - pos));
			this._lookbehind_size = len - pos;
		}
		if (pos > 0) this.emit("info", false, data$1, this._bufpos, pos < len ? pos : len);
		this._bufpos = len;
		return len;
	};
	SBMH.prototype._sbmh_lookup_char = function(data$1, pos) {
		return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data$1[pos];
	};
	SBMH.prototype._sbmh_memcmp = function(data$1, pos, len) {
		for (var i$5 = 0; i$5 < len; ++i$5) if (this._sbmh_lookup_char(data$1, pos + i$5) !== this._needle[i$5]) return false;
		return true;
	};
	module.exports = SBMH;
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const inherits$4 = __require("node:util").inherits;
	const ReadableStream$5 = __require("node:stream").Readable;
	function PartStream$1(opts) {
		ReadableStream$5.call(this, opts);
	}
	inherits$4(PartStream$1, ReadableStream$5);
	PartStream$1.prototype._read = function(n$5) {};
	module.exports = PartStream$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function getLimit$3(limits, name, defaultLimit) {
		if (!limits || limits[name] === void 0 || limits[name] === null) return defaultLimit;
		if (typeof limits[name] !== "number" || isNaN(limits[name])) throw new TypeError("Limit " + name + " is not a valid number");
		return limits[name];
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter$1 = __require("node:events").EventEmitter;
	const inherits$3 = __require("node:util").inherits;
	const getLimit$2 = require_getLimit();
	const StreamSearch$1 = require_sbmh();
	const B_DCRLF = Buffer.from("\r\n\r\n");
	const RE_CRLF = /\r\n/g;
	const RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
	function HeaderParser$1(cfg) {
		EventEmitter$1.call(this);
		cfg = cfg || {};
		const self = this;
		this.nread = 0;
		this.maxed = false;
		this.npairs = 0;
		this.maxHeaderPairs = getLimit$2(cfg, "maxHeaderPairs", 2e3);
		this.maxHeaderSize = getLimit$2(cfg, "maxHeaderSize", 80 * 1024);
		this.buffer = "";
		this.header = {};
		this.finished = false;
		this.ss = new StreamSearch$1(B_DCRLF);
		this.ss.on("info", function(isMatch, data$1, start, end) {
			if (data$1 && !self.maxed) {
				if (self.nread + end - start >= self.maxHeaderSize) {
					end = self.maxHeaderSize - self.nread + start;
					self.nread = self.maxHeaderSize;
					self.maxed = true;
				} else self.nread += end - start;
				self.buffer += data$1.toString("binary", start, end);
			}
			if (isMatch) self._finish();
		});
	}
	inherits$3(HeaderParser$1, EventEmitter$1);
	HeaderParser$1.prototype.push = function(data$1) {
		const r$5 = this.ss.push(data$1);
		if (this.finished) return r$5;
	};
	HeaderParser$1.prototype.reset = function() {
		this.finished = false;
		this.buffer = "";
		this.header = {};
		this.ss.reset();
	};
	HeaderParser$1.prototype._finish = function() {
		if (this.buffer) this._parseHeader();
		this.ss.matches = this.ss.maxMatches;
		const header = this.header;
		this.header = {};
		this.buffer = "";
		this.finished = true;
		this.nread = this.npairs = 0;
		this.maxed = false;
		this.emit("header", header);
	};
	HeaderParser$1.prototype._parseHeader = function() {
		if (this.npairs === this.maxHeaderPairs) return;
		const lines = this.buffer.split(RE_CRLF);
		const len = lines.length;
		let m$5, h$5;
		for (var i$5 = 0; i$5 < len; ++i$5) {
			if (lines[i$5].length === 0) continue;
			if (lines[i$5][0] === "	" || lines[i$5][0] === " ") {
				if (h$5) {
					this.header[h$5][this.header[h$5].length - 1] += lines[i$5];
					continue;
				}
			}
			const posColon = lines[i$5].indexOf(":");
			if (posColon === -1 || posColon === 0) return;
			m$5 = RE_HDR.exec(lines[i$5]);
			h$5 = m$5[1].toLowerCase();
			this.header[h$5] = this.header[h$5] || [];
			this.header[h$5].push(m$5[2] || "");
			if (++this.npairs === this.maxHeaderPairs) break;
		}
	};
	module.exports = HeaderParser$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const WritableStream$1 = __require("node:stream").Writable;
	const inherits$2 = __require("node:util").inherits;
	const StreamSearch = require_sbmh();
	const PartStream = require_PartStream();
	const HeaderParser = require_HeaderParser();
	const DASH = 45;
	const B_ONEDASH = Buffer.from("-");
	const B_CRLF = Buffer.from("\r\n");
	const EMPTY_FN = function() {};
	function Dicer$2(cfg) {
		if (!(this instanceof Dicer$2)) return new Dicer$2(cfg);
		WritableStream$1.call(this, cfg);
		if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") throw new TypeError("Boundary required");
		if (typeof cfg.boundary === "string") this.setBoundary(cfg.boundary);
		else this._bparser = void 0;
		this._headerFirst = cfg.headerFirst;
		this._dashes = 0;
		this._parts = 0;
		this._finished = false;
		this._realFinish = false;
		this._isPreamble = true;
		this._justMatched = false;
		this._firstWrite = true;
		this._inHeader = true;
		this._part = void 0;
		this._cb = void 0;
		this._ignoreData = false;
		this._partOpts = { highWaterMark: cfg.partHwm };
		this._pause = false;
		const self = this;
		this._hparser = new HeaderParser(cfg);
		this._hparser.on("header", function(header) {
			self._inHeader = false;
			self._part.emit("header", header);
		});
	}
	inherits$2(Dicer$2, WritableStream$1);
	Dicer$2.prototype.emit = function(ev) {
		if (ev === "finish" && !this._realFinish) {
			if (!this._finished) {
				const self = this;
				process.nextTick(function() {
					self.emit("error", /* @__PURE__ */ new Error("Unexpected end of multipart data"));
					if (self._part && !self._ignoreData) {
						const type = self._isPreamble ? "Preamble" : "Part";
						self._part.emit("error", /* @__PURE__ */ new Error(type + " terminated early due to unexpected end of multipart data"));
						self._part.push(null);
						process.nextTick(function() {
							self._realFinish = true;
							self.emit("finish");
							self._realFinish = false;
						});
						return;
					}
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				});
			}
		} else WritableStream$1.prototype.emit.apply(this, arguments);
	};
	Dicer$2.prototype._write = function(data$1, encoding, cb) {
		if (!this._hparser && !this._bparser) return cb();
		if (this._headerFirst && this._isPreamble) {
			if (!this._part) {
				this._part = new PartStream(this._partOpts);
				if (this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
				else this._ignore();
			}
			const r$5 = this._hparser.push(data$1);
			if (!this._inHeader && r$5 !== void 0 && r$5 < data$1.length) data$1 = data$1.slice(r$5);
			else return cb();
		}
		if (this._firstWrite) {
			this._bparser.push(B_CRLF);
			this._firstWrite = false;
		}
		this._bparser.push(data$1);
		if (this._pause) this._cb = cb;
		else cb();
	};
	Dicer$2.prototype.reset = function() {
		this._part = void 0;
		this._bparser = void 0;
		this._hparser = void 0;
	};
	Dicer$2.prototype.setBoundary = function(boundary) {
		const self = this;
		this._bparser = new StreamSearch("\r\n--" + boundary);
		this._bparser.on("info", function(isMatch, data$1, start, end) {
			self._oninfo(isMatch, data$1, start, end);
		});
	};
	Dicer$2.prototype._ignore = function() {
		if (this._part && !this._ignoreData) {
			this._ignoreData = true;
			this._part.on("error", EMPTY_FN);
			this._part.resume();
		}
	};
	Dicer$2.prototype._oninfo = function(isMatch, data$1, start, end) {
		let buf;
		const self = this;
		let i$5 = 0;
		let r$5;
		let shouldWriteMore = true;
		if (!this._part && this._justMatched && data$1) {
			while (this._dashes < 2 && start + i$5 < end) if (data$1[start + i$5] === DASH) {
				++i$5;
				++this._dashes;
			} else {
				if (this._dashes) buf = B_ONEDASH;
				this._dashes = 0;
				break;
			}
			if (this._dashes === 2) {
				if (start + i$5 < end && this.listenerCount("trailer") !== 0) this.emit("trailer", data$1.slice(start + i$5, end));
				this.reset();
				this._finished = true;
				if (self._parts === 0) {
					self._realFinish = true;
					self.emit("finish");
					self._realFinish = false;
				}
			}
			if (this._dashes) return;
		}
		if (this._justMatched) this._justMatched = false;
		if (!this._part) {
			this._part = new PartStream(this._partOpts);
			this._part._read = function(n$5) {
				self._unpause();
			};
			if (this._isPreamble && this.listenerCount("preamble") !== 0) this.emit("preamble", this._part);
			else if (this._isPreamble !== true && this.listenerCount("part") !== 0) this.emit("part", this._part);
			else this._ignore();
			if (!this._isPreamble) this._inHeader = true;
		}
		if (data$1 && start < end && !this._ignoreData) {
			if (this._isPreamble || !this._inHeader) {
				if (buf) shouldWriteMore = this._part.push(buf);
				shouldWriteMore = this._part.push(data$1.slice(start, end));
				if (!shouldWriteMore) this._pause = true;
			} else if (!this._isPreamble && this._inHeader) {
				if (buf) this._hparser.push(buf);
				r$5 = this._hparser.push(data$1.slice(start, end));
				if (!this._inHeader && r$5 !== void 0 && r$5 < end) this._oninfo(false, data$1, start + r$5, end);
			}
		}
		if (isMatch) {
			this._hparser.reset();
			if (this._isPreamble) this._isPreamble = false;
			else if (start !== end) {
				++this._parts;
				this._part.on("end", function() {
					if (--self._parts === 0) if (self._finished) {
						self._realFinish = true;
						self.emit("finish");
						self._realFinish = false;
					} else self._unpause();
				});
			}
			this._part.push(null);
			this._part = void 0;
			this._ignoreData = false;
			this._justMatched = true;
			this._dashes = 0;
		}
	};
	Dicer$2.prototype._unpause = function() {
		if (!this._pause) return;
		this._pause = false;
		if (this._cb) {
			const cb = this._cb;
			this._cb = void 0;
			cb();
		}
	};
	module.exports = Dicer$2;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const utf8Decoder = new TextDecoder("utf-8");
	const textDecoders = new Map([["utf-8", utf8Decoder], ["utf8", utf8Decoder]]);
	function getDecoder(charset) {
		let lc;
		while (true) switch (charset) {
			case "utf-8":
			case "utf8": return decoders.utf8;
			case "latin1":
			case "ascii":
			case "us-ascii":
			case "iso-8859-1":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "windows-1252":
			case "iso_8859-1:1987":
			case "cp1252":
			case "x-cp1252": return decoders.latin1;
			case "utf16le":
			case "utf-16le":
			case "ucs2":
			case "ucs-2": return decoders.utf16le;
			case "base64": return decoders.base64;
			default:
				if (lc === void 0) {
					lc = true;
					charset = charset.toLowerCase();
					continue;
				}
				return decoders.other.bind(charset);
		}
	}
	const decoders = {
		utf8: (data$1, sourceEncoding) => {
			if (data$1.length === 0) return "";
			if (typeof data$1 === "string") data$1 = Buffer.from(data$1, sourceEncoding);
			return data$1.utf8Slice(0, data$1.length);
		},
		latin1: (data$1, sourceEncoding) => {
			if (data$1.length === 0) return "";
			if (typeof data$1 === "string") return data$1;
			return data$1.latin1Slice(0, data$1.length);
		},
		utf16le: (data$1, sourceEncoding) => {
			if (data$1.length === 0) return "";
			if (typeof data$1 === "string") data$1 = Buffer.from(data$1, sourceEncoding);
			return data$1.ucs2Slice(0, data$1.length);
		},
		base64: (data$1, sourceEncoding) => {
			if (data$1.length === 0) return "";
			if (typeof data$1 === "string") data$1 = Buffer.from(data$1, sourceEncoding);
			return data$1.base64Slice(0, data$1.length);
		},
		other: (data$1, sourceEncoding) => {
			if (data$1.length === 0) return "";
			if (typeof data$1 === "string") data$1 = Buffer.from(data$1, sourceEncoding);
			if (textDecoders.has(exports.toString())) try {
				return textDecoders.get(exports).decode(data$1);
			} catch {}
			return typeof data$1 === "string" ? data$1 : data$1.toString();
		}
	};
	function decodeText$3(text, sourceEncoding, destEncoding) {
		if (text) return getDecoder(destEncoding)(text, sourceEncoding);
		return text;
	}
	module.exports = decodeText$3;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const decodeText$2 = require_decodeText();
	const RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
	const EncodedLookup = {
		"%00": "\0",
		"%01": "",
		"%02": "",
		"%03": "",
		"%04": "",
		"%05": "",
		"%06": "",
		"%07": "\x07",
		"%08": "\b",
		"%09": "	",
		"%0a": "\n",
		"%0A": "\n",
		"%0b": "\v",
		"%0B": "\v",
		"%0c": "\f",
		"%0C": "\f",
		"%0d": "\r",
		"%0D": "\r",
		"%0e": "",
		"%0E": "",
		"%0f": "",
		"%0F": "",
		"%10": "",
		"%11": "",
		"%12": "",
		"%13": "",
		"%14": "",
		"%15": "",
		"%16": "",
		"%17": "",
		"%18": "",
		"%19": "",
		"%1a": "",
		"%1A": "",
		"%1b": "\x1B",
		"%1B": "\x1B",
		"%1c": "",
		"%1C": "",
		"%1d": "",
		"%1D": "",
		"%1e": "",
		"%1E": "",
		"%1f": "",
		"%1F": "",
		"%20": " ",
		"%21": "!",
		"%22": "\"",
		"%23": "#",
		"%24": "$",
		"%25": "%",
		"%26": "&",
		"%27": "'",
		"%28": "(",
		"%29": ")",
		"%2a": "*",
		"%2A": "*",
		"%2b": "+",
		"%2B": "+",
		"%2c": ",",
		"%2C": ",",
		"%2d": "-",
		"%2D": "-",
		"%2e": ".",
		"%2E": ".",
		"%2f": "/",
		"%2F": "/",
		"%30": "0",
		"%31": "1",
		"%32": "2",
		"%33": "3",
		"%34": "4",
		"%35": "5",
		"%36": "6",
		"%37": "7",
		"%38": "8",
		"%39": "9",
		"%3a": ":",
		"%3A": ":",
		"%3b": ";",
		"%3B": ";",
		"%3c": "<",
		"%3C": "<",
		"%3d": "=",
		"%3D": "=",
		"%3e": ">",
		"%3E": ">",
		"%3f": "?",
		"%3F": "?",
		"%40": "@",
		"%41": "A",
		"%42": "B",
		"%43": "C",
		"%44": "D",
		"%45": "E",
		"%46": "F",
		"%47": "G",
		"%48": "H",
		"%49": "I",
		"%4a": "J",
		"%4A": "J",
		"%4b": "K",
		"%4B": "K",
		"%4c": "L",
		"%4C": "L",
		"%4d": "M",
		"%4D": "M",
		"%4e": "N",
		"%4E": "N",
		"%4f": "O",
		"%4F": "O",
		"%50": "P",
		"%51": "Q",
		"%52": "R",
		"%53": "S",
		"%54": "T",
		"%55": "U",
		"%56": "V",
		"%57": "W",
		"%58": "X",
		"%59": "Y",
		"%5a": "Z",
		"%5A": "Z",
		"%5b": "[",
		"%5B": "[",
		"%5c": "\\",
		"%5C": "\\",
		"%5d": "]",
		"%5D": "]",
		"%5e": "^",
		"%5E": "^",
		"%5f": "_",
		"%5F": "_",
		"%60": "`",
		"%61": "a",
		"%62": "b",
		"%63": "c",
		"%64": "d",
		"%65": "e",
		"%66": "f",
		"%67": "g",
		"%68": "h",
		"%69": "i",
		"%6a": "j",
		"%6A": "j",
		"%6b": "k",
		"%6B": "k",
		"%6c": "l",
		"%6C": "l",
		"%6d": "m",
		"%6D": "m",
		"%6e": "n",
		"%6E": "n",
		"%6f": "o",
		"%6F": "o",
		"%70": "p",
		"%71": "q",
		"%72": "r",
		"%73": "s",
		"%74": "t",
		"%75": "u",
		"%76": "v",
		"%77": "w",
		"%78": "x",
		"%79": "y",
		"%7a": "z",
		"%7A": "z",
		"%7b": "{",
		"%7B": "{",
		"%7c": "|",
		"%7C": "|",
		"%7d": "}",
		"%7D": "}",
		"%7e": "~",
		"%7E": "~",
		"%7f": "",
		"%7F": "",
		"%80": "",
		"%81": "",
		"%82": "",
		"%83": "",
		"%84": "",
		"%85": "",
		"%86": "",
		"%87": "",
		"%88": "",
		"%89": "",
		"%8a": "",
		"%8A": "",
		"%8b": "",
		"%8B": "",
		"%8c": "",
		"%8C": "",
		"%8d": "",
		"%8D": "",
		"%8e": "",
		"%8E": "",
		"%8f": "",
		"%8F": "",
		"%90": "",
		"%91": "",
		"%92": "",
		"%93": "",
		"%94": "",
		"%95": "",
		"%96": "",
		"%97": "",
		"%98": "",
		"%99": "",
		"%9a": "",
		"%9A": "",
		"%9b": "",
		"%9B": "",
		"%9c": "",
		"%9C": "",
		"%9d": "",
		"%9D": "",
		"%9e": "",
		"%9E": "",
		"%9f": "",
		"%9F": "",
		"%a0": "\xA0",
		"%A0": "\xA0",
		"%a1": "",
		"%A1": "",
		"%a2": "",
		"%A2": "",
		"%a3": "",
		"%A3": "",
		"%a4": "",
		"%A4": "",
		"%a5": "",
		"%A5": "",
		"%a6": "",
		"%A6": "",
		"%a7": "",
		"%A7": "",
		"%a8": "",
		"%A8": "",
		"%a9": "",
		"%A9": "",
		"%aa": "",
		"%Aa": "",
		"%aA": "",
		"%AA": "",
		"%ab": "",
		"%Ab": "",
		"%aB": "",
		"%AB": "",
		"%ac": "",
		"%Ac": "",
		"%aC": "",
		"%AC": "",
		"%ad": "",
		"%Ad": "",
		"%aD": "",
		"%AD": "",
		"%ae": "",
		"%Ae": "",
		"%aE": "",
		"%AE": "",
		"%af": "",
		"%Af": "",
		"%aF": "",
		"%AF": "",
		"%b0": "",
		"%B0": "",
		"%b1": "",
		"%B1": "",
		"%b2": "",
		"%B2": "",
		"%b3": "",
		"%B3": "",
		"%b4": "",
		"%B4": "",
		"%b5": "",
		"%B5": "",
		"%b6": "",
		"%B6": "",
		"%b7": "",
		"%B7": "",
		"%b8": "",
		"%B8": "",
		"%b9": "",
		"%B9": "",
		"%ba": "",
		"%Ba": "",
		"%bA": "",
		"%BA": "",
		"%bb": "",
		"%Bb": "",
		"%bB": "",
		"%BB": "",
		"%bc": "",
		"%Bc": "",
		"%bC": "",
		"%BC": "",
		"%bd": "",
		"%Bd": "",
		"%bD": "",
		"%BD": "",
		"%be": "",
		"%Be": "",
		"%bE": "",
		"%BE": "",
		"%bf": "",
		"%Bf": "",
		"%bF": "",
		"%BF": "",
		"%c0": "",
		"%C0": "",
		"%c1": "",
		"%C1": "",
		"%c2": "",
		"%C2": "",
		"%c3": "",
		"%C3": "",
		"%c4": "",
		"%C4": "",
		"%c5": "",
		"%C5": "",
		"%c6": "",
		"%C6": "",
		"%c7": "",
		"%C7": "",
		"%c8": "",
		"%C8": "",
		"%c9": "",
		"%C9": "",
		"%ca": "",
		"%Ca": "",
		"%cA": "",
		"%CA": "",
		"%cb": "",
		"%Cb": "",
		"%cB": "",
		"%CB": "",
		"%cc": "",
		"%Cc": "",
		"%cC": "",
		"%CC": "",
		"%cd": "",
		"%Cd": "",
		"%cD": "",
		"%CD": "",
		"%ce": "",
		"%Ce": "",
		"%cE": "",
		"%CE": "",
		"%cf": "",
		"%Cf": "",
		"%cF": "",
		"%CF": "",
		"%d0": "",
		"%D0": "",
		"%d1": "",
		"%D1": "",
		"%d2": "",
		"%D2": "",
		"%d3": "",
		"%D3": "",
		"%d4": "",
		"%D4": "",
		"%d5": "",
		"%D5": "",
		"%d6": "",
		"%D6": "",
		"%d7": "",
		"%D7": "",
		"%d8": "",
		"%D8": "",
		"%d9": "",
		"%D9": "",
		"%da": "",
		"%Da": "",
		"%dA": "",
		"%DA": "",
		"%db": "",
		"%Db": "",
		"%dB": "",
		"%DB": "",
		"%dc": "",
		"%Dc": "",
		"%dC": "",
		"%DC": "",
		"%dd": "",
		"%Dd": "",
		"%dD": "",
		"%DD": "",
		"%de": "",
		"%De": "",
		"%dE": "",
		"%DE": "",
		"%df": "",
		"%Df": "",
		"%dF": "",
		"%DF": "",
		"%e0": "",
		"%E0": "",
		"%e1": "",
		"%E1": "",
		"%e2": "",
		"%E2": "",
		"%e3": "",
		"%E3": "",
		"%e4": "",
		"%E4": "",
		"%e5": "",
		"%E5": "",
		"%e6": "",
		"%E6": "",
		"%e7": "",
		"%E7": "",
		"%e8": "",
		"%E8": "",
		"%e9": "",
		"%E9": "",
		"%ea": "",
		"%Ea": "",
		"%eA": "",
		"%EA": "",
		"%eb": "",
		"%Eb": "",
		"%eB": "",
		"%EB": "",
		"%ec": "",
		"%Ec": "",
		"%eC": "",
		"%EC": "",
		"%ed": "",
		"%Ed": "",
		"%eD": "",
		"%ED": "",
		"%ee": "",
		"%Ee": "",
		"%eE": "",
		"%EE": "",
		"%ef": "",
		"%Ef": "",
		"%eF": "",
		"%EF": "",
		"%f0": "",
		"%F0": "",
		"%f1": "",
		"%F1": "",
		"%f2": "",
		"%F2": "",
		"%f3": "",
		"%F3": "",
		"%f4": "",
		"%F4": "",
		"%f5": "",
		"%F5": "",
		"%f6": "",
		"%F6": "",
		"%f7": "",
		"%F7": "",
		"%f8": "",
		"%F8": "",
		"%f9": "",
		"%F9": "",
		"%fa": "",
		"%Fa": "",
		"%fA": "",
		"%FA": "",
		"%fb": "",
		"%Fb": "",
		"%fB": "",
		"%FB": "",
		"%fc": "",
		"%Fc": "",
		"%fC": "",
		"%FC": "",
		"%fd": "",
		"%Fd": "",
		"%fD": "",
		"%FD": "",
		"%fe": "",
		"%Fe": "",
		"%fE": "",
		"%FE": "",
		"%ff": "",
		"%Ff": "",
		"%fF": "",
		"%FF": ""
	};
	function encodedReplacer(match) {
		return EncodedLookup[match];
	}
	const STATE_KEY = 0;
	const STATE_VALUE = 1;
	const STATE_CHARSET = 2;
	const STATE_LANG = 3;
	function parseParams$2(str) {
		const res = [];
		let state$1 = STATE_KEY;
		let charset = "";
		let inquote = false;
		let escaping = false;
		let p$5 = 0;
		let tmp = "";
		const len = str.length;
		for (var i$5 = 0; i$5 < len; ++i$5) {
			const char = str[i$5];
			if (char === "\\" && inquote) if (escaping) escaping = false;
			else {
				escaping = true;
				continue;
			}
			else if (char === "\"") if (!escaping) {
				if (inquote) {
					inquote = false;
					state$1 = STATE_KEY;
				} else inquote = true;
				continue;
			} else escaping = false;
			else {
				if (escaping && inquote) tmp += "\\";
				escaping = false;
				if ((state$1 === STATE_CHARSET || state$1 === STATE_LANG) && char === "'") {
					if (state$1 === STATE_CHARSET) {
						state$1 = STATE_LANG;
						charset = tmp.substring(1);
					} else state$1 = STATE_VALUE;
					tmp = "";
					continue;
				} else if (state$1 === STATE_KEY && (char === "*" || char === "=") && res.length) {
					state$1 = char === "*" ? STATE_CHARSET : STATE_VALUE;
					res[p$5] = [tmp, void 0];
					tmp = "";
					continue;
				} else if (!inquote && char === ";") {
					state$1 = STATE_KEY;
					if (charset) {
						if (tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
						charset = "";
					} else if (tmp.length) tmp = decodeText$2(tmp, "binary", "utf8");
					if (res[p$5] === void 0) res[p$5] = tmp;
					else res[p$5][1] = tmp;
					tmp = "";
					++p$5;
					continue;
				} else if (!inquote && (char === " " || char === "	")) continue;
			}
			tmp += char;
		}
		if (charset && tmp.length) tmp = decodeText$2(tmp.replace(RE_ENCODED, encodedReplacer), "binary", charset);
		else if (tmp) tmp = decodeText$2(tmp, "binary", "utf8");
		if (res[p$5] === void 0) {
			if (tmp) res[p$5] = tmp;
		} else res[p$5][1] = tmp;
		return res;
	}
	module.exports = parseParams$2;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = function basename$1(path$6) {
		if (typeof path$6 !== "string") return "";
		for (var i$5 = path$6.length - 1; i$5 >= 0; --i$5) switch (path$6.charCodeAt(i$5)) {
			case 47:
			case 92:
				path$6 = path$6.slice(i$5 + 1);
				return path$6 === ".." || path$6 === "." ? "" : path$6;
		}
		return path$6 === ".." || path$6 === "." ? "" : path$6;
	};
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Readable: Readable$4 } = __require("node:stream");
	const { inherits: inherits$1 } = __require("node:util");
	const Dicer$1 = require_Dicer();
	const parseParams$1 = require_parseParams();
	const decodeText$1 = require_decodeText();
	const basename = require_basename();
	const getLimit$1 = require_getLimit();
	const RE_BOUNDARY = /^boundary$/i;
	const RE_FIELD = /^form-data$/i;
	const RE_CHARSET$1 = /^charset$/i;
	const RE_FILENAME = /^filename$/i;
	const RE_NAME = /^name$/i;
	Multipart.detect = /^multipart\/form-data/i;
	function Multipart(boy, cfg) {
		let i$5;
		let len;
		const self = this;
		let boundary;
		const limits = cfg.limits;
		const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
		const parsedConType = cfg.parsedConType || [];
		const defCharset = cfg.defCharset || "utf8";
		const preservePath = cfg.preservePath;
		const fileOpts = { highWaterMark: cfg.fileHwm };
		for (i$5 = 0, len = parsedConType.length; i$5 < len; ++i$5) if (Array.isArray(parsedConType[i$5]) && RE_BOUNDARY.test(parsedConType[i$5][0])) {
			boundary = parsedConType[i$5][1];
			break;
		}
		function checkFinished() {
			if (nends === 0 && finished$1 && !boy._done) {
				finished$1 = false;
				self.end();
			}
		}
		if (typeof boundary !== "string") throw new Error("Multipart: Boundary not found");
		const fieldSizeLimit = getLimit$1(limits, "fieldSize", 1 * 1024 * 1024);
		const fileSizeLimit = getLimit$1(limits, "fileSize", Infinity);
		const filesLimit = getLimit$1(limits, "files", Infinity);
		const fieldsLimit = getLimit$1(limits, "fields", Infinity);
		const partsLimit = getLimit$1(limits, "parts", Infinity);
		const headerPairsLimit = getLimit$1(limits, "headerPairs", 2e3);
		const headerSizeLimit = getLimit$1(limits, "headerSize", 80 * 1024);
		let nfiles = 0;
		let nfields = 0;
		let nends = 0;
		let curFile;
		let curField;
		let finished$1 = false;
		this._needDrain = false;
		this._pause = false;
		this._cb = void 0;
		this._nparts = 0;
		this._boy = boy;
		this.parser = new Dicer$1({
			boundary,
			maxHeaderPairs: headerPairsLimit,
			maxHeaderSize: headerSizeLimit,
			partHwm: fileOpts.highWaterMark,
			highWaterMark: cfg.highWaterMark
		});
		this.parser.on("drain", function() {
			self._needDrain = false;
			if (self._cb && !self._pause) {
				const cb = self._cb;
				self._cb = void 0;
				cb();
			}
		}).on("part", function onPart(part) {
			if (++self._nparts > partsLimit) {
				self.parser.removeListener("part", onPart);
				self.parser.on("part", skipPart);
				boy.hitPartsLimit = true;
				boy.emit("partsLimit");
				return skipPart(part);
			}
			if (curField) {
				const field = curField;
				field.emit("end");
				field.removeAllListeners("end");
			}
			part.on("header", function(header) {
				let contype;
				let fieldname;
				let parsed;
				let charset;
				let encoding;
				let filename;
				let nsize = 0;
				if (header["content-type"]) {
					parsed = parseParams$1(header["content-type"][0]);
					if (parsed[0]) {
						contype = parsed[0].toLowerCase();
						for (i$5 = 0, len = parsed.length; i$5 < len; ++i$5) if (RE_CHARSET$1.test(parsed[i$5][0])) {
							charset = parsed[i$5][1].toLowerCase();
							break;
						}
					}
				}
				if (contype === void 0) contype = "text/plain";
				if (charset === void 0) charset = defCharset;
				if (header["content-disposition"]) {
					parsed = parseParams$1(header["content-disposition"][0]);
					if (!RE_FIELD.test(parsed[0])) return skipPart(part);
					for (i$5 = 0, len = parsed.length; i$5 < len; ++i$5) if (RE_NAME.test(parsed[i$5][0])) fieldname = parsed[i$5][1];
					else if (RE_FILENAME.test(parsed[i$5][0])) {
						filename = parsed[i$5][1];
						if (!preservePath) filename = basename(filename);
					}
				} else return skipPart(part);
				if (header["content-transfer-encoding"]) encoding = header["content-transfer-encoding"][0].toLowerCase();
				else encoding = "7bit";
				let onData, onEnd;
				if (isPartAFile(fieldname, contype, filename)) {
					if (nfiles === filesLimit) {
						if (!boy.hitFilesLimit) {
							boy.hitFilesLimit = true;
							boy.emit("filesLimit");
						}
						return skipPart(part);
					}
					++nfiles;
					if (boy.listenerCount("file") === 0) {
						self.parser._ignore();
						return;
					}
					++nends;
					const file = new FileStream(fileOpts);
					curFile = file;
					file.on("end", function() {
						--nends;
						self._pause = false;
						checkFinished();
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					});
					file._read = function(n$5) {
						if (!self._pause) return;
						self._pause = false;
						if (self._cb && !self._needDrain) {
							const cb = self._cb;
							self._cb = void 0;
							cb();
						}
					};
					boy.emit("file", fieldname, file, filename, encoding, contype);
					onData = function(data$1) {
						if ((nsize += data$1.length) > fileSizeLimit) {
							const extralen = fileSizeLimit - nsize + data$1.length;
							if (extralen > 0) file.push(data$1.slice(0, extralen));
							file.truncated = true;
							file.bytesRead = fileSizeLimit;
							part.removeAllListeners("data");
							file.emit("limit");
							return;
						} else if (!file.push(data$1)) self._pause = true;
						file.bytesRead = nsize;
					};
					onEnd = function() {
						curFile = void 0;
						file.push(null);
					};
				} else {
					if (nfields === fieldsLimit) {
						if (!boy.hitFieldsLimit) {
							boy.hitFieldsLimit = true;
							boy.emit("fieldsLimit");
						}
						return skipPart(part);
					}
					++nfields;
					++nends;
					let buffer$3 = "";
					let truncated = false;
					curField = part;
					onData = function(data$1) {
						if ((nsize += data$1.length) > fieldSizeLimit) {
							const extralen = fieldSizeLimit - (nsize - data$1.length);
							buffer$3 += data$1.toString("binary", 0, extralen);
							truncated = true;
							part.removeAllListeners("data");
						} else buffer$3 += data$1.toString("binary");
					};
					onEnd = function() {
						curField = void 0;
						if (buffer$3.length) buffer$3 = decodeText$1(buffer$3, "binary", charset);
						boy.emit("field", fieldname, buffer$3, false, truncated, encoding, contype);
						--nends;
						checkFinished();
					};
				}
				part._readableState.sync = false;
				part.on("data", onData);
				part.on("end", onEnd);
			}).on("error", function(err) {
				if (curFile) curFile.emit("error", err);
			});
		}).on("error", function(err) {
			boy.emit("error", err);
		}).on("finish", function() {
			finished$1 = true;
			checkFinished();
		});
	}
	Multipart.prototype.write = function(chunk, cb) {
		const r$5 = this.parser.write(chunk);
		if (r$5 && !this._pause) cb();
		else {
			this._needDrain = !r$5;
			this._cb = cb;
		}
	};
	Multipart.prototype.end = function() {
		const self = this;
		if (self.parser.writable) self.parser.end();
		else if (!self._boy._done) process.nextTick(function() {
			self._boy._done = true;
			self._boy.emit("finish");
		});
	};
	function skipPart(part) {
		part.resume();
	}
	function FileStream(opts) {
		Readable$4.call(this, opts);
		this.bytesRead = 0;
		this.truncated = false;
	}
	inherits$1(FileStream, Readable$4);
	FileStream.prototype._read = function(n$5) {};
	module.exports = Multipart;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const RE_PLUS = /\+/g;
	const HEX = [
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		1,
		1,
		1,
		1,
		1,
		1,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0,
		0
	];
	function Decoder$1() {
		this.buffer = void 0;
	}
	Decoder$1.prototype.write = function(str) {
		str = str.replace(RE_PLUS, " ");
		let res = "";
		let i$5 = 0;
		let p$5 = 0;
		const len = str.length;
		for (; i$5 < len; ++i$5) if (this.buffer !== void 0) if (!HEX[str.charCodeAt(i$5)]) {
			res += "%" + this.buffer;
			this.buffer = void 0;
			--i$5;
		} else {
			this.buffer += str[i$5];
			++p$5;
			if (this.buffer.length === 2) {
				res += String.fromCharCode(parseInt(this.buffer, 16));
				this.buffer = void 0;
			}
		}
		else if (str[i$5] === "%") {
			if (i$5 > p$5) {
				res += str.substring(p$5, i$5);
				p$5 = i$5;
			}
			this.buffer = "";
			++p$5;
		}
		if (p$5 < len && this.buffer === void 0) res += str.substring(p$5);
		return res;
	};
	Decoder$1.prototype.reset = function() {
		this.buffer = void 0;
	};
	module.exports = Decoder$1;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Decoder = require_Decoder();
	const decodeText = require_decodeText();
	const getLimit = require_getLimit();
	const RE_CHARSET = /^charset$/i;
	UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
	function UrlEncoded(boy, cfg) {
		const limits = cfg.limits;
		const parsedConType = cfg.parsedConType;
		this.boy = boy;
		this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
		this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
		this.fieldsLimit = getLimit(limits, "fields", Infinity);
		let charset;
		for (var i$5 = 0, len = parsedConType.length; i$5 < len; ++i$5) if (Array.isArray(parsedConType[i$5]) && RE_CHARSET.test(parsedConType[i$5][0])) {
			charset = parsedConType[i$5][1].toLowerCase();
			break;
		}
		if (charset === void 0) charset = cfg.defCharset || "utf8";
		this.decoder = new Decoder();
		this.charset = charset;
		this._fields = 0;
		this._state = "key";
		this._checkingBytes = true;
		this._bytesKey = 0;
		this._bytesVal = 0;
		this._key = "";
		this._val = "";
		this._keyTrunc = false;
		this._valTrunc = false;
		this._hitLimit = false;
	}
	UrlEncoded.prototype.write = function(data$1, cb) {
		if (this._fields === this.fieldsLimit) {
			if (!this.boy.hitFieldsLimit) {
				this.boy.hitFieldsLimit = true;
				this.boy.emit("fieldsLimit");
			}
			return cb();
		}
		let idxeq;
		let idxamp;
		let i$5;
		let p$5 = 0;
		const len = data$1.length;
		while (p$5 < len) if (this._state === "key") {
			idxeq = idxamp = void 0;
			for (i$5 = p$5; i$5 < len; ++i$5) {
				if (!this._checkingBytes) ++p$5;
				if (data$1[i$5] === 61) {
					idxeq = i$5;
					break;
				} else if (data$1[i$5] === 38) {
					idxamp = i$5;
					break;
				}
				if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesKey;
			}
			if (idxeq !== void 0) {
				if (idxeq > p$5) this._key += this.decoder.write(data$1.toString("binary", p$5, idxeq));
				this._state = "val";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._val = "";
				this._bytesVal = 0;
				this._valTrunc = false;
				this.decoder.reset();
				p$5 = idxeq + 1;
			} else if (idxamp !== void 0) {
				++this._fields;
				let key;
				const keyTrunc = this._keyTrunc;
				if (idxamp > p$5) key = this._key += this.decoder.write(data$1.toString("binary", p$5, idxamp));
				else key = this._key;
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				if (key.length) this.boy.emit("field", decodeText(key, "binary", this.charset), "", keyTrunc, false);
				p$5 = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$5 > p$5) this._key += this.decoder.write(data$1.toString("binary", p$5, i$5));
				p$5 = i$5;
				if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
					this._checkingBytes = false;
					this._keyTrunc = true;
				}
			} else {
				if (p$5 < len) this._key += this.decoder.write(data$1.toString("binary", p$5));
				p$5 = len;
			}
		} else {
			idxamp = void 0;
			for (i$5 = p$5; i$5 < len; ++i$5) {
				if (!this._checkingBytes) ++p$5;
				if (data$1[i$5] === 38) {
					idxamp = i$5;
					break;
				}
				if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
					this._hitLimit = true;
					break;
				} else if (this._checkingBytes) ++this._bytesVal;
			}
			if (idxamp !== void 0) {
				++this._fields;
				if (idxamp > p$5) this._val += this.decoder.write(data$1.toString("binary", p$5, idxamp));
				this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
				this._state = "key";
				this._hitLimit = false;
				this._checkingBytes = true;
				this._key = "";
				this._bytesKey = 0;
				this._keyTrunc = false;
				this.decoder.reset();
				p$5 = idxamp + 1;
				if (this._fields === this.fieldsLimit) return cb();
			} else if (this._hitLimit) {
				if (i$5 > p$5) this._val += this.decoder.write(data$1.toString("binary", p$5, i$5));
				p$5 = i$5;
				if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
					this._checkingBytes = false;
					this._valTrunc = true;
				}
			} else {
				if (p$5 < len) this._val += this.decoder.write(data$1.toString("binary", p$5));
				p$5 = len;
			}
		}
		cb();
	};
	UrlEncoded.prototype.end = function() {
		if (this.boy._done) return;
		if (this._state === "key" && this._key.length > 0) this.boy.emit("field", decodeText(this._key, "binary", this.charset), "", this._keyTrunc, false);
		else if (this._state === "val") this.boy.emit("field", decodeText(this._key, "binary", this.charset), decodeText(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
		this.boy._done = true;
		this.boy.emit("finish");
	};
	module.exports = UrlEncoded;
}));

//#endregion
//#region node_modules/@fastify/busboy/lib/main.js
var require_main = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const WritableStream = __require("node:stream").Writable;
	const { inherits } = __require("node:util");
	const Dicer = require_Dicer();
	const MultipartParser = require_multipart();
	const UrlencodedParser = require_urlencoded();
	const parseParams = require_parseParams();
	function Busboy$1(opts) {
		if (!(this instanceof Busboy$1)) return new Busboy$1(opts);
		if (typeof opts !== "object") throw new TypeError("Busboy expected an options-Object.");
		if (typeof opts.headers !== "object") throw new TypeError("Busboy expected an options-Object with headers-attribute.");
		if (typeof opts.headers["content-type"] !== "string") throw new TypeError("Missing Content-Type-header.");
		const { headers, ...streamOptions } = opts;
		this.opts = {
			autoDestroy: false,
			...streamOptions
		};
		WritableStream.call(this, this.opts);
		this._done = false;
		this._parser = this.getParserByHeaders(headers);
		this._finished = false;
	}
	inherits(Busboy$1, WritableStream);
	Busboy$1.prototype.emit = function(ev) {
		if (ev === "finish") {
			if (!this._done) {
				this._parser?.end();
				return;
			} else if (this._finished) return;
			this._finished = true;
		}
		WritableStream.prototype.emit.apply(this, arguments);
	};
	Busboy$1.prototype.getParserByHeaders = function(headers) {
		const parsed = parseParams(headers["content-type"]);
		const cfg = {
			defCharset: this.opts.defCharset,
			fileHwm: this.opts.fileHwm,
			headers,
			highWaterMark: this.opts.highWaterMark,
			isPartAFile: this.opts.isPartAFile,
			limits: this.opts.limits,
			parsedConType: parsed,
			preservePath: this.opts.preservePath
		};
		if (MultipartParser.detect.test(parsed[0])) return new MultipartParser(this, cfg);
		if (UrlencodedParser.detect.test(parsed[0])) return new UrlencodedParser(this, cfg);
		throw new Error("Unsupported Content-Type.");
	};
	Busboy$1.prototype._write = function(chunk, encoding, cb) {
		this._parser.write(chunk, cb);
	};
	module.exports = Busboy$1;
	module.exports.default = Busboy$1;
	module.exports.Busboy = Busboy$1;
	module.exports.Dicer = Dicer;
}));

//#endregion
//#region node_modules/undici/lib/fetch/constants.js
var require_constants$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
	const corsSafeListedMethods = [
		"GET",
		"HEAD",
		"POST"
	];
	const corsSafeListedMethodsSet$1 = new Set(corsSafeListedMethods);
	const nullBodyStatus$2 = [
		101,
		204,
		205,
		304
	];
	const redirectStatus = [
		301,
		302,
		303,
		307,
		308
	];
	const redirectStatusSet$3 = new Set(redirectStatus);
	const badPorts = [
		"1",
		"7",
		"9",
		"11",
		"13",
		"15",
		"17",
		"19",
		"20",
		"21",
		"22",
		"23",
		"25",
		"37",
		"42",
		"43",
		"53",
		"69",
		"77",
		"79",
		"87",
		"95",
		"101",
		"102",
		"103",
		"104",
		"109",
		"110",
		"111",
		"113",
		"115",
		"117",
		"119",
		"123",
		"135",
		"137",
		"139",
		"143",
		"161",
		"179",
		"389",
		"427",
		"465",
		"512",
		"513",
		"514",
		"515",
		"526",
		"530",
		"531",
		"532",
		"540",
		"548",
		"554",
		"556",
		"563",
		"587",
		"601",
		"636",
		"989",
		"990",
		"993",
		"995",
		"1719",
		"1720",
		"1723",
		"2049",
		"3659",
		"4045",
		"5060",
		"5061",
		"6000",
		"6566",
		"6665",
		"6666",
		"6667",
		"6668",
		"6669",
		"6697",
		"10080"
	];
	const badPortsSet$1 = new Set(badPorts);
	const referrerPolicy$1 = [
		"",
		"no-referrer",
		"no-referrer-when-downgrade",
		"same-origin",
		"origin",
		"strict-origin",
		"origin-when-cross-origin",
		"strict-origin-when-cross-origin",
		"unsafe-url"
	];
	const referrerPolicySet = new Set(referrerPolicy$1);
	const requestRedirect$1 = [
		"follow",
		"manual",
		"error"
	];
	const safeMethods = [
		"GET",
		"HEAD",
		"OPTIONS",
		"TRACE"
	];
	const safeMethodsSet$1 = new Set(safeMethods);
	const requestMode$1 = [
		"navigate",
		"same-origin",
		"no-cors",
		"cors"
	];
	const requestCredentials$1 = [
		"omit",
		"same-origin",
		"include"
	];
	const requestCache$1 = [
		"default",
		"no-store",
		"reload",
		"no-cache",
		"force-cache",
		"only-if-cached"
	];
	const requestBodyHeader$1 = [
		"content-encoding",
		"content-language",
		"content-location",
		"content-type",
		"content-length"
	];
	const requestDuplex$1 = ["half"];
	const forbiddenMethods = [
		"CONNECT",
		"TRACE",
		"TRACK"
	];
	const forbiddenMethodsSet$1 = new Set(forbiddenMethods);
	const subresource = [
		"audio",
		"audioworklet",
		"font",
		"image",
		"manifest",
		"paintworklet",
		"script",
		"style",
		"track",
		"video",
		"xslt",
		""
	];
	const subresourceSet$1 = new Set(subresource);
	/** @type {globalThis['DOMException']} */
	const DOMException$6 = globalThis.DOMException ?? (() => {
		try {
			atob("~");
		} catch (err) {
			return Object.getPrototypeOf(err).constructor;
		}
	})();
	let channel;
	/** @type {globalThis['structuredClone']} */
	const structuredClone$2 = globalThis.structuredClone ?? function structuredClone$3(value, options = void 0) {
		if (arguments.length === 0) throw new TypeError("missing argument");
		if (!channel) channel = new MessageChannel();
		channel.port1.unref();
		channel.port2.unref();
		channel.port1.postMessage(value, options?.transfer);
		return receiveMessageOnPort(channel.port2).message;
	};
	module.exports = {
		DOMException: DOMException$6,
		structuredClone: structuredClone$2,
		subresource,
		forbiddenMethods,
		requestBodyHeader: requestBodyHeader$1,
		referrerPolicy: referrerPolicy$1,
		requestRedirect: requestRedirect$1,
		requestMode: requestMode$1,
		requestCredentials: requestCredentials$1,
		requestCache: requestCache$1,
		redirectStatus,
		corsSafeListedMethods,
		nullBodyStatus: nullBodyStatus$2,
		safeMethods,
		badPorts,
		requestDuplex: requestDuplex$1,
		subresourceSet: subresourceSet$1,
		badPortsSet: badPortsSet$1,
		redirectStatusSet: redirectStatusSet$3,
		corsSafeListedMethodsSet: corsSafeListedMethodsSet$1,
		safeMethodsSet: safeMethodsSet$1,
		forbiddenMethodsSet: forbiddenMethodsSet$1,
		referrerPolicySet
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/global.js
var require_global$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const globalOrigin = Symbol.for("undici.globalOrigin.1");
	function getGlobalOrigin$4() {
		return globalThis[globalOrigin];
	}
	function setGlobalOrigin(newOrigin) {
		if (newOrigin === void 0) {
			Object.defineProperty(globalThis, globalOrigin, {
				value: void 0,
				writable: true,
				enumerable: false,
				configurable: false
			});
			return;
		}
		const parsedURL = new URL(newOrigin);
		if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
		Object.defineProperty(globalThis, globalOrigin, {
			value: parsedURL,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	module.exports = {
		getGlobalOrigin: getGlobalOrigin$4,
		setGlobalOrigin
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/util.js
var require_util$5 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { redirectStatusSet: redirectStatusSet$2, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants$3();
	const { getGlobalOrigin: getGlobalOrigin$3 } = require_global$1();
	const { performance: performance$1 } = __require("perf_hooks");
	const { isBlobLike: isBlobLike$6, toUSVString: toUSVString$4, ReadableStreamFrom: ReadableStreamFrom$2 } = require_util$6();
	const assert$18 = __require("assert");
	const { isUint8Array: isUint8Array$1 } = __require("util/types");
	let supportedHashes = [];
	/** @type {import('crypto')|undefined} */
	let crypto$4;
	try {
		crypto$4 = __require("crypto");
		const possibleRelevantHashes = [
			"sha256",
			"sha384",
			"sha512"
		];
		supportedHashes = crypto$4.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
	} catch {}
	function responseURL(response) {
		const urlList = response.urlList;
		const length = urlList.length;
		return length === 0 ? null : urlList[length - 1].toString();
	}
	function responseLocationURL$1(response, requestFragment) {
		if (!redirectStatusSet$2.has(response.status)) return null;
		let location = response.headersList.get("location");
		if (location !== null && isValidHeaderValue$1(location)) location = new URL(location, responseURL(response));
		if (location && !location.hash) location.hash = requestFragment;
		return location;
	}
	/** @returns {URL} */
	function requestCurrentURL$1(request$1) {
		return request$1.urlList[request$1.urlList.length - 1];
	}
	function requestBadPort$1(request$1) {
		const url$1 = requestCurrentURL$1(request$1);
		if (urlIsHttpHttpsScheme$2(url$1) && badPortsSet.has(url$1.port)) return "blocked";
		return "allowed";
	}
	function isErrorLike$2(object) {
		return object instanceof Error || object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException";
	}
	function isValidReasonPhrase$1(statusText) {
		for (let i$5 = 0; i$5 < statusText.length; ++i$5) {
			const c$5 = statusText.charCodeAt(i$5);
			if (!(c$5 === 9 || c$5 >= 32 && c$5 <= 126 || c$5 >= 128 && c$5 <= 255)) return false;
		}
		return true;
	}
	/**
	* @see https://tools.ietf.org/html/rfc7230#section-3.2.6
	* @param {number} c
	*/
	function isTokenCharCode(c$5) {
		switch (c$5) {
			case 34:
			case 40:
			case 41:
			case 44:
			case 47:
			case 58:
			case 59:
			case 60:
			case 61:
			case 62:
			case 63:
			case 64:
			case 91:
			case 92:
			case 93:
			case 123:
			case 125: return false;
			default: return c$5 >= 33 && c$5 <= 126;
		}
	}
	/**
	* @param {string} characters
	*/
	function isValidHTTPToken$1(characters) {
		if (characters.length === 0) return false;
		for (let i$5 = 0; i$5 < characters.length; ++i$5) if (!isTokenCharCode(characters.charCodeAt(i$5))) return false;
		return true;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-name
	* @param {string} potentialValue
	*/
	function isValidHeaderName$2(potentialValue) {
		return isValidHTTPToken$1(potentialValue);
	}
	/**
	* @see https://fetch.spec.whatwg.org/#header-value
	* @param {string} potentialValue
	*/
	function isValidHeaderValue$1(potentialValue) {
		if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) return false;
		if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) return false;
		return true;
	}
	function setRequestReferrerPolicyOnRedirect$1(request$1, actualResponse) {
		const { headersList } = actualResponse;
		const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
		let policy = "";
		if (policyHeader.length > 0) for (let i$5 = policyHeader.length; i$5 !== 0; i$5--) {
			const token = policyHeader[i$5 - 1].trim();
			if (referrerPolicyTokens.has(token)) {
				policy = token;
				break;
			}
		}
		if (policy !== "") request$1.referrerPolicy = policy;
	}
	function crossOriginResourcePolicyCheck$1() {
		return "allowed";
	}
	function corsCheck$1() {
		return "success";
	}
	function TAOCheck$1() {
		return "success";
	}
	function appendFetchMetadata$1(httpRequest$1) {
		let header = null;
		header = httpRequest$1.mode;
		httpRequest$1.headersList.set("sec-fetch-mode", header);
	}
	function appendRequestOriginHeader$1(request$1) {
		let serializedOrigin = request$1.origin;
		if (request$1.responseTainting === "cors" || request$1.mode === "websocket") {
			if (serializedOrigin) request$1.headersList.append("origin", serializedOrigin);
		} else if (request$1.method !== "GET" && request$1.method !== "HEAD") {
			switch (request$1.referrerPolicy) {
				case "no-referrer":
					serializedOrigin = null;
					break;
				case "no-referrer-when-downgrade":
				case "strict-origin":
				case "strict-origin-when-cross-origin":
					if (request$1.origin && urlHasHttpsScheme$1(request$1.origin) && !urlHasHttpsScheme$1(requestCurrentURL$1(request$1))) serializedOrigin = null;
					break;
				case "same-origin":
					if (!sameOrigin$2(request$1, requestCurrentURL$1(request$1))) serializedOrigin = null;
					break;
				default:
			}
			if (serializedOrigin) request$1.headersList.append("origin", serializedOrigin);
		}
	}
	function coarsenedSharedCurrentTime$1(crossOriginIsolatedCapability) {
		return performance$1.now();
	}
	function createOpaqueTimingInfo$1(timingInfo) {
		return {
			startTime: timingInfo.startTime ?? 0,
			redirectStartTime: 0,
			redirectEndTime: 0,
			postRedirectStartTime: timingInfo.startTime ?? 0,
			finalServiceWorkerStartTime: 0,
			finalNetworkResponseStartTime: 0,
			finalNetworkRequestStartTime: 0,
			endTime: 0,
			encodedBodySize: 0,
			decodedBodySize: 0,
			finalConnectionTimingInfo: null
		};
	}
	function makePolicyContainer$2() {
		return { referrerPolicy: "strict-origin-when-cross-origin" };
	}
	function clonePolicyContainer$1(policyContainer) {
		return { referrerPolicy: policyContainer.referrerPolicy };
	}
	function determineRequestsReferrer$1(request$1) {
		const policy = request$1.referrerPolicy;
		assert$18(policy);
		let referrerSource = null;
		if (request$1.referrer === "client") {
			const globalOrigin$1 = getGlobalOrigin$3();
			if (!globalOrigin$1 || globalOrigin$1.origin === "null") return "no-referrer";
			referrerSource = new URL(globalOrigin$1);
		} else if (request$1.referrer instanceof URL) referrerSource = request$1.referrer;
		let referrerURL = stripURLForReferrer(referrerSource);
		const referrerOrigin = stripURLForReferrer(referrerSource, true);
		if (referrerURL.toString().length > 4096) referrerURL = referrerOrigin;
		const areSameOrigin = sameOrigin$2(request$1, referrerURL);
		const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request$1.url);
		switch (policy) {
			case "origin": return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
			case "unsafe-url": return referrerURL;
			case "same-origin": return areSameOrigin ? referrerOrigin : "no-referrer";
			case "origin-when-cross-origin": return areSameOrigin ? referrerURL : referrerOrigin;
			case "strict-origin-when-cross-origin": {
				const currentURL = requestCurrentURL$1(request$1);
				if (sameOrigin$2(referrerURL, currentURL)) return referrerURL;
				if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) return "no-referrer";
				return referrerOrigin;
			}
			case "strict-origin":
			case "no-referrer-when-downgrade":
			default: return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-referrer-policy/#strip-url
	* @param {URL} url
	* @param {boolean|undefined} originOnly
	*/
	function stripURLForReferrer(url$1, originOnly) {
		assert$18(url$1 instanceof URL);
		if (url$1.protocol === "file:" || url$1.protocol === "about:" || url$1.protocol === "blank:") return "no-referrer";
		url$1.username = "";
		url$1.password = "";
		url$1.hash = "";
		if (originOnly) {
			url$1.pathname = "";
			url$1.search = "";
		}
		return url$1;
	}
	function isURLPotentiallyTrustworthy(url$1) {
		if (!(url$1 instanceof URL)) return false;
		if (url$1.href === "about:blank" || url$1.href === "about:srcdoc") return true;
		if (url$1.protocol === "data:") return true;
		if (url$1.protocol === "file:") return true;
		return isOriginPotentiallyTrustworthy(url$1.origin);
		function isOriginPotentiallyTrustworthy(origin) {
			if (origin == null || origin === "null") return false;
			const originAsURL = new URL(origin);
			if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") return true;
			if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.") || originAsURL.hostname.endsWith(".localhost")) return true;
			return false;
		}
	}
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist
	* @param {Uint8Array} bytes
	* @param {string} metadataList
	*/
	function bytesMatch$1(bytes, metadataList) {
		/* istanbul ignore if: only if node is built with --without-ssl */
		if (crypto$4 === void 0) return true;
		const parsedMetadata = parseMetadata(metadataList);
		if (parsedMetadata === "no metadata") return true;
		if (parsedMetadata.length === 0) return true;
		const metadata = filterMetadataListByAlgorithm(parsedMetadata, getStrongestMetadata(parsedMetadata));
		for (const item of metadata) {
			const algorithm = item.algo;
			const expectedValue = item.hash;
			let actualValue = crypto$4.createHash(algorithm).update(bytes).digest("base64");
			if (actualValue[actualValue.length - 1] === "=") if (actualValue[actualValue.length - 2] === "=") actualValue = actualValue.slice(0, -2);
			else actualValue = actualValue.slice(0, -1);
			if (compareBase64Mixed(actualValue, expectedValue)) return true;
		}
		return false;
	}
	const parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
	/**
	* @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata
	* @param {string} metadata
	*/
	function parseMetadata(metadata) {
		/** @type {{ algo: string, hash: string }[]} */
		const result = [];
		let empty = true;
		for (const token of metadata.split(" ")) {
			empty = false;
			const parsedToken = parseHashWithOptions.exec(token);
			if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) continue;
			const algorithm = parsedToken.groups.algo.toLowerCase();
			if (supportedHashes.includes(algorithm)) result.push(parsedToken.groups);
		}
		if (empty === true) return "no metadata";
		return result;
	}
	/**
	* @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList
	*/
	function getStrongestMetadata(metadataList) {
		let algorithm = metadataList[0].algo;
		if (algorithm[3] === "5") return algorithm;
		for (let i$5 = 1; i$5 < metadataList.length; ++i$5) {
			const metadata = metadataList[i$5];
			if (metadata.algo[3] === "5") {
				algorithm = "sha512";
				break;
			} else if (algorithm[3] === "3") continue;
			else if (metadata.algo[3] === "3") algorithm = "sha384";
		}
		return algorithm;
	}
	function filterMetadataListByAlgorithm(metadataList, algorithm) {
		if (metadataList.length === 1) return metadataList;
		let pos = 0;
		for (let i$5 = 0; i$5 < metadataList.length; ++i$5) if (metadataList[i$5].algo === algorithm) metadataList[pos++] = metadataList[i$5];
		metadataList.length = pos;
		return metadataList;
	}
	/**
	* Compares two base64 strings, allowing for base64url
	* in the second string.
	*
	* @param {string} actualValue always base64
	* @param {string} expectedValue base64 or base64url
	* @returns {boolean}
	*/
	function compareBase64Mixed(actualValue, expectedValue) {
		if (actualValue.length !== expectedValue.length) return false;
		for (let i$5 = 0; i$5 < actualValue.length; ++i$5) if (actualValue[i$5] !== expectedValue[i$5]) {
			if (actualValue[i$5] === "+" && expectedValue[i$5] === "-" || actualValue[i$5] === "/" && expectedValue[i$5] === "_") continue;
			return false;
		}
		return true;
	}
	function tryUpgradeRequestToAPotentiallyTrustworthyURL$1(request$1) {}
	/**
	* @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
	* @param {URL} A
	* @param {URL} B
	*/
	function sameOrigin$2(A$2, B$2) {
		if (A$2.origin === B$2.origin && A$2.origin === "null") return true;
		if (A$2.protocol === B$2.protocol && A$2.hostname === B$2.hostname && A$2.port === B$2.port) return true;
		return false;
	}
	function createDeferredPromise$3() {
		let res;
		let rej;
		return {
			promise: new Promise((resolve, reject) => {
				res = resolve;
				rej = reject;
			}),
			resolve: res,
			reject: rej
		};
	}
	function isAborted$2(fetchParams) {
		return fetchParams.controller.state === "aborted";
	}
	function isCancelled$2(fetchParams) {
		return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
	}
	const normalizeMethodRecord$1 = {
		delete: "DELETE",
		DELETE: "DELETE",
		get: "GET",
		GET: "GET",
		head: "HEAD",
		HEAD: "HEAD",
		options: "OPTIONS",
		OPTIONS: "OPTIONS",
		post: "POST",
		POST: "POST",
		put: "PUT",
		PUT: "PUT"
	};
	Object.setPrototypeOf(normalizeMethodRecord$1, null);
	/**
	* @see https://fetch.spec.whatwg.org/#concept-method-normalize
	* @param {string} method
	*/
	function normalizeMethod$1(method) {
		return normalizeMethodRecord$1[method.toLowerCase()] ?? method;
	}
	function serializeJavascriptValueToJSONString$1(value) {
		const result = JSON.stringify(value);
		if (result === void 0) throw new TypeError("Value is not JSON serializable");
		assert$18(typeof result === "string");
		return result;
	}
	const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
	/**
	* @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
	* @param {() => unknown[]} iterator
	* @param {string} name name of the instance
	* @param {'key'|'value'|'key+value'} kind
	*/
	function makeIterator$2(iterator, name, kind) {
		const object = {
			index: 0,
			kind,
			target: iterator
		};
		const i$5 = {
			next() {
				if (Object.getPrototypeOf(this) !== i$5) throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
				const { index, kind: kind$1, target } = object;
				const values = target();
				if (index >= values.length) return {
					value: void 0,
					done: true
				};
				const pair = values[index];
				object.index = index + 1;
				return iteratorResult(pair, kind$1);
			},
			[Symbol.toStringTag]: `${name} Iterator`
		};
		Object.setPrototypeOf(i$5, esIteratorPrototype);
		return Object.setPrototypeOf({}, i$5);
	}
	function iteratorResult(pair, kind) {
		let result;
		switch (kind) {
			case "key":
				result = pair[0];
				break;
			case "value":
				result = pair[1];
				break;
			case "key+value":
				result = pair;
				break;
		}
		return {
			value: result,
			done: false
		};
	}
	/**
	* @see https://fetch.spec.whatwg.org/#body-fully-read
	*/
	async function fullyReadBody$2(body, processBody, processBodyError) {
		const successSteps = processBody;
		const errorSteps = processBodyError;
		let reader;
		try {
			reader = body.stream.getReader();
		} catch (e$5) {
			errorSteps(e$5);
			return;
		}
		try {
			successSteps(await readAllBytes$1(reader));
		} catch (e$5) {
			errorSteps(e$5);
		}
	}
	/** @type {ReadableStream} */
	let ReadableStream$4 = globalThis.ReadableStream;
	function isReadableStreamLike$1(stream$3) {
		if (!ReadableStream$4) ReadableStream$4 = __require("stream/web").ReadableStream;
		return stream$3 instanceof ReadableStream$4 || stream$3[Symbol.toStringTag] === "ReadableStream" && typeof stream$3.tee === "function";
	}
	const MAXIMUM_ARGUMENT_LENGTH = 65535;
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-decode
	* @param {number[]|Uint8Array} input
	*/
	function isomorphicDecode$1(input) {
		if (input.length < MAXIMUM_ARGUMENT_LENGTH) return String.fromCharCode(...input);
		return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
	}
	/**
	* @param {ReadableStreamController<Uint8Array>} controller
	*/
	function readableStreamClose$2(controller) {
		try {
			controller.close();
		} catch (err) {
			if (!err.message.includes("Controller is already closed")) throw err;
		}
	}
	/**
	* @see https://infra.spec.whatwg.org/#isomorphic-encode
	* @param {string} input
	*/
	function isomorphicEncode$2(input) {
		for (let i$5 = 0; i$5 < input.length; i$5++) assert$18(input.charCodeAt(i$5) <= 255);
		return input;
	}
	/**
	* @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes
	* @see https://streams.spec.whatwg.org/#read-loop
	* @param {ReadableStreamDefaultReader} reader
	*/
	async function readAllBytes$1(reader) {
		const bytes = [];
		let byteLength = 0;
		while (true) {
			const { done, value: chunk } = await reader.read();
			if (done) return Buffer.concat(bytes, byteLength);
			if (!isUint8Array$1(chunk)) throw new TypeError("Received non-Uint8Array chunk");
			bytes.push(chunk);
			byteLength += chunk.length;
		}
	}
	/**
	* @see https://fetch.spec.whatwg.org/#is-local
	* @param {URL} url
	*/
	function urlIsLocal$1(url$1) {
		assert$18("protocol" in url$1);
		const protocol = url$1.protocol;
		return protocol === "about:" || protocol === "blob:" || protocol === "data:";
	}
	/**
	* @param {string|URL} url
	*/
	function urlHasHttpsScheme$1(url$1) {
		if (typeof url$1 === "string") return url$1.startsWith("https:");
		return url$1.protocol === "https:";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-scheme
	* @param {URL} url
	*/
	function urlIsHttpHttpsScheme$2(url$1) {
		assert$18("protocol" in url$1);
		const protocol = url$1.protocol;
		return protocol === "http:" || protocol === "https:";
	}
	/**
	* Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
	*/
	const hasOwn$1 = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
	module.exports = {
		isAborted: isAborted$2,
		isCancelled: isCancelled$2,
		createDeferredPromise: createDeferredPromise$3,
		ReadableStreamFrom: ReadableStreamFrom$2,
		toUSVString: toUSVString$4,
		tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL$1,
		coarsenedSharedCurrentTime: coarsenedSharedCurrentTime$1,
		determineRequestsReferrer: determineRequestsReferrer$1,
		makePolicyContainer: makePolicyContainer$2,
		clonePolicyContainer: clonePolicyContainer$1,
		appendFetchMetadata: appendFetchMetadata$1,
		appendRequestOriginHeader: appendRequestOriginHeader$1,
		TAOCheck: TAOCheck$1,
		corsCheck: corsCheck$1,
		crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck$1,
		createOpaqueTimingInfo: createOpaqueTimingInfo$1,
		setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect$1,
		isValidHTTPToken: isValidHTTPToken$1,
		requestBadPort: requestBadPort$1,
		requestCurrentURL: requestCurrentURL$1,
		responseURL,
		responseLocationURL: responseLocationURL$1,
		isBlobLike: isBlobLike$6,
		isURLPotentiallyTrustworthy,
		isValidReasonPhrase: isValidReasonPhrase$1,
		sameOrigin: sameOrigin$2,
		normalizeMethod: normalizeMethod$1,
		serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString$1,
		makeIterator: makeIterator$2,
		isValidHeaderName: isValidHeaderName$2,
		isValidHeaderValue: isValidHeaderValue$1,
		hasOwn: hasOwn$1,
		isErrorLike: isErrorLike$2,
		fullyReadBody: fullyReadBody$2,
		bytesMatch: bytesMatch$1,
		isReadableStreamLike: isReadableStreamLike$1,
		readableStreamClose: readableStreamClose$2,
		isomorphicEncode: isomorphicEncode$2,
		isomorphicDecode: isomorphicDecode$1,
		urlIsLocal: urlIsLocal$1,
		urlHasHttpsScheme: urlHasHttpsScheme$1,
		urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$2,
		readAllBytes: readAllBytes$1,
		normalizeMethodRecord: normalizeMethodRecord$1,
		parseMetadata
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/symbols.js
var require_symbols$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kUrl: Symbol("url"),
		kHeaders: Symbol("headers"),
		kSignal: Symbol("signal"),
		kState: Symbol("state"),
		kGuard: Symbol("guard"),
		kRealm: Symbol("realm")
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/webidl.js
var require_webidl = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { types: types$9 } = __require("util");
	const { hasOwn, toUSVString: toUSVString$3 } = require_util$5();
	/** @type {import('../../types/webidl').Webidl} */
	const webidl$14 = {};
	webidl$14.converters = {};
	webidl$14.util = {};
	webidl$14.errors = {};
	webidl$14.errors.exception = function(message) {
		return /* @__PURE__ */ new TypeError(`${message.header}: ${message.message}`);
	};
	webidl$14.errors.conversionFailed = function(context) {
		const plural = context.types.length === 1 ? "" : " one of";
		const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
		return webidl$14.errors.exception({
			header: context.prefix,
			message
		});
	};
	webidl$14.errors.invalidArgument = function(context) {
		return webidl$14.errors.exception({
			header: context.prefix,
			message: `"${context.value}" is an invalid ${context.type}.`
		});
	};
	webidl$14.brandCheck = function(V, I$1, opts = void 0) {
		if (opts?.strict !== false && !(V instanceof I$1)) throw new TypeError("Illegal invocation");
		else return V?.[Symbol.toStringTag] === I$1.prototype[Symbol.toStringTag];
	};
	webidl$14.argumentLengthCheck = function({ length }, min, ctx) {
		if (length < min) throw webidl$14.errors.exception({
			message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
			...ctx
		});
	};
	webidl$14.illegalConstructor = function() {
		throw webidl$14.errors.exception({
			header: "TypeError",
			message: "Illegal constructor"
		});
	};
	webidl$14.util.Type = function(V) {
		switch (typeof V) {
			case "undefined": return "Undefined";
			case "boolean": return "Boolean";
			case "string": return "String";
			case "symbol": return "Symbol";
			case "number": return "Number";
			case "bigint": return "BigInt";
			case "function":
			case "object":
				if (V === null) return "Null";
				return "Object";
		}
	};
	webidl$14.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
		let upperBound;
		let lowerBound;
		if (bitLength === 64) {
			upperBound = Math.pow(2, 53) - 1;
			if (signedness === "unsigned") lowerBound = 0;
			else lowerBound = Math.pow(-2, 53) + 1;
		} else if (signedness === "unsigned") {
			lowerBound = 0;
			upperBound = Math.pow(2, bitLength) - 1;
		} else {
			lowerBound = Math.pow(-2, bitLength) - 1;
			upperBound = Math.pow(2, bitLength - 1) - 1;
		}
		let x$5 = Number(V);
		if (x$5 === 0) x$5 = 0;
		if (opts.enforceRange === true) {
			if (Number.isNaN(x$5) || x$5 === Number.POSITIVE_INFINITY || x$5 === Number.NEGATIVE_INFINITY) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Could not convert ${V} to an integer.`
			});
			x$5 = webidl$14.util.IntegerPart(x$5);
			if (x$5 < lowerBound || x$5 > upperBound) throw webidl$14.errors.exception({
				header: "Integer conversion",
				message: `Value must be between ${lowerBound}-${upperBound}, got ${x$5}.`
			});
			return x$5;
		}
		if (!Number.isNaN(x$5) && opts.clamp === true) {
			x$5 = Math.min(Math.max(x$5, lowerBound), upperBound);
			if (Math.floor(x$5) % 2 === 0) x$5 = Math.floor(x$5);
			else x$5 = Math.ceil(x$5);
			return x$5;
		}
		if (Number.isNaN(x$5) || x$5 === 0 && Object.is(0, x$5) || x$5 === Number.POSITIVE_INFINITY || x$5 === Number.NEGATIVE_INFINITY) return 0;
		x$5 = webidl$14.util.IntegerPart(x$5);
		x$5 = x$5 % Math.pow(2, bitLength);
		if (signedness === "signed" && x$5 >= Math.pow(2, bitLength) - 1) return x$5 - Math.pow(2, bitLength);
		return x$5;
	};
	webidl$14.util.IntegerPart = function(n$5) {
		const r$5 = Math.floor(Math.abs(n$5));
		if (n$5 < 0) return -1 * r$5;
		return r$5;
	};
	webidl$14.sequenceConverter = function(converter) {
		return (V) => {
			if (webidl$14.util.Type(V) !== "Object") throw webidl$14.errors.exception({
				header: "Sequence",
				message: `Value of type ${webidl$14.util.Type(V)} is not an Object.`
			});
			/** @type {Generator} */
			const method = V?.[Symbol.iterator]?.();
			const seq = [];
			if (method === void 0 || typeof method.next !== "function") throw webidl$14.errors.exception({
				header: "Sequence",
				message: "Object is not an iterator."
			});
			while (true) {
				const { done, value } = method.next();
				if (done) break;
				seq.push(converter(value));
			}
			return seq;
		};
	};
	webidl$14.recordConverter = function(keyConverter, valueConverter) {
		return (O) => {
			if (webidl$14.util.Type(O) !== "Object") throw webidl$14.errors.exception({
				header: "Record",
				message: `Value of type ${webidl$14.util.Type(O)} is not an Object.`
			});
			const result = {};
			if (!types$9.isProxy(O)) {
				const keys$1 = Object.keys(O);
				for (const key of keys$1) {
					const typedKey = keyConverter(key);
					result[typedKey] = valueConverter(O[key]);
				}
				return result;
			}
			const keys = Reflect.ownKeys(O);
			for (const key of keys) if (Reflect.getOwnPropertyDescriptor(O, key)?.enumerable) {
				const typedKey = keyConverter(key);
				result[typedKey] = valueConverter(O[key]);
			}
			return result;
		};
	};
	webidl$14.interfaceConverter = function(i$5) {
		return (V, opts = {}) => {
			if (opts.strict !== false && !(V instanceof i$5)) throw webidl$14.errors.exception({
				header: i$5.name,
				message: `Expected ${V} to be an instance of ${i$5.name}.`
			});
			return V;
		};
	};
	webidl$14.dictionaryConverter = function(converters) {
		return (dictionary) => {
			const type = webidl$14.util.Type(dictionary);
			const dict = {};
			if (type === "Null" || type === "Undefined") return dict;
			else if (type !== "Object") throw webidl$14.errors.exception({
				header: "Dictionary",
				message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
			});
			for (const options of converters) {
				const { key, defaultValue, required, converter } = options;
				if (required === true) {
					if (!hasOwn(dictionary, key)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `Missing required key "${key}".`
					});
				}
				let value = dictionary[key];
				const hasDefault = hasOwn(options, "defaultValue");
				if (hasDefault && value !== null) value = value ?? defaultValue;
				if (required || hasDefault || value !== void 0) {
					value = converter(value);
					if (options.allowedValues && !options.allowedValues.includes(value)) throw webidl$14.errors.exception({
						header: "Dictionary",
						message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
					});
					dict[key] = value;
				}
			}
			return dict;
		};
	};
	webidl$14.nullableConverter = function(converter) {
		return (V) => {
			if (V === null) return V;
			return converter(V);
		};
	};
	webidl$14.converters.DOMString = function(V, opts = {}) {
		if (V === null && opts.legacyNullToEmptyString) return "";
		if (typeof V === "symbol") throw new TypeError("Could not convert argument of type symbol to string.");
		return String(V);
	};
	webidl$14.converters.ByteString = function(V) {
		const x$5 = webidl$14.converters.DOMString(V);
		for (let index = 0; index < x$5.length; index++) if (x$5.charCodeAt(index) > 255) throw new TypeError(`Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x$5.charCodeAt(index)} which is greater than 255.`);
		return x$5;
	};
	webidl$14.converters.USVString = toUSVString$3;
	webidl$14.converters.boolean = function(V) {
		return Boolean(V);
	};
	webidl$14.converters.any = function(V) {
		return V;
	};
	webidl$14.converters["long long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 64, "signed");
	};
	webidl$14.converters["unsigned long long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 64, "unsigned");
	};
	webidl$14.converters["unsigned long"] = function(V) {
		return webidl$14.util.ConvertToInt(V, 32, "unsigned");
	};
	webidl$14.converters["unsigned short"] = function(V, opts) {
		return webidl$14.util.ConvertToInt(V, 16, "unsigned", opts);
	};
	webidl$14.converters.ArrayBuffer = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$9.isAnyArrayBuffer(V)) throw webidl$14.errors.conversionFailed({
			prefix: `${V}`,
			argument: `${V}`,
			types: ["ArrayBuffer"]
		});
		if (opts.allowShared === false && types$9.isSharedArrayBuffer(V)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.TypedArray = function(V, T, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$9.isTypedArray(V) || V.constructor.name !== T.name) throw webidl$14.errors.conversionFailed({
			prefix: `${T.name}`,
			argument: `${V}`,
			types: [T.name]
		});
		if (opts.allowShared === false && types$9.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.DataView = function(V, opts = {}) {
		if (webidl$14.util.Type(V) !== "Object" || !types$9.isDataView(V)) throw webidl$14.errors.exception({
			header: "DataView",
			message: "Object is not a DataView."
		});
		if (opts.allowShared === false && types$9.isSharedArrayBuffer(V.buffer)) throw webidl$14.errors.exception({
			header: "ArrayBuffer",
			message: "SharedArrayBuffer is not allowed."
		});
		return V;
	};
	webidl$14.converters.BufferSource = function(V, opts = {}) {
		if (types$9.isAnyArrayBuffer(V)) return webidl$14.converters.ArrayBuffer(V, opts);
		if (types$9.isTypedArray(V)) return webidl$14.converters.TypedArray(V, V.constructor);
		if (types$9.isDataView(V)) return webidl$14.converters.DataView(V, opts);
		throw new TypeError(`Could not convert ${V} to a BufferSource.`);
	};
	webidl$14.converters["sequence<ByteString>"] = webidl$14.sequenceConverter(webidl$14.converters.ByteString);
	webidl$14.converters["sequence<sequence<ByteString>>"] = webidl$14.sequenceConverter(webidl$14.converters["sequence<ByteString>"]);
	webidl$14.converters["record<ByteString, ByteString>"] = webidl$14.recordConverter(webidl$14.converters.ByteString, webidl$14.converters.ByteString);
	module.exports = { webidl: webidl$14 };
}));

//#endregion
//#region node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$17 = __require("assert");
	const { atob: atob$1 } = __require("buffer");
	const { isomorphicDecode } = require_util$5();
	const encoder$1 = new TextEncoder();
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-token-code-point
	*/
	const HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
	const HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
	/**
	* @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
	*/
	const HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
	/** @param {URL} dataURL */
	function dataURLProcessor$1(dataURL) {
		assert$17(dataURL.protocol === "data:");
		let input = URLSerializer$4(dataURL, true);
		input = input.slice(5);
		const position = { position: 0 };
		let mimeType = collectASequenceOfCodePointsFast$1(",", input, position);
		const mimeTypeLength = mimeType.length;
		mimeType = removeASCIIWhitespace(mimeType, true, true);
		if (position.position >= input.length) return "failure";
		position.position++;
		let body = stringPercentDecode(input.slice(mimeTypeLength + 1));
		if (/;(\u0020){0,}base64$/i.test(mimeType)) {
			body = forgivingBase64(isomorphicDecode(body));
			if (body === "failure") return "failure";
			mimeType = mimeType.slice(0, -6);
			mimeType = mimeType.replace(/(\u0020)+$/, "");
			mimeType = mimeType.slice(0, -1);
		}
		if (mimeType.startsWith(";")) mimeType = "text/plain" + mimeType;
		let mimeTypeRecord = parseMIMEType$3(mimeType);
		if (mimeTypeRecord === "failure") mimeTypeRecord = parseMIMEType$3("text/plain;charset=US-ASCII");
		return {
			mimeType: mimeTypeRecord,
			body
		};
	}
	/**
	* @param {URL} url
	* @param {boolean} excludeFragment
	*/
	function URLSerializer$4(url$1, excludeFragment = false) {
		if (!excludeFragment) return url$1.href;
		const href = url$1.href;
		const hashLength = url$1.hash.length;
		return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
	}
	/**
	* @param {(char: string) => boolean} condition
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePoints(condition, input, position) {
		let result = "";
		while (position.position < input.length && condition(input[position.position])) {
			result += input[position.position];
			position.position++;
		}
		return result;
	}
	/**
	* A faster collectASequenceOfCodePoints that only works when comparing a single character.
	* @param {string} char
	* @param {string} input
	* @param {{ position: number }} position
	*/
	function collectASequenceOfCodePointsFast$1(char, input, position) {
		const idx = input.indexOf(char, position.position);
		const start = position.position;
		if (idx === -1) {
			position.position = input.length;
			return input.slice(start);
		}
		position.position = idx;
		return input.slice(start, position.position);
	}
	/** @param {string} input */
	function stringPercentDecode(input) {
		return percentDecode(encoder$1.encode(input));
	}
	/** @param {Uint8Array} input */
	function percentDecode(input) {
		/** @type {number[]} */
		const output = [];
		for (let i$5 = 0; i$5 < input.length; i$5++) {
			const byte = input[i$5];
			if (byte !== 37) output.push(byte);
			else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i$5 + 1], input[i$5 + 2]))) output.push(37);
			else {
				const nextTwoBytes = String.fromCharCode(input[i$5 + 1], input[i$5 + 2]);
				const bytePoint = Number.parseInt(nextTwoBytes, 16);
				output.push(bytePoint);
				i$5 += 2;
			}
		}
		return Uint8Array.from(output);
	}
	/** @param {string} input */
	function parseMIMEType$3(input) {
		input = removeHTTPWhitespace(input, true, true);
		const position = { position: 0 };
		const type = collectASequenceOfCodePointsFast$1("/", input, position);
		if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) return "failure";
		if (position.position > input.length) return "failure";
		position.position++;
		let subtype = collectASequenceOfCodePointsFast$1(";", input, position);
		subtype = removeHTTPWhitespace(subtype, false, true);
		if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) return "failure";
		const typeLowercase = type.toLowerCase();
		const subtypeLowercase = subtype.toLowerCase();
		const mimeType = {
			type: typeLowercase,
			subtype: subtypeLowercase,
			parameters: /* @__PURE__ */ new Map(),
			essence: `${typeLowercase}/${subtypeLowercase}`
		};
		while (position.position < input.length) {
			position.position++;
			collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
			let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
			parameterName = parameterName.toLowerCase();
			if (position.position < input.length) {
				if (input[position.position] === ";") continue;
				position.position++;
			}
			if (position.position > input.length) break;
			let parameterValue = null;
			if (input[position.position] === "\"") {
				parameterValue = collectAnHTTPQuotedString(input, position, true);
				collectASequenceOfCodePointsFast$1(";", input, position);
			} else {
				parameterValue = collectASequenceOfCodePointsFast$1(";", input, position);
				parameterValue = removeHTTPWhitespace(parameterValue, false, true);
				if (parameterValue.length === 0) continue;
			}
			if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) mimeType.parameters.set(parameterName, parameterValue);
		}
		return mimeType;
	}
	/** @param {string} data */
	function forgivingBase64(data$1) {
		data$1 = data$1.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
		if (data$1.length % 4 === 0) data$1 = data$1.replace(/=?=$/, "");
		if (data$1.length % 4 === 1) return "failure";
		if (/[^+/0-9A-Za-z]/.test(data$1)) return "failure";
		const binary = atob$1(data$1);
		const bytes = new Uint8Array(binary.length);
		for (let byte = 0; byte < binary.length; byte++) bytes[byte] = binary.charCodeAt(byte);
		return bytes;
	}
	/**
	* @param {string} input
	* @param {{ position: number }} position
	* @param {boolean?} extractValue
	*/
	function collectAnHTTPQuotedString(input, position, extractValue) {
		const positionStart = position.position;
		let value = "";
		assert$17(input[position.position] === "\"");
		position.position++;
		while (true) {
			value += collectASequenceOfCodePoints((char) => char !== "\"" && char !== "\\", input, position);
			if (position.position >= input.length) break;
			const quoteOrBackslash = input[position.position];
			position.position++;
			if (quoteOrBackslash === "\\") {
				if (position.position >= input.length) {
					value += "\\";
					break;
				}
				value += input[position.position];
				position.position++;
			} else {
				assert$17(quoteOrBackslash === "\"");
				break;
			}
		}
		if (extractValue) return value;
		return input.slice(positionStart, position.position);
	}
	/**
	* @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type
	*/
	function serializeAMimeType$4(mimeType) {
		assert$17(mimeType !== "failure");
		const { parameters, essence } = mimeType;
		let serialization = essence;
		for (let [name, value] of parameters.entries()) {
			serialization += ";";
			serialization += name;
			serialization += "=";
			if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
				value = value.replace(/(\\|")/g, "\\$1");
				value = "\"" + value;
				value += "\"";
			}
			serialization += value;
		}
		return serialization;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} char
	*/
	function isHTTPWhiteSpace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === " ";
	}
	/**
	* @see https://fetch.spec.whatwg.org/#http-whitespace
	* @param {string} str
	*/
	function removeHTTPWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	/**
	* @see https://infra.spec.whatwg.org/#ascii-whitespace
	* @param {string} char
	*/
	function isASCIIWhitespace(char) {
		return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
	}
	/**
	* @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace
	*/
	function removeASCIIWhitespace(str, leading = true, trailing = true) {
		let lead = 0;
		let trail = str.length - 1;
		if (leading) for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++);
		if (trailing) for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--);
		return str.slice(lead, trail + 1);
	}
	module.exports = {
		dataURLProcessor: dataURLProcessor$1,
		URLSerializer: URLSerializer$4,
		collectASequenceOfCodePoints,
		collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast$1,
		stringPercentDecode,
		parseMIMEType: parseMIMEType$3,
		collectAnHTTPQuotedString,
		serializeAMimeType: serializeAMimeType$4
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/file.js
var require_file = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Blob: Blob$4, File: NativeFile$2 } = __require("buffer");
	const { types: types$8 } = __require("util");
	const { kState: kState$9 } = require_symbols$3();
	const { isBlobLike: isBlobLike$5 } = require_util$5();
	const { webidl: webidl$13 } = require_webidl();
	const { parseMIMEType: parseMIMEType$2, serializeAMimeType: serializeAMimeType$3 } = require_dataURL();
	const { kEnumerableProperty: kEnumerableProperty$8 } = require_util$6();
	const encoder = new TextEncoder();
	var File$2 = class File$2 extends Blob$4 {
		constructor(fileBits, fileName, options = {}) {
			webidl$13.argumentLengthCheck(arguments, 2, { header: "File constructor" });
			fileBits = webidl$13.converters["sequence<BlobPart>"](fileBits);
			fileName = webidl$13.converters.USVString(fileName);
			options = webidl$13.converters.FilePropertyBag(options);
			const n$5 = fileName;
			let t$5 = options.type;
			let d$5;
			substep: {
				if (t$5) {
					t$5 = parseMIMEType$2(t$5);
					if (t$5 === "failure") {
						t$5 = "";
						break substep;
					}
					t$5 = serializeAMimeType$3(t$5).toLowerCase();
				}
				d$5 = options.lastModified;
			}
			super(processBlobParts(fileBits, options), { type: t$5 });
			this[kState$9] = {
				name: n$5,
				lastModified: d$5,
				type: t$5
			};
		}
		get name() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].lastModified;
		}
		get type() {
			webidl$13.brandCheck(this, File$2);
			return this[kState$9].type;
		}
	};
	var FileLike$1 = class FileLike$1 {
		constructor(blobLike, fileName, options = {}) {
			this[kState$9] = {
				blobLike,
				name: fileName,
				type: options.type,
				lastModified: options.lastModified ?? Date.now()
			};
		}
		stream(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.stream(...args);
		}
		arrayBuffer(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.arrayBuffer(...args);
		}
		slice(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.slice(...args);
		}
		text(...args) {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.text(...args);
		}
		get size() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.size;
		}
		get type() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].blobLike.type;
		}
		get name() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].name;
		}
		get lastModified() {
			webidl$13.brandCheck(this, FileLike$1);
			return this[kState$9].lastModified;
		}
		get [Symbol.toStringTag]() {
			return "File";
		}
	};
	Object.defineProperties(File$2.prototype, {
		[Symbol.toStringTag]: {
			value: "File",
			configurable: true
		},
		name: kEnumerableProperty$8,
		lastModified: kEnumerableProperty$8
	});
	webidl$13.converters.Blob = webidl$13.interfaceConverter(Blob$4);
	webidl$13.converters.BlobPart = function(V, opts) {
		if (webidl$13.util.Type(V) === "Object") {
			if (isBlobLike$5(V)) return webidl$13.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$8.isAnyArrayBuffer(V)) return webidl$13.converters.BufferSource(V, opts);
		}
		return webidl$13.converters.USVString(V, opts);
	};
	webidl$13.converters["sequence<BlobPart>"] = webidl$13.sequenceConverter(webidl$13.converters.BlobPart);
	webidl$13.converters.FilePropertyBag = webidl$13.dictionaryConverter([
		{
			key: "lastModified",
			converter: webidl$13.converters["long long"],
			get defaultValue() {
				return Date.now();
			}
		},
		{
			key: "type",
			converter: webidl$13.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "endings",
			converter: (value) => {
				value = webidl$13.converters.DOMString(value);
				value = value.toLowerCase();
				if (value !== "native") value = "transparent";
				return value;
			},
			defaultValue: "transparent"
		}
	]);
	/**
	* @see https://www.w3.org/TR/FileAPI/#process-blob-parts
	* @param {(NodeJS.TypedArray|Blob|string)[]} parts
	* @param {{ type: string, endings: string }} options
	*/
	function processBlobParts(parts, options) {
		/** @type {NodeJS.TypedArray[]} */
		const bytes = [];
		for (const element of parts) if (typeof element === "string") {
			let s$5 = element;
			if (options.endings === "native") s$5 = convertLineEndingsNative(s$5);
			bytes.push(encoder.encode(s$5));
		} else if (types$8.isAnyArrayBuffer(element) || types$8.isTypedArray(element)) if (!element.buffer) bytes.push(new Uint8Array(element));
		else bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
		else if (isBlobLike$5(element)) bytes.push(element);
		return bytes;
	}
	/**
	* @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
	* @param {string} s
	*/
	function convertLineEndingsNative(s$5) {
		let nativeLineEnding = "\n";
		if (process.platform === "win32") nativeLineEnding = "\r\n";
		return s$5.replace(/\r?\n/g, nativeLineEnding);
	}
	function isFileLike$1(object) {
		return NativeFile$2 && object instanceof NativeFile$2 || object instanceof File$2 || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
	}
	module.exports = {
		File: File$2,
		FileLike: FileLike$1,
		isFileLike: isFileLike$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/formdata.js
var require_formdata = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { isBlobLike: isBlobLike$4, toUSVString: toUSVString$2, makeIterator: makeIterator$1 } = require_util$5();
	const { kState: kState$8 } = require_symbols$3();
	const { File: UndiciFile$1, FileLike, isFileLike } = require_file();
	const { webidl: webidl$12 } = require_webidl();
	const { Blob: Blob$3, File: NativeFile$1 } = __require("buffer");
	/** @type {globalThis['File']} */
	const File$1 = NativeFile$1 ?? UndiciFile$1;
	var FormData$2 = class FormData$2 {
		constructor(form) {
			if (form !== void 0) throw webidl$12.errors.conversionFailed({
				prefix: "FormData constructor",
				argument: "Argument 1",
				types: ["undefined"]
			});
			this[kState$8] = [];
		}
		append(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? webidl$12.converters.USVString(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			this[kState$8].push(entry);
		}
		delete(name) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
			name = webidl$12.converters.USVString(name);
			this[kState$8] = this[kState$8].filter((entry) => entry.name !== name);
		}
		get(name) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
			name = webidl$12.converters.USVString(name);
			const idx = this[kState$8].findIndex((entry) => entry.name === name);
			if (idx === -1) return null;
			return this[kState$8][idx].value;
		}
		getAll(name) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].filter((entry) => entry.name === name).map((entry) => entry.value);
		}
		has(name) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
			name = webidl$12.converters.USVString(name);
			return this[kState$8].findIndex((entry) => entry.name === name) !== -1;
		}
		set(name, value, filename = void 0) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
			if (arguments.length === 3 && !isBlobLike$4(value)) throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
			name = webidl$12.converters.USVString(name);
			value = isBlobLike$4(value) ? webidl$12.converters.Blob(value, { strict: false }) : webidl$12.converters.USVString(value);
			filename = arguments.length === 3 ? toUSVString$2(filename) : void 0;
			const entry = makeEntry(name, value, filename);
			const idx = this[kState$8].findIndex((entry$1) => entry$1.name === name);
			if (idx !== -1) this[kState$8] = [
				...this[kState$8].slice(0, idx),
				entry,
				...this[kState$8].slice(idx + 1).filter((entry$1) => entry$1.name !== name)
			];
			else this[kState$8].push(entry);
		}
		entries() {
			webidl$12.brandCheck(this, FormData$2);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
		}
		keys() {
			webidl$12.brandCheck(this, FormData$2);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "key");
		}
		values() {
			webidl$12.brandCheck(this, FormData$2);
			return makeIterator$1(() => this[kState$8].map((pair) => [pair.name, pair.value]), "FormData", "value");
		}
		/**
		* @param {(value: string, key: string, self: FormData) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$12.brandCheck(this, FormData$2);
			webidl$12.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
	};
	FormData$2.prototype[Symbol.iterator] = FormData$2.prototype.entries;
	Object.defineProperties(FormData$2.prototype, { [Symbol.toStringTag]: {
		value: "FormData",
		configurable: true
	} });
	/**
	* @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
	* @param {string} name
	* @param {string|Blob} value
	* @param {?string} filename
	* @returns
	*/
	function makeEntry(name, value, filename) {
		name = Buffer.from(name).toString("utf8");
		if (typeof value === "string") value = Buffer.from(value).toString("utf8");
		else {
			if (!isFileLike(value)) value = value instanceof Blob$3 ? new File$1([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
			if (filename !== void 0) {
				/** @type {FilePropertyBag} */
				const options = {
					type: value.type,
					lastModified: value.lastModified
				};
				value = NativeFile$1 && value instanceof NativeFile$1 || value instanceof UndiciFile$1 ? new File$1([value], filename, options) : new FileLike(value, filename, options);
			}
		}
		return {
			name,
			value
		};
	}
	module.exports = { FormData: FormData$2 };
}));

//#endregion
//#region node_modules/undici/lib/fetch/body.js
var require_body = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Busboy = require_main();
	const util$17 = require_util$6();
	const { ReadableStreamFrom: ReadableStreamFrom$1, isBlobLike: isBlobLike$3, isReadableStreamLike, readableStreamClose: readableStreamClose$1, createDeferredPromise: createDeferredPromise$2, fullyReadBody: fullyReadBody$1 } = require_util$5();
	const { FormData: FormData$1 } = require_formdata();
	const { kState: kState$7 } = require_symbols$3();
	const { webidl: webidl$11 } = require_webidl();
	const { DOMException: DOMException$5, structuredClone: structuredClone$1 } = require_constants$3();
	const { Blob: Blob$2, File: NativeFile } = __require("buffer");
	const { kBodyUsed: kBodyUsed$1 } = require_symbols$4();
	const assert$16 = __require("assert");
	const { isErrored: isErrored$1 } = require_util$6();
	const { isUint8Array, isArrayBuffer: isArrayBuffer$3 } = __require("util/types");
	const { File: UndiciFile } = require_file();
	const { parseMIMEType: parseMIMEType$1, serializeAMimeType: serializeAMimeType$2 } = require_dataURL();
	let random;
	try {
		const crypto$6 = __require("node:crypto");
		random = (max) => crypto$6.randomInt(0, max);
	} catch {
		random = (max) => Math.floor(Math.random(max));
	}
	let ReadableStream$3 = globalThis.ReadableStream;
	/** @type {globalThis['File']} */
	const File = NativeFile ?? UndiciFile;
	const textEncoder$1 = new TextEncoder();
	const textDecoder$1 = new TextDecoder();
	function extractBody$3(object, keepalive = false) {
		if (!ReadableStream$3) ReadableStream$3 = __require("stream/web").ReadableStream;
		let stream$3 = null;
		if (object instanceof ReadableStream$3) stream$3 = object;
		else if (isBlobLike$3(object)) stream$3 = object.stream();
		else stream$3 = new ReadableStream$3({
			async pull(controller) {
				controller.enqueue(typeof source === "string" ? textEncoder$1.encode(source) : source);
				queueMicrotask(() => readableStreamClose$1(controller));
			},
			start() {},
			type: void 0
		});
		assert$16(isReadableStreamLike(stream$3));
		let action = null;
		let source = null;
		let length = null;
		let type = null;
		if (typeof object === "string") {
			source = object;
			type = "text/plain;charset=UTF-8";
		} else if (object instanceof URLSearchParams) {
			source = object.toString();
			type = "application/x-www-form-urlencoded;charset=UTF-8";
		} else if (isArrayBuffer$3(object)) source = new Uint8Array(object.slice());
		else if (ArrayBuffer.isView(object)) source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
		else if (util$17.isFormDataLike(object)) {
			const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, "0")}`;
			const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
			/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
			const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
			const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
			const blobParts = [];
			const rn = new Uint8Array([13, 10]);
			length = 0;
			let hasUnknownSizeValue = false;
			for (const [name, value] of object) if (typeof value === "string") {
				const chunk$1 = textEncoder$1.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
				blobParts.push(chunk$1);
				length += chunk$1.byteLength;
			} else {
				const chunk$1 = textEncoder$1.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
				blobParts.push(chunk$1, value, rn);
				if (typeof value.size === "number") length += chunk$1.byteLength + value.size + rn.byteLength;
				else hasUnknownSizeValue = true;
			}
			const chunk = textEncoder$1.encode(`--${boundary}--`);
			blobParts.push(chunk);
			length += chunk.byteLength;
			if (hasUnknownSizeValue) length = null;
			source = object;
			action = async function* () {
				for (const part of blobParts) if (part.stream) yield* part.stream();
				else yield part;
			};
			type = "multipart/form-data; boundary=" + boundary;
		} else if (isBlobLike$3(object)) {
			source = object;
			length = object.size;
			if (object.type) type = object.type;
		} else if (typeof object[Symbol.asyncIterator] === "function") {
			if (keepalive) throw new TypeError("keepalive");
			if (util$17.isDisturbed(object) || object.locked) throw new TypeError("Response body object should not be disturbed or locked");
			stream$3 = object instanceof ReadableStream$3 ? object : ReadableStreamFrom$1(object);
		}
		if (typeof source === "string" || util$17.isBuffer(source)) length = Buffer.byteLength(source);
		if (action != null) {
			let iterator;
			stream$3 = new ReadableStream$3({
				async start() {
					iterator = action(object)[Symbol.asyncIterator]();
				},
				async pull(controller) {
					const { value, done } = await iterator.next();
					if (done) queueMicrotask(() => {
						controller.close();
					});
					else if (!isErrored$1(stream$3)) controller.enqueue(new Uint8Array(value));
					return controller.desiredSize > 0;
				},
				async cancel(reason) {
					await iterator.return();
				},
				type: void 0
			});
		}
		return [{
			stream: stream$3,
			source,
			length
		}, type];
	}
	function safelyExtractBody$1(object, keepalive = false) {
		if (!ReadableStream$3)
 // istanbul ignore next
		ReadableStream$3 = __require("stream/web").ReadableStream;
		if (object instanceof ReadableStream$3) {
			// istanbul ignore next
			assert$16(!util$17.isDisturbed(object), "The body has already been consumed.");
			// istanbul ignore next
			assert$16(!object.locked, "The stream is locked.");
		}
		return extractBody$3(object, keepalive);
	}
	function cloneBody$2(body) {
		const [out1, out2] = body.stream.tee();
		const [, finalClone] = structuredClone$1(out2, { transfer: [out2] }).tee();
		body.stream = out1;
		return {
			stream: finalClone,
			length: body.length,
			source: body.source
		};
	}
	async function* consumeBody(body) {
		if (body) if (isUint8Array(body)) yield body;
		else {
			const stream$3 = body.stream;
			if (util$17.isDisturbed(stream$3)) throw new TypeError("The body has already been consumed.");
			if (stream$3.locked) throw new TypeError("The stream is locked.");
			stream$3[kBodyUsed$1] = true;
			yield* stream$3;
		}
	}
	function throwIfAborted(state$1) {
		if (state$1.aborted) throw new DOMException$5("The operation was aborted.", "AbortError");
	}
	function bodyMixinMethods(instance) {
		return {
			blob() {
				return specConsumeBody(this, (bytes) => {
					let mimeType = bodyMimeType(this);
					if (mimeType === "failure") mimeType = "";
					else if (mimeType) mimeType = serializeAMimeType$2(mimeType);
					return new Blob$2([bytes], { type: mimeType });
				}, instance);
			},
			arrayBuffer() {
				return specConsumeBody(this, (bytes) => {
					return new Uint8Array(bytes).buffer;
				}, instance);
			},
			text() {
				return specConsumeBody(this, utf8DecodeBytes, instance);
			},
			json() {
				return specConsumeBody(this, parseJSONFromBytes, instance);
			},
			async formData() {
				webidl$11.brandCheck(this, instance);
				throwIfAborted(this[kState$7]);
				const contentType = this.headers.get("Content-Type");
				if (/multipart\/form-data/.test(contentType)) {
					const headers = {};
					for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
					const responseFormData = new FormData$1();
					let busboy;
					try {
						busboy = new Busboy({
							headers,
							preservePath: true
						});
					} catch (err) {
						throw new DOMException$5(`${err}`, "AbortError");
					}
					busboy.on("field", (name, value) => {
						responseFormData.append(name, value);
					});
					busboy.on("file", (name, value, filename, encoding, mimeType) => {
						const chunks = [];
						if (encoding === "base64" || encoding.toLowerCase() === "base64") {
							let base64chunk = "";
							value.on("data", (chunk) => {
								base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
								const end = base64chunk.length - base64chunk.length % 4;
								chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
								base64chunk = base64chunk.slice(end);
							});
							value.on("end", () => {
								chunks.push(Buffer.from(base64chunk, "base64"));
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						} else {
							value.on("data", (chunk) => {
								chunks.push(chunk);
							});
							value.on("end", () => {
								responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
							});
						}
					});
					const busboyResolve = new Promise((resolve, reject) => {
						busboy.on("finish", resolve);
						busboy.on("error", (err) => reject(new TypeError(err)));
					});
					if (this.body !== null) for await (const chunk of consumeBody(this[kState$7].body)) busboy.write(chunk);
					busboy.end();
					await busboyResolve;
					return responseFormData;
				} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
					let entries;
					try {
						let text = "";
						const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
						for await (const chunk of consumeBody(this[kState$7].body)) {
							if (!isUint8Array(chunk)) throw new TypeError("Expected Uint8Array chunk");
							text += streamingDecoder.decode(chunk, { stream: true });
						}
						text += streamingDecoder.decode();
						entries = new URLSearchParams(text);
					} catch (err) {
						// istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
						throw Object.assign(/* @__PURE__ */ new TypeError(), { cause: err });
					}
					const formData = new FormData$1();
					for (const [name, value] of entries) formData.append(name, value);
					return formData;
				} else {
					await Promise.resolve();
					throwIfAborted(this[kState$7]);
					throw webidl$11.errors.exception({
						header: `${instance.name}.formData`,
						message: "Could not parse content as FormData."
					});
				}
			}
		};
	}
	function mixinBody$2(prototype) {
		Object.assign(prototype.prototype, bodyMixinMethods(prototype));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-consume-body
	* @param {Response|Request} object
	* @param {(value: unknown) => unknown} convertBytesToJSValue
	* @param {Response|Request} instance
	*/
	async function specConsumeBody(object, convertBytesToJSValue, instance) {
		webidl$11.brandCheck(object, instance);
		throwIfAborted(object[kState$7]);
		if (bodyUnusable(object[kState$7].body)) throw new TypeError("Body is unusable");
		const promise = createDeferredPromise$2();
		const errorSteps = (error$2) => promise.reject(error$2);
		const successSteps = (data$1) => {
			try {
				promise.resolve(convertBytesToJSValue(data$1));
			} catch (e$5) {
				errorSteps(e$5);
			}
		};
		if (object[kState$7].body == null) {
			successSteps(new Uint8Array());
			return promise.promise;
		}
		await fullyReadBody$1(object[kState$7].body, successSteps, errorSteps);
		return promise.promise;
	}
	function bodyUnusable(body) {
		return body != null && (body.stream.locked || util$17.isDisturbed(body.stream));
	}
	/**
	* @see https://encoding.spec.whatwg.org/#utf-8-decode
	* @param {Buffer} buffer
	*/
	function utf8DecodeBytes(buffer$3) {
		if (buffer$3.length === 0) return "";
		if (buffer$3[0] === 239 && buffer$3[1] === 187 && buffer$3[2] === 191) buffer$3 = buffer$3.subarray(3);
		return textDecoder$1.decode(buffer$3);
	}
	/**
	* @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value
	* @param {Uint8Array} bytes
	*/
	function parseJSONFromBytes(bytes) {
		return JSON.parse(utf8DecodeBytes(bytes));
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-body-mime-type
	* @param {import('./response').Response|import('./request').Request} object
	*/
	function bodyMimeType(object) {
		const { headersList } = object[kState$7];
		const contentType = headersList.get("content-type");
		if (contentType === null) return "failure";
		return parseMIMEType$1(contentType);
	}
	module.exports = {
		extractBody: extractBody$3,
		safelyExtractBody: safelyExtractBody$1,
		cloneBody: cloneBody$2,
		mixinBody: mixinBody$2
	};
}));

//#endregion
//#region node_modules/undici/lib/core/request.js
var require_request$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$20, NotSupportedError: NotSupportedError$1 } = require_errors();
	const assert$15 = __require("assert");
	const { kHTTP2BuildRequest: kHTTP2BuildRequest$1, kHTTP2CopyHeaders: kHTTP2CopyHeaders$1, kHTTP1BuildRequest: kHTTP1BuildRequest$1 } = require_symbols$4();
	const util$16 = require_util$6();
	/**
	* Verifies that the given val is a valid HTTP token
	* per the rules defined in RFC 7230
	* See https://tools.ietf.org/html/rfc7230#section-3.2.6
	*/
	const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
	/**
	* Matches if val contains an invalid field-vchar
	*  field-value    = *( field-content / obs-fold )
	*  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	*  field-vchar    = VCHAR / obs-text
	*/
	const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
	const invalidPathRegex = /[^\u0021-\u00ff]/;
	const kHandler = Symbol("handler");
	const channels$3 = {};
	let extractBody$2;
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels$3.create = diagnosticsChannel$2.channel("undici:request:create");
		channels$3.bodySent = diagnosticsChannel$2.channel("undici:request:bodySent");
		channels$3.headers = diagnosticsChannel$2.channel("undici:request:headers");
		channels$3.trailers = diagnosticsChannel$2.channel("undici:request:trailers");
		channels$3.error = diagnosticsChannel$2.channel("undici:request:error");
	} catch {
		channels$3.create = { hasSubscribers: false };
		channels$3.bodySent = { hasSubscribers: false };
		channels$3.headers = { hasSubscribers: false };
		channels$3.trailers = { hasSubscribers: false };
		channels$3.error = { hasSubscribers: false };
	}
	var Request$5 = class Request$5 {
		constructor(origin, { path: path$6, method, body, headers, query, idempotent, blocking, upgrade: upgrade$1, headersTimeout, bodyTimeout, reset, throwOnError, expectContinue }, handler) {
			if (typeof path$6 !== "string") throw new InvalidArgumentError$20("path must be a string");
			else if (path$6[0] !== "/" && !(path$6.startsWith("http://") || path$6.startsWith("https://")) && method !== "CONNECT") throw new InvalidArgumentError$20("path must be an absolute URL or start with a slash");
			else if (invalidPathRegex.exec(path$6) !== null) throw new InvalidArgumentError$20("invalid request path");
			if (typeof method !== "string") throw new InvalidArgumentError$20("method must be a string");
			else if (tokenRegExp.exec(method) === null) throw new InvalidArgumentError$20("invalid request method");
			if (upgrade$1 && typeof upgrade$1 !== "string") throw new InvalidArgumentError$20("upgrade must be a string");
			if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$20("invalid headersTimeout");
			if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$20("invalid bodyTimeout");
			if (reset != null && typeof reset !== "boolean") throw new InvalidArgumentError$20("invalid reset");
			if (expectContinue != null && typeof expectContinue !== "boolean") throw new InvalidArgumentError$20("invalid expectContinue");
			this.headersTimeout = headersTimeout;
			this.bodyTimeout = bodyTimeout;
			this.throwOnError = throwOnError === true;
			this.method = method;
			this.abort = null;
			if (body == null) this.body = null;
			else if (util$16.isStream(body)) {
				this.body = body;
				const rState = this.body._readableState;
				if (!rState || !rState.autoDestroy) {
					this.endHandler = function autoDestroy() {
						util$16.destroy(this);
					};
					this.body.on("end", this.endHandler);
				}
				this.errorHandler = (err) => {
					if (this.abort) this.abort(err);
					else this.error = err;
				};
				this.body.on("error", this.errorHandler);
			} else if (util$16.isBuffer(body)) this.body = body.byteLength ? body : null;
			else if (ArrayBuffer.isView(body)) this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
			else if (body instanceof ArrayBuffer) this.body = body.byteLength ? Buffer.from(body) : null;
			else if (typeof body === "string") this.body = body.length ? Buffer.from(body) : null;
			else if (util$16.isFormDataLike(body) || util$16.isIterable(body) || util$16.isBlobLike(body)) this.body = body;
			else throw new InvalidArgumentError$20("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
			this.completed = false;
			this.aborted = false;
			this.upgrade = upgrade$1 || null;
			this.path = query ? util$16.buildURL(path$6, query) : path$6;
			this.origin = origin;
			this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
			this.blocking = blocking == null ? false : blocking;
			this.reset = reset == null ? null : reset;
			this.host = null;
			this.contentLength = null;
			this.contentType = null;
			this.headers = "";
			this.expectContinue = expectContinue != null ? expectContinue : false;
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$5 = 0; i$5 < headers.length; i$5 += 2) processHeader(this, headers[i$5], headers[i$5 + 1]);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$5 = 0; i$5 < keys.length; i$5++) {
					const key = keys[i$5];
					processHeader(this, key, headers[key]);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			if (util$16.isFormDataLike(this.body)) {
				if (util$16.nodeMajor < 16 || util$16.nodeMajor === 16 && util$16.nodeMinor < 8) throw new InvalidArgumentError$20("Form-Data bodies are only supported in node v16.8 and newer.");
				if (!extractBody$2) extractBody$2 = require_body().extractBody;
				const [bodyStream, contentType] = extractBody$2(body);
				if (this.contentType == null) {
					this.contentType = contentType;
					this.headers += `content-type: ${contentType}\r\n`;
				}
				this.body = bodyStream.stream;
				this.contentLength = bodyStream.length;
			} else if (util$16.isBlobLike(body) && this.contentType == null && body.type) {
				this.contentType = body.type;
				this.headers += `content-type: ${body.type}\r\n`;
			}
			util$16.validateHandler(handler, method, upgrade$1);
			this.servername = util$16.getServerName(this.host);
			this[kHandler] = handler;
			if (channels$3.create.hasSubscribers) channels$3.create.publish({ request: this });
		}
		onBodySent(chunk) {
			if (this[kHandler].onBodySent) try {
				return this[kHandler].onBodySent(chunk);
			} catch (err) {
				this.abort(err);
			}
		}
		onRequestSent() {
			if (channels$3.bodySent.hasSubscribers) channels$3.bodySent.publish({ request: this });
			if (this[kHandler].onRequestSent) try {
				return this[kHandler].onRequestSent();
			} catch (err) {
				this.abort(err);
			}
		}
		onConnect(abort$1) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (this.error) abort$1(this.error);
			else {
				this.abort = abort$1;
				return this[kHandler].onConnect(abort$1);
			}
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			if (channels$3.headers.hasSubscribers) channels$3.headers.publish({
				request: this,
				response: {
					statusCode,
					headers,
					statusText
				}
			});
			try {
				return this[kHandler].onHeaders(statusCode, headers, resume$1, statusText);
			} catch (err) {
				this.abort(err);
			}
		}
		onData(chunk) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			try {
				return this[kHandler].onData(chunk);
			} catch (err) {
				this.abort(err);
				return false;
			}
		}
		onUpgrade(statusCode, headers, socket) {
			assert$15(!this.aborted);
			assert$15(!this.completed);
			return this[kHandler].onUpgrade(statusCode, headers, socket);
		}
		onComplete(trailers) {
			this.onFinally();
			assert$15(!this.aborted);
			this.completed = true;
			if (channels$3.trailers.hasSubscribers) channels$3.trailers.publish({
				request: this,
				trailers
			});
			try {
				return this[kHandler].onComplete(trailers);
			} catch (err) {
				this.onError(err);
			}
		}
		onError(error$2) {
			this.onFinally();
			if (channels$3.error.hasSubscribers) channels$3.error.publish({
				request: this,
				error: error$2
			});
			if (this.aborted) return;
			this.aborted = true;
			return this[kHandler].onError(error$2);
		}
		onFinally() {
			if (this.errorHandler) {
				this.body.off("error", this.errorHandler);
				this.errorHandler = null;
			}
			if (this.endHandler) {
				this.body.off("end", this.endHandler);
				this.endHandler = null;
			}
		}
		addHeader(key, value) {
			processHeader(this, key, value);
			return this;
		}
		static [kHTTP1BuildRequest$1](origin, opts, handler) {
			return new Request$5(origin, opts, handler);
		}
		static [kHTTP2BuildRequest$1](origin, opts, handler) {
			const headers = opts.headers;
			opts = {
				...opts,
				headers: null
			};
			const request$1 = new Request$5(origin, opts, handler);
			request$1.headers = {};
			if (Array.isArray(headers)) {
				if (headers.length % 2 !== 0) throw new InvalidArgumentError$20("headers array must be even");
				for (let i$5 = 0; i$5 < headers.length; i$5 += 2) processHeader(request$1, headers[i$5], headers[i$5 + 1], true);
			} else if (headers && typeof headers === "object") {
				const keys = Object.keys(headers);
				for (let i$5 = 0; i$5 < keys.length; i$5++) {
					const key = keys[i$5];
					processHeader(request$1, key, headers[key], true);
				}
			} else if (headers != null) throw new InvalidArgumentError$20("headers must be an object or an array");
			return request$1;
		}
		static [kHTTP2CopyHeaders$1](raw) {
			const rawHeaders = raw.split("\r\n");
			const headers = {};
			for (const header of rawHeaders) {
				const [key, value] = header.split(": ");
				if (value == null || value.length === 0) continue;
				if (headers[key]) headers[key] += `,${value}`;
				else headers[key] = value;
			}
			return headers;
		}
	};
	function processHeaderValue(key, val, skipAppend) {
		if (val && typeof val === "object") throw new InvalidArgumentError$20(`invalid ${key} header`);
		val = val != null ? `${val}` : "";
		if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
		return skipAppend ? val : `${key}: ${val}\r\n`;
	}
	function processHeader(request$1, key, val, skipAppend = false) {
		if (val && typeof val === "object" && !Array.isArray(val)) throw new InvalidArgumentError$20(`invalid ${key} header`);
		else if (val === void 0) return;
		if (request$1.host === null && key.length === 4 && key.toLowerCase() === "host") {
			if (headerCharRegex.exec(val) !== null) throw new InvalidArgumentError$20(`invalid ${key} header`);
			request$1.host = val;
		} else if (request$1.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
			request$1.contentLength = parseInt(val, 10);
			if (!Number.isFinite(request$1.contentLength)) throw new InvalidArgumentError$20("invalid content-length header");
		} else if (request$1.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
			request$1.contentType = val;
			if (skipAppend) request$1.headers[key] = processHeaderValue(key, val, skipAppend);
			else request$1.headers += processHeaderValue(key, val);
		} else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") throw new InvalidArgumentError$20("invalid transfer-encoding header");
		else if (key.length === 10 && key.toLowerCase() === "connection") {
			const value = typeof val === "string" ? val.toLowerCase() : null;
			if (value !== "close" && value !== "keep-alive") throw new InvalidArgumentError$20("invalid connection header");
			else if (value === "close") request$1.reset = true;
		} else if (key.length === 10 && key.toLowerCase() === "keep-alive") throw new InvalidArgumentError$20("invalid keep-alive header");
		else if (key.length === 7 && key.toLowerCase() === "upgrade") throw new InvalidArgumentError$20("invalid upgrade header");
		else if (key.length === 6 && key.toLowerCase() === "expect") throw new NotSupportedError$1("expect header not supported");
		else if (tokenRegExp.exec(key) === null) throw new InvalidArgumentError$20("invalid header key");
		else if (Array.isArray(val)) for (let i$5 = 0; i$5 < val.length; i$5++) if (skipAppend) if (request$1.headers[key]) request$1.headers[key] += `,${processHeaderValue(key, val[i$5], skipAppend)}`;
		else request$1.headers[key] = processHeaderValue(key, val[i$5], skipAppend);
		else request$1.headers += processHeaderValue(key, val[i$5]);
		else if (skipAppend) request$1.headers[key] = processHeaderValue(key, val, skipAppend);
		else request$1.headers += processHeaderValue(key, val);
	}
	module.exports = Request$5;
}));

//#endregion
//#region node_modules/undici/lib/dispatcher.js
var require_dispatcher = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const EventEmitter = __require("events");
	var Dispatcher$3 = class extends EventEmitter {
		dispatch() {
			throw new Error("not implemented");
		}
		close() {
			throw new Error("not implemented");
		}
		destroy() {
			throw new Error("not implemented");
		}
	};
	module.exports = Dispatcher$3;
}));

//#endregion
//#region node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Dispatcher$2 = require_dispatcher();
	const { ClientDestroyedError: ClientDestroyedError$1, ClientClosedError, InvalidArgumentError: InvalidArgumentError$19 } = require_errors();
	const { kDestroy: kDestroy$4, kClose: kClose$6, kDispatch: kDispatch$3, kInterceptors: kInterceptors$5 } = require_symbols$4();
	const kDestroyed = Symbol("destroyed");
	const kClosed = Symbol("closed");
	const kOnDestroyed = Symbol("onDestroyed");
	const kOnClosed = Symbol("onClosed");
	const kInterceptedDispatch = Symbol("Intercepted Dispatch");
	var DispatcherBase$4 = class extends Dispatcher$2 {
		constructor() {
			super();
			this[kDestroyed] = false;
			this[kOnDestroyed] = null;
			this[kClosed] = false;
			this[kOnClosed] = [];
		}
		get destroyed() {
			return this[kDestroyed];
		}
		get closed() {
			return this[kClosed];
		}
		get interceptors() {
			return this[kInterceptors$5];
		}
		set interceptors(newInterceptors) {
			if (newInterceptors) {
				for (let i$5 = newInterceptors.length - 1; i$5 >= 0; i$5--) if (typeof this[kInterceptors$5][i$5] !== "function") throw new InvalidArgumentError$19("interceptor must be an function");
			}
			this[kInterceptors$5] = newInterceptors;
		}
		close(callback) {
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.close((err, data$1) => {
					return err ? reject(err) : resolve(data$1);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				queueMicrotask(() => callback(new ClientDestroyedError$1(), null));
				return;
			}
			if (this[kClosed]) {
				if (this[kOnClosed]) this[kOnClosed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			this[kClosed] = true;
			this[kOnClosed].push(callback);
			const onClosed = () => {
				const callbacks = this[kOnClosed];
				this[kOnClosed] = null;
				for (let i$5 = 0; i$5 < callbacks.length; i$5++) callbacks[i$5](null, null);
			};
			this[kClose$6]().then(() => this.destroy()).then(() => {
				queueMicrotask(onClosed);
			});
		}
		destroy(err, callback) {
			if (typeof err === "function") {
				callback = err;
				err = null;
			}
			if (callback === void 0) return new Promise((resolve, reject) => {
				this.destroy(err, (err$1, data$1) => {
					return err$1 ? reject(err$1) : resolve(data$1);
				});
			});
			if (typeof callback !== "function") throw new InvalidArgumentError$19("invalid callback");
			if (this[kDestroyed]) {
				if (this[kOnDestroyed]) this[kOnDestroyed].push(callback);
				else queueMicrotask(() => callback(null, null));
				return;
			}
			if (!err) err = new ClientDestroyedError$1();
			this[kDestroyed] = true;
			this[kOnDestroyed] = this[kOnDestroyed] || [];
			this[kOnDestroyed].push(callback);
			const onDestroyed = () => {
				const callbacks = this[kOnDestroyed];
				this[kOnDestroyed] = null;
				for (let i$5 = 0; i$5 < callbacks.length; i$5++) callbacks[i$5](null, null);
			};
			this[kDestroy$4](err).then(() => {
				queueMicrotask(onDestroyed);
			});
		}
		[kInterceptedDispatch](opts, handler) {
			if (!this[kInterceptors$5] || this[kInterceptors$5].length === 0) {
				this[kInterceptedDispatch] = this[kDispatch$3];
				return this[kDispatch$3](opts, handler);
			}
			let dispatch = this[kDispatch$3].bind(this);
			for (let i$5 = this[kInterceptors$5].length - 1; i$5 >= 0; i$5--) dispatch = this[kInterceptors$5][i$5](dispatch);
			this[kInterceptedDispatch] = dispatch;
			return dispatch(opts, handler);
		}
		dispatch(opts, handler) {
			if (!handler || typeof handler !== "object") throw new InvalidArgumentError$19("handler must be an object");
			try {
				if (!opts || typeof opts !== "object") throw new InvalidArgumentError$19("opts must be an object.");
				if (this[kDestroyed] || this[kOnDestroyed]) throw new ClientDestroyedError$1();
				if (this[kClosed]) throw new ClientClosedError();
				return this[kInterceptedDispatch](opts, handler);
			} catch (err) {
				if (typeof handler.onError !== "function") throw new InvalidArgumentError$19("invalid onError method");
				handler.onError(err);
				return false;
			}
		}
	};
	module.exports = DispatcherBase$4;
}));

//#endregion
//#region node_modules/undici/lib/core/connect.js
var require_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const net$1 = __require("net");
	const assert$14 = __require("assert");
	const util$15 = require_util$6();
	const { InvalidArgumentError: InvalidArgumentError$18, ConnectTimeoutError } = require_errors();
	let tls;
	let SessionCache;
	if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) SessionCache = class WeakSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
			this._sessionRegistry = new global.FinalizationRegistry((key) => {
				if (this._sessionCache.size < this._maxCachedSessions) return;
				const ref = this._sessionCache.get(key);
				if (ref !== void 0 && ref.deref() === void 0) this._sessionCache.delete(key);
			});
		}
		get(sessionKey) {
			const ref = this._sessionCache.get(sessionKey);
			return ref ? ref.deref() : null;
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			this._sessionCache.set(sessionKey, new WeakRef(session));
			this._sessionRegistry.register(session, sessionKey);
		}
	};
	else SessionCache = class SimpleSessionCache {
		constructor(maxCachedSessions) {
			this._maxCachedSessions = maxCachedSessions;
			this._sessionCache = /* @__PURE__ */ new Map();
		}
		get(sessionKey) {
			return this._sessionCache.get(sessionKey);
		}
		set(sessionKey, session) {
			if (this._maxCachedSessions === 0) return;
			if (this._sessionCache.size >= this._maxCachedSessions) {
				const { value: oldestKey } = this._sessionCache.keys().next();
				this._sessionCache.delete(oldestKey);
			}
			this._sessionCache.set(sessionKey, session);
		}
	};
	function buildConnector$4({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
		if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) throw new InvalidArgumentError$18("maxCachedSessions must be a positive integer or zero");
		const options = {
			path: socketPath,
			...opts
		};
		const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
		timeout = timeout == null ? 1e4 : timeout;
		allowH2 = allowH2 != null ? allowH2 : false;
		return function connect$2({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
			let socket;
			if (protocol === "https:") {
				if (!tls) tls = __require("tls");
				servername = servername || options.servername || util$15.getServerName(host) || null;
				const sessionKey = servername || hostname;
				const session = sessionCache.get(sessionKey) || null;
				assert$14(sessionKey);
				socket = tls.connect({
					highWaterMark: 16384,
					...options,
					servername,
					session,
					localAddress,
					ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
					socket: httpSocket,
					port: port || 443,
					host: hostname
				});
				socket.on("session", function(session$1) {
					sessionCache.set(sessionKey, session$1);
				});
			} else {
				assert$14(!httpSocket, "httpSocket can only be sent on TLS update");
				socket = net$1.connect({
					highWaterMark: 64 * 1024,
					...options,
					localAddress,
					port: port || 80,
					host: hostname
				});
			}
			if (options.keepAlive == null || options.keepAlive) {
				const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
				socket.setKeepAlive(true, keepAliveInitialDelay);
			}
			const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
			socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			}).on("error", function(err) {
				cancelTimeout();
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
			return socket;
		};
	}
	function setupTimeout(onConnectTimeout$1, timeout) {
		if (!timeout) return () => {};
		let s1 = null;
		let s2 = null;
		const timeoutId = setTimeout(() => {
			s1 = setImmediate(() => {
				if (process.platform === "win32") s2 = setImmediate(() => onConnectTimeout$1());
				else onConnectTimeout$1();
			});
		}, timeout);
		return () => {
			clearTimeout(timeoutId);
			clearImmediate(s1);
			clearImmediate(s2);
		};
	}
	function onConnectTimeout(socket) {
		util$15.destroy(socket, new ConnectTimeoutError());
	}
	module.exports = buildConnector$4;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/utils.js
var require_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.enumToMap = void 0;
	function enumToMap(obj) {
		const res = {};
		Object.keys(obj).forEach((key) => {
			const value = obj[key];
			if (typeof value === "number") res[key] = value;
		});
		return res;
	}
	exports.enumToMap = enumToMap;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/constants.js
var require_constants$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
	const utils_1$1 = require_utils();
	(function(ERROR) {
		ERROR[ERROR["OK"] = 0] = "OK";
		ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
		ERROR[ERROR["STRICT"] = 2] = "STRICT";
		ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
		ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
		ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
		ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
		ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
		ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
		ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
		ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
		ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
		ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
		ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
		ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
		ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
		ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
		ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
		ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
		ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
		ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
		ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
		ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
		ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
		ERROR[ERROR["USER"] = 24] = "USER";
	})(exports.ERROR || (exports.ERROR = {}));
	(function(TYPE) {
		TYPE[TYPE["BOTH"] = 0] = "BOTH";
		TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
		TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
	})(exports.TYPE || (exports.TYPE = {}));
	(function(FLAGS) {
		FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
		FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
		FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
		FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
		FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
		FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
		FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
		FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
		FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
	})(exports.FLAGS || (exports.FLAGS = {}));
	(function(LENIENT_FLAGS) {
		LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
		LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
		LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
	})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function(METHODS$1) {
		METHODS$1[METHODS$1["DELETE"] = 0] = "DELETE";
		METHODS$1[METHODS$1["GET"] = 1] = "GET";
		METHODS$1[METHODS$1["HEAD"] = 2] = "HEAD";
		METHODS$1[METHODS$1["POST"] = 3] = "POST";
		METHODS$1[METHODS$1["PUT"] = 4] = "PUT";
		METHODS$1[METHODS$1["CONNECT"] = 5] = "CONNECT";
		METHODS$1[METHODS$1["OPTIONS"] = 6] = "OPTIONS";
		METHODS$1[METHODS$1["TRACE"] = 7] = "TRACE";
		METHODS$1[METHODS$1["COPY"] = 8] = "COPY";
		METHODS$1[METHODS$1["LOCK"] = 9] = "LOCK";
		METHODS$1[METHODS$1["MKCOL"] = 10] = "MKCOL";
		METHODS$1[METHODS$1["MOVE"] = 11] = "MOVE";
		METHODS$1[METHODS$1["PROPFIND"] = 12] = "PROPFIND";
		METHODS$1[METHODS$1["PROPPATCH"] = 13] = "PROPPATCH";
		METHODS$1[METHODS$1["SEARCH"] = 14] = "SEARCH";
		METHODS$1[METHODS$1["UNLOCK"] = 15] = "UNLOCK";
		METHODS$1[METHODS$1["BIND"] = 16] = "BIND";
		METHODS$1[METHODS$1["REBIND"] = 17] = "REBIND";
		METHODS$1[METHODS$1["UNBIND"] = 18] = "UNBIND";
		METHODS$1[METHODS$1["ACL"] = 19] = "ACL";
		METHODS$1[METHODS$1["REPORT"] = 20] = "REPORT";
		METHODS$1[METHODS$1["MKACTIVITY"] = 21] = "MKACTIVITY";
		METHODS$1[METHODS$1["CHECKOUT"] = 22] = "CHECKOUT";
		METHODS$1[METHODS$1["MERGE"] = 23] = "MERGE";
		METHODS$1[METHODS$1["M-SEARCH"] = 24] = "M-SEARCH";
		METHODS$1[METHODS$1["NOTIFY"] = 25] = "NOTIFY";
		METHODS$1[METHODS$1["SUBSCRIBE"] = 26] = "SUBSCRIBE";
		METHODS$1[METHODS$1["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
		METHODS$1[METHODS$1["PATCH"] = 28] = "PATCH";
		METHODS$1[METHODS$1["PURGE"] = 29] = "PURGE";
		METHODS$1[METHODS$1["MKCALENDAR"] = 30] = "MKCALENDAR";
		METHODS$1[METHODS$1["LINK"] = 31] = "LINK";
		METHODS$1[METHODS$1["UNLINK"] = 32] = "UNLINK";
		METHODS$1[METHODS$1["SOURCE"] = 33] = "SOURCE";
		METHODS$1[METHODS$1["PRI"] = 34] = "PRI";
		METHODS$1[METHODS$1["DESCRIBE"] = 35] = "DESCRIBE";
		METHODS$1[METHODS$1["ANNOUNCE"] = 36] = "ANNOUNCE";
		METHODS$1[METHODS$1["SETUP"] = 37] = "SETUP";
		METHODS$1[METHODS$1["PLAY"] = 38] = "PLAY";
		METHODS$1[METHODS$1["PAUSE"] = 39] = "PAUSE";
		METHODS$1[METHODS$1["TEARDOWN"] = 40] = "TEARDOWN";
		METHODS$1[METHODS$1["GET_PARAMETER"] = 41] = "GET_PARAMETER";
		METHODS$1[METHODS$1["SET_PARAMETER"] = 42] = "SET_PARAMETER";
		METHODS$1[METHODS$1["REDIRECT"] = 43] = "REDIRECT";
		METHODS$1[METHODS$1["RECORD"] = 44] = "RECORD";
		METHODS$1[METHODS$1["FLUSH"] = 45] = "FLUSH";
	})(METHODS = exports.METHODS || (exports.METHODS = {}));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS["M-SEARCH"],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1$1.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key) => {
		if (/^H/.test(key)) exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
	});
	(function(FINISH) {
		FINISH[FINISH["SAFE"] = 0] = "SAFE";
		FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
		FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
	})(exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i$5 = "A".charCodeAt(0); i$5 <= "Z".charCodeAt(0); i$5++) {
		exports.ALPHA.push(String.fromCharCode(i$5));
		exports.ALPHA.push(String.fromCharCode(i$5 + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = [
		"0",
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9"
	];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = [
		"-",
		"_",
		".",
		"!",
		"~",
		"*",
		"'",
		"(",
		")"
	];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		"%",
		";",
		":",
		"&",
		"=",
		"+",
		"$",
		","
	]);
	exports.STRICT_URL_CHAR = [
		"!",
		"\"",
		"$",
		"%",
		"&",
		"'",
		"(",
		")",
		"*",
		"+",
		",",
		"-",
		".",
		"/",
		":",
		";",
		"<",
		"=",
		">",
		"@",
		"[",
		"\\",
		"]",
		"^",
		"_",
		"`",
		"{",
		"|",
		"}",
		"~"
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
	for (let i$5 = 128; i$5 <= 255; i$5++) exports.URL_CHAR.push(i$5);
	exports.HEX = exports.NUM.concat([
		"a",
		"b",
		"c",
		"d",
		"e",
		"f",
		"A",
		"B",
		"C",
		"D",
		"E",
		"F"
	]);
	exports.STRICT_TOKEN = [
		"!",
		"#",
		"$",
		"%",
		"&",
		"'",
		"*",
		"+",
		"-",
		".",
		"^",
		"_",
		"`",
		"|",
		"~"
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
	exports.HEADER_CHARS = ["	"];
	for (let i$5 = 32; i$5 <= 255; i$5++) if (i$5 !== 127) exports.HEADER_CHARS.push(i$5);
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c$5) => c$5 !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function(HEADER_STATE$1) {
		HEADER_STATE$1[HEADER_STATE$1["GENERAL"] = 0] = "GENERAL";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION"] = 1] = "CONNECTION";
		HEADER_STATE$1[HEADER_STATE$1["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
		HEADER_STATE$1[HEADER_STATE$1["UPGRADE"] = 4] = "UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
		HEADER_STATE$1[HEADER_STATE$1["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
		HEADER_STATE$1[HEADER_STATE$1["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
	})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
	exports.SPECIAL_HEADERS = {
		"connection": HEADER_STATE.CONNECTION,
		"content-length": HEADER_STATE.CONTENT_LENGTH,
		"proxy-connection": HEADER_STATE.CONNECTION,
		"transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
		"upgrade": HEADER_STATE.UPGRADE
	};
}));

//#endregion
//#region node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const util$14 = require_util$6();
	const { kBodyUsed } = require_symbols$4();
	const assert$13 = __require("assert");
	const { InvalidArgumentError: InvalidArgumentError$17 } = require_errors();
	const EE$1 = __require("events");
	const redirectableStatusCodes = [
		300,
		301,
		302,
		303,
		307,
		308
	];
	const kBody$1 = Symbol("body");
	var BodyAsyncIterable = class {
		constructor(body) {
			this[kBody$1] = body;
			this[kBodyUsed] = false;
		}
		async *[Symbol.asyncIterator]() {
			assert$13(!this[kBodyUsed], "disturbed");
			this[kBodyUsed] = true;
			yield* this[kBody$1];
		}
	};
	var RedirectHandler$2 = class {
		constructor(dispatch, maxRedirections, opts, handler) {
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$17("maxRedirections must be a positive number");
			util$14.validateHandler(handler, opts.method, opts.upgrade);
			this.dispatch = dispatch;
			this.location = null;
			this.abort = null;
			this.opts = {
				...opts,
				maxRedirections: 0
			};
			this.maxRedirections = maxRedirections;
			this.handler = handler;
			this.history = [];
			if (util$14.isStream(this.opts.body)) {
				if (util$14.bodyLength(this.opts.body) === 0) this.opts.body.on("data", function() {
					assert$13(false);
				});
				if (typeof this.opts.body.readableDidRead !== "boolean") {
					this.opts.body[kBodyUsed] = false;
					EE$1.prototype.on.call(this.opts.body, "data", function() {
						this[kBodyUsed] = true;
					});
				}
			} else if (this.opts.body && typeof this.opts.body.pipeTo === "function") this.opts.body = new BodyAsyncIterable(this.opts.body);
			else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util$14.isIterable(this.opts.body)) this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
		onConnect(abort$1) {
			this.abort = abort$1;
			this.handler.onConnect(abort$1, { history: this.history });
		}
		onUpgrade(statusCode, headers, socket) {
			this.handler.onUpgrade(statusCode, headers, socket);
		}
		onError(error$2) {
			this.handler.onError(error$2);
		}
		onHeaders(statusCode, headers, resume$1, statusText) {
			this.location = this.history.length >= this.maxRedirections || util$14.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
			if (this.opts.origin) this.history.push(new URL(this.opts.path, this.opts.origin));
			if (!this.location) return this.handler.onHeaders(statusCode, headers, resume$1, statusText);
			const { origin, pathname, search } = util$14.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
			const path$6 = search ? `${pathname}${search}` : pathname;
			this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
			this.opts.path = path$6;
			this.opts.origin = origin;
			this.opts.maxRedirections = 0;
			this.opts.query = null;
			if (statusCode === 303 && this.opts.method !== "HEAD") {
				this.opts.method = "GET";
				this.opts.body = null;
			}
		}
		onData(chunk) {
			if (this.location) {} else return this.handler.onData(chunk);
		}
		onComplete(trailers) {
			if (this.location) {
				this.location = null;
				this.abort = null;
				this.dispatch(this.opts, this);
			} else this.handler.onComplete(trailers);
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) this.handler.onBodySent(chunk);
		}
	};
	function parseLocation(statusCode, headers) {
		if (redirectableStatusCodes.indexOf(statusCode) === -1) return null;
		for (let i$5 = 0; i$5 < headers.length; i$5 += 2) if (headers[i$5].toString().toLowerCase() === "location") return headers[i$5 + 1];
	}
	function shouldRemoveHeader(header, removeContent, unknownOrigin) {
		if (header.length === 4) return util$14.headerNameToString(header) === "host";
		if (removeContent && util$14.headerNameToString(header).startsWith("content-")) return true;
		if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
			const name = util$14.headerNameToString(header);
			return name === "authorization" || name === "cookie" || name === "proxy-authorization";
		}
		return false;
	}
	function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
		const ret = [];
		if (Array.isArray(headers)) {
			for (let i$5 = 0; i$5 < headers.length; i$5 += 2) if (!shouldRemoveHeader(headers[i$5], removeContent, unknownOrigin)) ret.push(headers[i$5], headers[i$5 + 1]);
		} else if (headers && typeof headers === "object") {
			for (const key of Object.keys(headers)) if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) ret.push(key, headers[key]);
		} else assert$13(headers == null, "headers must be an object or an array");
		return ret;
	}
	module.exports = RedirectHandler$2;
}));

//#endregion
//#region node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const RedirectHandler$1 = require_RedirectHandler();
	function createRedirectInterceptor$3({ maxRedirections: defaultMaxRedirections }) {
		return (dispatch) => {
			return function Intercept(opts, handler) {
				const { maxRedirections = defaultMaxRedirections } = opts;
				if (!maxRedirections) return dispatch(opts, handler);
				const redirectHandler = new RedirectHandler$1(dispatch, maxRedirections, opts, handler);
				opts = {
					...opts,
					maxRedirections: 0
				};
				return dispatch(opts, redirectHandler);
			};
		};
	}
	module.exports = createRedirectInterceptor$3;
}));

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
}));

//#endregion
//#region node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcsBygG4AckBuQHIAboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBANwBC0EAIRAMxgELQQ4hEAzFAQtBDSEQDMQBC0EPIRAMwwELQRAhEAzCAQtBEyEQDMEBC0EUIRAMwAELQRUhEAy/AQtBFiEQDL4BC0EXIRAMvQELQRghEAy8AQtBGSEQDLsBC0EaIRAMugELQRshEAy5AQtBHCEQDLgBC0EIIRAMtwELQR0hEAy2AQtBICEQDLUBC0EfIRAMtAELQQchEAyzAQtBISEQDLIBC0EiIRAMsQELQR4hEAywAQtBIyEQDK8BC0ESIRAMrgELQREhEAytAQtBJCEQDKwBC0ElIRAMqwELQSYhEAyqAQtBJyEQDKkBC0HDASEQDKgBC0EpIRAMpwELQSshEAymAQtBLCEQDKUBC0EtIRAMpAELQS4hEAyjAQtBLyEQDKIBC0HEASEQDKEBC0EwIRAMoAELQTQhEAyfAQtBDCEQDJ4BC0ExIRAMnQELQTIhEAycAQtBMyEQDJsBC0E5IRAMmgELQTUhEAyZAQtBxQEhEAyYAQtBCyEQDJcBC0E6IRAMlgELQTYhEAyVAQtBCiEQDJQBC0E3IRAMkwELQTghEAySAQtBPCEQDJEBC0E7IRAMkAELQT0hEAyPAQtBCSEQDI4BC0EoIRAMjQELQT4hEAyMAQtBPyEQDIsBC0HAACEQDIoBC0HBACEQDIkBC0HCACEQDIgBC0HDACEQDIcBC0HEACEQDIYBC0HFACEQDIUBC0HGACEQDIQBC0EqIRAMgwELQccAIRAMggELQcgAIRAMgQELQckAIRAMgAELQcoAIRAMfwtBywAhEAx+C0HNACEQDH0LQcwAIRAMfAtBzgAhEAx7C0HPACEQDHoLQdAAIRAMeQtB0QAhEAx4C0HSACEQDHcLQdMAIRAMdgtB1AAhEAx1C0HWACEQDHQLQdUAIRAMcwtBBiEQDHILQdcAIRAMcQtBBSEQDHALQdgAIRAMbwtBBCEQDG4LQdkAIRAMbQtB2gAhEAxsC0HbACEQDGsLQdwAIRAMagtBAyEQDGkLQd0AIRAMaAtB3gAhEAxnC0HfACEQDGYLQeEAIRAMZQtB4AAhEAxkC0HiACEQDGMLQeMAIRAMYgtBAiEQDGELQeQAIRAMYAtB5QAhEAxfC0HmACEQDF4LQecAIRAMXQtB6AAhEAxcC0HpACEQDFsLQeoAIRAMWgtB6wAhEAxZC0HsACEQDFgLQe0AIRAMVwtB7gAhEAxWC0HvACEQDFULQfAAIRAMVAtB8QAhEAxTC0HyACEQDFILQfMAIRAMUQtB9AAhEAxQC0H1ACEQDE8LQfYAIRAMTgtB9wAhEAxNC0H4ACEQDEwLQfkAIRAMSwtB+gAhEAxKC0H7ACEQDEkLQfwAIRAMSAtB/QAhEAxHC0H+ACEQDEYLQf8AIRAMRQtBgAEhEAxEC0GBASEQDEMLQYIBIRAMQgtBgwEhEAxBC0GEASEQDEALQYUBIRAMPwtBhgEhEAw+C0GHASEQDD0LQYgBIRAMPAtBiQEhEAw7C0GKASEQDDoLQYsBIRAMOQtBjAEhEAw4C0GNASEQDDcLQY4BIRAMNgtBjwEhEAw1C0GQASEQDDQLQZEBIRAMMwtBkgEhEAwyC0GTASEQDDELQZQBIRAMMAtBlQEhEAwvC0GWASEQDC4LQZcBIRAMLQtBmAEhEAwsC0GZASEQDCsLQZoBIRAMKgtBmwEhEAwpC0GcASEQDCgLQZ0BIRAMJwtBngEhEAwmC0GfASEQDCULQaABIRAMJAtBoQEhEAwjC0GiASEQDCILQaMBIRAMIQtBpAEhEAwgC0GlASEQDB8LQaYBIRAMHgtBpwEhEAwdC0GoASEQDBwLQakBIRAMGwtBqgEhEAwaC0GrASEQDBkLQawBIRAMGAtBrQEhEAwXC0GuASEQDBYLQQEhEAwVC0GvASEQDBQLQbABIRAMEwtBsQEhEAwSC0GzASEQDBELQbIBIRAMEAtBtAEhEAwPC0G1ASEQDA4LQbYBIRAMDQtBtwEhEAwMC0G4ASEQDAsLQbkBIRAMCgtBugEhEAwJC0G7ASEQDAgLQcYBIRAMBwtBvAEhEAwGC0G9ASEQDAULQb4BIRAMBAtBvwEhEAwDC0HAASEQDAILQcIBIRAMAQtBwQEhEAsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
}));

//#endregion
//#region node_modules/undici/lib/client.js
var require_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$12 = __require("assert");
	const net = __require("net");
	const http$3 = __require("http");
	const { pipeline: pipeline$2 } = __require("stream");
	const util$13 = require_util$6();
	const timers = require_timers();
	const Request$4 = require_request$1();
	const DispatcherBase$3 = require_dispatcher_base();
	const { RequestContentLengthMismatchError, ResponseContentLengthMismatchError, InvalidArgumentError: InvalidArgumentError$16, RequestAbortedError: RequestAbortedError$8, HeadersTimeoutError, HeadersOverflowError, SocketError: SocketError$2, InformationalError, BodyTimeoutError, HTTPParserError, ResponseExceededMaxSizeError, ClientDestroyedError } = require_errors();
	const buildConnector$3 = require_connect();
	const { kUrl: kUrl$3, kReset, kServerName, kClient: kClient$1, kBusy: kBusy$1, kParser, kConnect, kBlocking, kResuming, kRunning: kRunning$3, kPending: kPending$2, kSize: kSize$4, kWriting, kQueue: kQueue$1, kConnected: kConnected$5, kConnecting, kNeedDrain: kNeedDrain$3, kNoRef, kKeepAliveDefaultTimeout, kHostHeader, kPendingIdx, kRunningIdx, kError: kError$2, kPipelining, kSocket, kKeepAliveTimeoutValue, kMaxHeadersSize, kKeepAliveMaxTimeout, kKeepAliveTimeoutThreshold, kHeadersTimeout, kBodyTimeout, kStrictContentLength, kConnector, kMaxRedirections: kMaxRedirections$1, kMaxRequests, kCounter, kClose: kClose$5, kDestroy: kDestroy$3, kDispatch: kDispatch$2, kInterceptors: kInterceptors$4, kLocalAddress, kMaxResponseSize, kHTTPConnVersion, kHost, kHTTP2Session, kHTTP2SessionState, kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols$4();
	/** @type {import('http2')} */
	let http2$1;
	try {
		http2$1 = __require("http2");
	} catch {
		http2$1 = { constants: {} };
	}
	const { constants: { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_SCHEME, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_EXPECT, HTTP2_HEADER_STATUS } } = http2$1;
	let h2ExperimentalWarned = false;
	const FastBuffer = Buffer[Symbol.species];
	const kClosedResolve$1 = Symbol("kClosedResolve");
	const channels$2 = {};
	try {
		const diagnosticsChannel$2 = __require("diagnostics_channel");
		channels$2.sendHeaders = diagnosticsChannel$2.channel("undici:client:sendHeaders");
		channels$2.beforeConnect = diagnosticsChannel$2.channel("undici:client:beforeConnect");
		channels$2.connectError = diagnosticsChannel$2.channel("undici:client:connectError");
		channels$2.connected = diagnosticsChannel$2.channel("undici:client:connected");
	} catch {
		channels$2.sendHeaders = { hasSubscribers: false };
		channels$2.beforeConnect = { hasSubscribers: false };
		channels$2.connectError = { hasSubscribers: false };
		channels$2.connected = { hasSubscribers: false };
	}
	/**
	* @type {import('../types/client').default}
	*/
	var Client$5 = class extends DispatcherBase$3 {
		/**
		*
		* @param {string|URL} url
		* @param {import('../types/client').Client.Options} options
		*/
		constructor(url$1, { interceptors, maxHeaderSize, headersTimeout, socketTimeout, requestTimeout: requestTimeout$1, connectTimeout, bodyTimeout, idleTimeout, keepAlive, keepAliveTimeout, maxKeepAliveTimeout, keepAliveMaxTimeout, keepAliveTimeoutThreshold, socketPath, pipelining, tls: tls$2, strictContentLength, maxCachedSessions, maxRedirections, connect: connect$2, maxRequestsPerClient, localAddress, maxResponseSize, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, maxConcurrentStreams } = {}) {
			super();
			if (keepAlive !== void 0) throw new InvalidArgumentError$16("unsupported keepAlive, use pipelining=0 instead");
			if (socketTimeout !== void 0) throw new InvalidArgumentError$16("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
			if (requestTimeout$1 !== void 0) throw new InvalidArgumentError$16("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
			if (idleTimeout !== void 0) throw new InvalidArgumentError$16("unsupported idleTimeout, use keepAliveTimeout instead");
			if (maxKeepAliveTimeout !== void 0) throw new InvalidArgumentError$16("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
			if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) throw new InvalidArgumentError$16("invalid maxHeaderSize");
			if (socketPath != null && typeof socketPath !== "string") throw new InvalidArgumentError$16("invalid socketPath");
			if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) throw new InvalidArgumentError$16("invalid connectTimeout");
			if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveTimeout");
			if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) throw new InvalidArgumentError$16("invalid keepAliveMaxTimeout");
			if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) throw new InvalidArgumentError$16("invalid keepAliveTimeoutThreshold");
			if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) throw new InvalidArgumentError$16("headersTimeout must be a positive integer or zero");
			if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) throw new InvalidArgumentError$16("bodyTimeout must be a positive integer or zero");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$16("connect must be a function or an object");
			if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) throw new InvalidArgumentError$16("maxRedirections must be a positive number");
			if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) throw new InvalidArgumentError$16("maxRequestsPerClient must be a positive number");
			if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) throw new InvalidArgumentError$16("localAddress must be valid string IP address");
			if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) throw new InvalidArgumentError$16("maxResponseSize must be a positive number");
			if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) throw new InvalidArgumentError$16("autoSelectFamilyAttemptTimeout must be a positive number");
			if (allowH2 != null && typeof allowH2 !== "boolean") throw new InvalidArgumentError$16("allowH2 must be a valid boolean value");
			if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) throw new InvalidArgumentError$16("maxConcurrentStreams must be a possitive integer, greater than 0");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$3({
				...tls$2,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$13.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$4] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor$2({ maxRedirections })];
			this[kUrl$3] = util$13.parseOrigin(url$1);
			this[kConnector] = connect$2;
			this[kSocket] = null;
			this[kPipelining] = pipelining != null ? pipelining : 1;
			this[kMaxHeadersSize] = maxHeaderSize || http$3.maxHeaderSize;
			this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
			this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
			this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
			this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
			this[kServerName] = null;
			this[kLocalAddress] = localAddress != null ? localAddress : null;
			this[kResuming] = 0;
			this[kNeedDrain$3] = 0;
			this[kHostHeader] = `host: ${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}\r\n`;
			this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
			this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
			this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
			this[kMaxRedirections$1] = maxRedirections;
			this[kMaxRequests] = maxRequestsPerClient;
			this[kClosedResolve$1] = null;
			this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
			this[kHTTPConnVersion] = "h1";
			this[kHTTP2Session] = null;
			this[kHTTP2SessionState] = !allowH2 ? null : {
				openStreams: 0,
				maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
			};
			this[kHost] = `${this[kUrl$3].hostname}${this[kUrl$3].port ? `:${this[kUrl$3].port}` : ""}`;
			this[kQueue$1] = [];
			this[kRunningIdx] = 0;
			this[kPendingIdx] = 0;
		}
		get pipelining() {
			return this[kPipelining];
		}
		set pipelining(value) {
			this[kPipelining] = value;
			resume(this, true);
		}
		get [kPending$2]() {
			return this[kQueue$1].length - this[kPendingIdx];
		}
		get [kRunning$3]() {
			return this[kPendingIdx] - this[kRunningIdx];
		}
		get [kSize$4]() {
			return this[kQueue$1].length - this[kRunningIdx];
		}
		get [kConnected$5]() {
			return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
		}
		get [kBusy$1]() {
			const socket = this[kSocket];
			return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize$4] >= (this[kPipelining] || 1) || this[kPending$2] > 0;
		}
		/* istanbul ignore: only used for test */
		[kConnect](cb) {
			connect$1(this);
			this.once("connect", cb);
		}
		[kDispatch$2](opts, handler) {
			const origin = opts.origin || this[kUrl$3].origin;
			const request$1 = this[kHTTPConnVersion] === "h2" ? Request$4[kHTTP2BuildRequest](origin, opts, handler) : Request$4[kHTTP1BuildRequest](origin, opts, handler);
			this[kQueue$1].push(request$1);
			if (this[kResuming]) {} else if (util$13.bodyLength(request$1.body) == null && util$13.isIterable(request$1.body)) {
				this[kResuming] = 1;
				process.nextTick(resume, this);
			} else resume(this, true);
			if (this[kResuming] && this[kNeedDrain$3] !== 2 && this[kBusy$1]) this[kNeedDrain$3] = 2;
			return this[kNeedDrain$3] < 2;
		}
		async [kClose$5]() {
			return new Promise((resolve) => {
				if (!this[kSize$4]) resolve(null);
				else this[kClosedResolve$1] = resolve;
			});
		}
		async [kDestroy$3](err) {
			return new Promise((resolve) => {
				const requests = this[kQueue$1].splice(this[kPendingIdx]);
				for (let i$5 = 0; i$5 < requests.length; i$5++) {
					const request$1 = requests[i$5];
					errorRequest(this, request$1, err);
				}
				const callback = () => {
					if (this[kClosedResolve$1]) {
						this[kClosedResolve$1]();
						this[kClosedResolve$1] = null;
					}
					resolve();
				};
				if (this[kHTTP2Session] != null) {
					util$13.destroy(this[kHTTP2Session], err);
					this[kHTTP2Session] = null;
					this[kHTTP2SessionState] = null;
				}
				if (!this[kSocket]) queueMicrotask(callback);
				else util$13.destroy(this[kSocket].on("close", callback), err);
				resume(this);
			});
		}
	};
	function onHttp2SessionError(err) {
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		this[kSocket][kError$2] = err;
		onError(this[kClient$1], err);
	}
	function onHttp2FrameError(type, code, id) {
		const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
		if (id === 0) {
			this[kSocket][kError$2] = err;
			onError(this[kClient$1], err);
		}
	}
	function onHttp2SessionEnd() {
		util$13.destroy(this, new SocketError$2("other side closed"));
		util$13.destroy(this[kSocket], new SocketError$2("other side closed"));
	}
	function onHTTP2GoAway(code) {
		const client$6 = this[kClient$1];
		const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
		client$6[kSocket] = null;
		client$6[kHTTP2Session] = null;
		if (client$6.destroyed) {
			assert$12(this[kPending$2] === 0);
			const requests = client$6[kQueue$1].splice(client$6[kRunningIdx]);
			for (let i$5 = 0; i$5 < requests.length; i$5++) {
				const request$1 = requests[i$5];
				errorRequest(this, request$1, err);
			}
		} else if (client$6[kRunning$3] > 0) {
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			client$6[kQueue$1][client$6[kRunningIdx]++] = null;
			errorRequest(client$6, request$1, err);
		}
		client$6[kPendingIdx] = client$6[kRunningIdx];
		assert$12(client$6[kRunning$3] === 0);
		client$6.emit("disconnect", client$6[kUrl$3], [client$6], err);
		resume(client$6);
	}
	const constants = require_constants$2();
	const createRedirectInterceptor$2 = require_redirectInterceptor();
	const EMPTY_BUF = Buffer.alloc(0);
	async function lazyllhttp() {
		const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
		let mod;
		try {
			mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
		} catch (e$5) {
			/* istanbul ignore next */
			mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
		}
		return await WebAssembly.instantiate(mod, { env: {
			wasm_on_url: (p$5, at, len) => {
				/* istanbul ignore next */
				return 0;
			},
			wasm_on_status: (p$5, at, len) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_message_begin: (p$5) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p$5, at, len) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_header_value: (p$5, at, len) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_headers_complete: (p$5, statusCode, upgrade$1, shouldKeepAlive) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				return currentParser.onHeadersComplete(statusCode, Boolean(upgrade$1), Boolean(shouldKeepAlive)) || 0;
			},
			wasm_on_body: (p$5, at, len) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				const start = at - currentBufferPtr + currentBufferRef.byteOffset;
				return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
			},
			wasm_on_message_complete: (p$5) => {
				assert$12.strictEqual(currentParser.ptr, p$5);
				return currentParser.onMessageComplete() || 0;
			}
		} });
	}
	let llhttpInstance = null;
	let llhttpPromise = lazyllhttp();
	llhttpPromise.catch();
	let currentParser = null;
	let currentBufferRef = null;
	let currentBufferSize = 0;
	let currentBufferPtr = null;
	const TIMEOUT_HEADERS = 1;
	const TIMEOUT_BODY = 2;
	const TIMEOUT_IDLE = 3;
	var Parser = class {
		constructor(client$6, socket, { exports: exports$1 }) {
			assert$12(Number.isFinite(client$6[kMaxHeadersSize]) && client$6[kMaxHeadersSize] > 0);
			this.llhttp = exports$1;
			this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
			this.client = client$6;
			this.socket = socket;
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.statusCode = null;
			this.statusText = "";
			this.upgrade = false;
			this.headers = [];
			this.headersSize = 0;
			this.headersMaxSize = client$6[kMaxHeadersSize];
			this.shouldKeepAlive = false;
			this.paused = false;
			this.resume = this.resume.bind(this);
			this.bytesRead = 0;
			this.keepAlive = "";
			this.contentLength = "";
			this.connection = "";
			this.maxResponseSize = client$6[kMaxResponseSize];
		}
		setTimeout(value, type) {
			this.timeoutType = type;
			if (value !== this.timeoutValue) {
				timers.clearTimeout(this.timeout);
				if (value) {
					this.timeout = timers.setTimeout(onParserTimeout, value, this);
					// istanbul ignore else: only for jest
					if (this.timeout.unref) this.timeout.unref();
				} else this.timeout = null;
				this.timeoutValue = value;
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
		}
		resume() {
			if (this.socket.destroyed || !this.paused) return;
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_resume(this.ptr);
			assert$12(this.timeoutType === TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			this.paused = false;
			this.execute(this.socket.read() || EMPTY_BUF);
			this.readMore();
		}
		readMore() {
			while (!this.paused && this.ptr) {
				const chunk = this.socket.read();
				if (chunk === null) break;
				this.execute(chunk);
			}
		}
		execute(data$1) {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			assert$12(!this.paused);
			const { socket, llhttp } = this;
			if (data$1.length > currentBufferSize) {
				if (currentBufferPtr) llhttp.free(currentBufferPtr);
				currentBufferSize = Math.ceil(data$1.length / 4096) * 4096;
				currentBufferPtr = llhttp.malloc(currentBufferSize);
			}
			new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data$1);
			try {
				let ret;
				try {
					currentBufferRef = data$1;
					currentParser = this;
					ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data$1.length);
				} catch (err) {
					/* istanbul ignore next: difficult to make a test case for */
					throw err;
				} finally {
					currentParser = null;
					currentBufferRef = null;
				}
				const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
				if (ret === constants.ERROR.PAUSED_UPGRADE) this.onUpgrade(data$1.slice(offset));
				else if (ret === constants.ERROR.PAUSED) {
					this.paused = true;
					socket.unshift(data$1.slice(offset));
				} else if (ret !== constants.ERROR.OK) {
					const ptr = llhttp.llhttp_get_error_reason(this.ptr);
					let message = "";
					/* istanbul ignore else: difficult to make a test case for */
					if (ptr) {
						const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
						message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
					}
					throw new HTTPParserError(message, constants.ERROR[ret], data$1.slice(offset));
				}
			} catch (err) {
				util$13.destroy(socket, err);
			}
		}
		destroy() {
			assert$12(this.ptr != null);
			assert$12(currentParser == null);
			this.llhttp.llhttp_free(this.ptr);
			this.ptr = null;
			timers.clearTimeout(this.timeout);
			this.timeout = null;
			this.timeoutValue = null;
			this.timeoutType = null;
			this.paused = false;
		}
		onStatus(buf) {
			this.statusText = buf.toString();
		}
		onMessageBegin() {
			const { socket, client: client$6 } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			if (!client$6[kQueue$1][client$6[kRunningIdx]]) return -1;
		}
		onHeaderField(buf) {
			const len = this.headers.length;
			if ((len & 1) === 0) this.headers.push(buf);
			else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			this.trackHeader(buf.length);
		}
		onHeaderValue(buf) {
			let len = this.headers.length;
			if ((len & 1) === 1) {
				this.headers.push(buf);
				len += 1;
			} else this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
			const key = this.headers[len - 2];
			if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") this.keepAlive += buf.toString();
			else if (key.length === 10 && key.toString().toLowerCase() === "connection") this.connection += buf.toString();
			else if (key.length === 14 && key.toString().toLowerCase() === "content-length") this.contentLength += buf.toString();
			this.trackHeader(buf.length);
		}
		trackHeader(len) {
			this.headersSize += len;
			if (this.headersSize >= this.headersMaxSize) util$13.destroy(this.socket, new HeadersOverflowError());
		}
		onUpgrade(head) {
			const { upgrade: upgrade$1, client: client$6, socket, headers, statusCode } = this;
			assert$12(upgrade$1);
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			assert$12(request$1);
			assert$12(!socket.destroyed);
			assert$12(socket === client$6[kSocket]);
			assert$12(!this.paused);
			assert$12(request$1.upgrade || request$1.method === "CONNECT");
			this.statusCode = null;
			this.statusText = "";
			this.shouldKeepAlive = null;
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			socket.unshift(head);
			socket[kParser].destroy();
			socket[kParser] = null;
			socket[kClient$1] = null;
			socket[kError$2] = null;
			socket.removeListener("error", onSocketError$1).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose$1);
			client$6[kSocket] = null;
			client$6[kQueue$1][client$6[kRunningIdx]++] = null;
			client$6.emit("disconnect", client$6[kUrl$3], [client$6], new InformationalError("upgrade"));
			try {
				request$1.onUpgrade(statusCode, headers, socket);
			} catch (err) {
				util$13.destroy(socket, err);
			}
			resume(client$6);
		}
		onHeadersComplete(statusCode, upgrade$1, shouldKeepAlive) {
			const { client: client$6, socket, headers, statusText } = this;
			/* istanbul ignore next: difficult to make a test case for */
			if (socket.destroyed) return -1;
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			/* istanbul ignore next: difficult to make a test case for */
			if (!request$1) return -1;
			assert$12(!this.upgrade);
			assert$12(this.statusCode < 200);
			if (statusCode === 100) {
				util$13.destroy(socket, new SocketError$2("bad response", util$13.getSocketInfo(socket)));
				return -1;
			}
			if (upgrade$1 && !request$1.upgrade) {
				util$13.destroy(socket, new SocketError$2("bad upgrade", util$13.getSocketInfo(socket)));
				return -1;
			}
			assert$12.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
			this.statusCode = statusCode;
			this.shouldKeepAlive = shouldKeepAlive || request$1.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
			if (this.statusCode >= 200) {
				const bodyTimeout = request$1.bodyTimeout != null ? request$1.bodyTimeout : client$6[kBodyTimeout];
				this.setTimeout(bodyTimeout, TIMEOUT_BODY);
			} else if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			if (request$1.method === "CONNECT") {
				assert$12(client$6[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			if (upgrade$1) {
				assert$12(client$6[kRunning$3] === 1);
				this.upgrade = true;
				return 2;
			}
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (this.shouldKeepAlive && client$6[kPipelining]) {
				const keepAliveTimeout = this.keepAlive ? util$13.parseKeepAliveTimeout(this.keepAlive) : null;
				if (keepAliveTimeout != null) {
					const timeout = Math.min(keepAliveTimeout - client$6[kKeepAliveTimeoutThreshold], client$6[kKeepAliveMaxTimeout]);
					if (timeout <= 0) socket[kReset] = true;
					else client$6[kKeepAliveTimeoutValue] = timeout;
				} else client$6[kKeepAliveTimeoutValue] = client$6[kKeepAliveDefaultTimeout];
			} else socket[kReset] = true;
			const pause = request$1.onHeaders(statusCode, headers, this.resume, statusText) === false;
			if (request$1.aborted) return -1;
			if (request$1.method === "HEAD") return 1;
			if (statusCode < 200) return 1;
			if (socket[kBlocking]) {
				socket[kBlocking] = false;
				resume(client$6);
			}
			return pause ? constants.ERROR.PAUSED : 0;
		}
		onBody(buf) {
			const { client: client$6, socket, statusCode, maxResponseSize } = this;
			if (socket.destroyed) return -1;
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			assert$12(request$1);
			assert$12.strictEqual(this.timeoutType, TIMEOUT_BODY);
			if (this.timeout) {
				// istanbul ignore else: only for jest
				if (this.timeout.refresh) this.timeout.refresh();
			}
			assert$12(statusCode >= 200);
			if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
				util$13.destroy(socket, new ResponseExceededMaxSizeError());
				return -1;
			}
			this.bytesRead += buf.length;
			if (request$1.onData(buf) === false) return constants.ERROR.PAUSED;
		}
		onMessageComplete() {
			const { client: client$6, socket, statusCode, upgrade: upgrade$1, headers, contentLength, bytesRead, shouldKeepAlive } = this;
			if (socket.destroyed && (!statusCode || shouldKeepAlive)) return -1;
			if (upgrade$1) return;
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			assert$12(request$1);
			assert$12(statusCode >= 100);
			this.statusCode = null;
			this.statusText = "";
			this.bytesRead = 0;
			this.contentLength = "";
			this.keepAlive = "";
			this.connection = "";
			assert$12(this.headers.length % 2 === 0);
			this.headers = [];
			this.headersSize = 0;
			if (statusCode < 200) return;
			/* istanbul ignore next: should be handled by llhttp? */
			if (request$1.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
				util$13.destroy(socket, new ResponseContentLengthMismatchError());
				return -1;
			}
			request$1.onComplete(headers);
			client$6[kQueue$1][client$6[kRunningIdx]++] = null;
			if (socket[kWriting]) {
				assert$12.strictEqual(client$6[kRunning$3], 0);
				util$13.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (!shouldKeepAlive) {
				util$13.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (socket[kReset] && client$6[kRunning$3] === 0) {
				util$13.destroy(socket, new InformationalError("reset"));
				return constants.ERROR.PAUSED;
			} else if (client$6[kPipelining] === 1) setImmediate(resume, client$6);
			else resume(client$6);
		}
	};
	function onParserTimeout(parser$1) {
		const { socket, timeoutType, client: client$6 } = parser$1;
		/* istanbul ignore else */
		if (timeoutType === TIMEOUT_HEADERS) {
			if (!socket[kWriting] || socket.writableNeedDrain || client$6[kRunning$3] > 1) {
				assert$12(!parser$1.paused, "cannot be paused while waiting for headers");
				util$13.destroy(socket, new HeadersTimeoutError());
			}
		} else if (timeoutType === TIMEOUT_BODY) {
			if (!parser$1.paused) util$13.destroy(socket, new BodyTimeoutError());
		} else if (timeoutType === TIMEOUT_IDLE) {
			assert$12(client$6[kRunning$3] === 0 && client$6[kKeepAliveTimeoutValue]);
			util$13.destroy(socket, new InformationalError("socket idle timeout"));
		}
	}
	function onSocketReadable() {
		const { [kParser]: parser$1 } = this;
		if (parser$1) parser$1.readMore();
	}
	function onSocketError$1(err) {
		const { [kClient$1]: client$6, [kParser]: parser$1 } = this;
		assert$12(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
		if (client$6[kHTTPConnVersion] !== "h2") {
			if (err.code === "ECONNRESET" && parser$1.statusCode && !parser$1.shouldKeepAlive) {
				parser$1.onMessageComplete();
				return;
			}
		}
		this[kError$2] = err;
		onError(this[kClient$1], err);
	}
	function onError(client$6, err) {
		if (client$6[kRunning$3] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
			assert$12(client$6[kPendingIdx] === client$6[kRunningIdx]);
			const requests = client$6[kQueue$1].splice(client$6[kRunningIdx]);
			for (let i$5 = 0; i$5 < requests.length; i$5++) {
				const request$1 = requests[i$5];
				errorRequest(client$6, request$1, err);
			}
			assert$12(client$6[kSize$4] === 0);
		}
	}
	function onSocketEnd() {
		const { [kParser]: parser$1, [kClient$1]: client$6 } = this;
		if (client$6[kHTTPConnVersion] !== "h2") {
			if (parser$1.statusCode && !parser$1.shouldKeepAlive) {
				parser$1.onMessageComplete();
				return;
			}
		}
		util$13.destroy(this, new SocketError$2("other side closed", util$13.getSocketInfo(this)));
	}
	function onSocketClose$1() {
		const { [kClient$1]: client$6, [kParser]: parser$1 } = this;
		if (client$6[kHTTPConnVersion] === "h1" && parser$1) {
			if (!this[kError$2] && parser$1.statusCode && !parser$1.shouldKeepAlive) parser$1.onMessageComplete();
			this[kParser].destroy();
			this[kParser] = null;
		}
		const err = this[kError$2] || new SocketError$2("closed", util$13.getSocketInfo(this));
		client$6[kSocket] = null;
		if (client$6.destroyed) {
			assert$12(client$6[kPending$2] === 0);
			const requests = client$6[kQueue$1].splice(client$6[kRunningIdx]);
			for (let i$5 = 0; i$5 < requests.length; i$5++) {
				const request$1 = requests[i$5];
				errorRequest(client$6, request$1, err);
			}
		} else if (client$6[kRunning$3] > 0 && err.code !== "UND_ERR_INFO") {
			const request$1 = client$6[kQueue$1][client$6[kRunningIdx]];
			client$6[kQueue$1][client$6[kRunningIdx]++] = null;
			errorRequest(client$6, request$1, err);
		}
		client$6[kPendingIdx] = client$6[kRunningIdx];
		assert$12(client$6[kRunning$3] === 0);
		client$6.emit("disconnect", client$6[kUrl$3], [client$6], err);
		resume(client$6);
	}
	async function connect$1(client$6) {
		assert$12(!client$6[kConnecting]);
		assert$12(!client$6[kSocket]);
		let { host, hostname, protocol, port } = client$6[kUrl$3];
		if (hostname[0] === "[") {
			const idx = hostname.indexOf("]");
			assert$12(idx !== -1);
			const ip = hostname.substring(1, idx);
			assert$12(net.isIP(ip));
			hostname = ip;
		}
		client$6[kConnecting] = true;
		if (channels$2.beforeConnect.hasSubscribers) channels$2.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				servername: client$6[kServerName],
				localAddress: client$6[kLocalAddress]
			},
			connector: client$6[kConnector]
		});
		try {
			const socket = await new Promise((resolve, reject) => {
				client$6[kConnector]({
					host,
					hostname,
					protocol,
					port,
					servername: client$6[kServerName],
					localAddress: client$6[kLocalAddress]
				}, (err, socket$1) => {
					if (err) reject(err);
					else resolve(socket$1);
				});
			});
			if (client$6.destroyed) {
				util$13.destroy(socket.on("error", () => {}), new ClientDestroyedError());
				return;
			}
			client$6[kConnecting] = false;
			assert$12(socket);
			if (socket.alpnProtocol === "h2") {
				if (!h2ExperimentalWarned) {
					h2ExperimentalWarned = true;
					process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
				}
				const session = http2$1.connect(client$6[kUrl$3], {
					createConnection: () => socket,
					peerMaxConcurrentStreams: client$6[kHTTP2SessionState].maxConcurrentStreams
				});
				client$6[kHTTPConnVersion] = "h2";
				session[kClient$1] = client$6;
				session[kSocket] = socket;
				session.on("error", onHttp2SessionError);
				session.on("frameError", onHttp2FrameError);
				session.on("end", onHttp2SessionEnd);
				session.on("goaway", onHTTP2GoAway);
				session.on("close", onSocketClose$1);
				session.unref();
				client$6[kHTTP2Session] = session;
				socket[kHTTP2Session] = session;
			} else {
				if (!llhttpInstance) {
					llhttpInstance = await llhttpPromise;
					llhttpPromise = null;
				}
				socket[kNoRef] = false;
				socket[kWriting] = false;
				socket[kReset] = false;
				socket[kBlocking] = false;
				socket[kParser] = new Parser(client$6, socket, llhttpInstance);
			}
			socket[kCounter] = 0;
			socket[kMaxRequests] = client$6[kMaxRequests];
			socket[kClient$1] = client$6;
			socket[kError$2] = null;
			socket.on("error", onSocketError$1).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose$1);
			client$6[kSocket] = socket;
			if (channels$2.connected.hasSubscribers) channels$2.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client$6[kServerName],
					localAddress: client$6[kLocalAddress]
				},
				connector: client$6[kConnector],
				socket
			});
			client$6.emit("connect", client$6[kUrl$3], [client$6]);
		} catch (err) {
			if (client$6.destroyed) return;
			client$6[kConnecting] = false;
			if (channels$2.connectError.hasSubscribers) channels$2.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client$6[kServerName],
					localAddress: client$6[kLocalAddress]
				},
				connector: client$6[kConnector],
				error: err
			});
			if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
				assert$12(client$6[kRunning$3] === 0);
				while (client$6[kPending$2] > 0 && client$6[kQueue$1][client$6[kPendingIdx]].servername === client$6[kServerName]) {
					const request$1 = client$6[kQueue$1][client$6[kPendingIdx]++];
					errorRequest(client$6, request$1, err);
				}
			} else onError(client$6, err);
			client$6.emit("connectionError", client$6[kUrl$3], [client$6], err);
		}
		resume(client$6);
	}
	function emitDrain(client$6) {
		client$6[kNeedDrain$3] = 0;
		client$6.emit("drain", client$6[kUrl$3], [client$6]);
	}
	function resume(client$6, sync) {
		if (client$6[kResuming] === 2) return;
		client$6[kResuming] = 2;
		_resume(client$6, sync);
		client$6[kResuming] = 0;
		if (client$6[kRunningIdx] > 256) {
			client$6[kQueue$1].splice(0, client$6[kRunningIdx]);
			client$6[kPendingIdx] -= client$6[kRunningIdx];
			client$6[kRunningIdx] = 0;
		}
	}
	function _resume(client$6, sync) {
		while (true) {
			if (client$6.destroyed) {
				assert$12(client$6[kPending$2] === 0);
				return;
			}
			if (client$6[kClosedResolve$1] && !client$6[kSize$4]) {
				client$6[kClosedResolve$1]();
				client$6[kClosedResolve$1] = null;
				return;
			}
			const socket = client$6[kSocket];
			if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
				if (client$6[kSize$4] === 0) {
					if (!socket[kNoRef] && socket.unref) {
						socket.unref();
						socket[kNoRef] = true;
					}
				} else if (socket[kNoRef] && socket.ref) {
					socket.ref();
					socket[kNoRef] = false;
				}
				if (client$6[kSize$4] === 0) {
					if (socket[kParser].timeoutType !== TIMEOUT_IDLE) socket[kParser].setTimeout(client$6[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				} else if (client$6[kRunning$3] > 0 && socket[kParser].statusCode < 200) {
					if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
						const request$2 = client$6[kQueue$1][client$6[kRunningIdx]];
						const headersTimeout = request$2.headersTimeout != null ? request$2.headersTimeout : client$6[kHeadersTimeout];
						socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
					}
				}
			}
			if (client$6[kBusy$1]) client$6[kNeedDrain$3] = 2;
			else if (client$6[kNeedDrain$3] === 2) {
				if (sync) {
					client$6[kNeedDrain$3] = 1;
					process.nextTick(emitDrain, client$6);
				} else emitDrain(client$6);
				continue;
			}
			if (client$6[kPending$2] === 0) return;
			if (client$6[kRunning$3] >= (client$6[kPipelining] || 1)) return;
			const request$1 = client$6[kQueue$1][client$6[kPendingIdx]];
			if (client$6[kUrl$3].protocol === "https:" && client$6[kServerName] !== request$1.servername) {
				if (client$6[kRunning$3] > 0) return;
				client$6[kServerName] = request$1.servername;
				if (socket && socket.servername !== request$1.servername) {
					util$13.destroy(socket, new InformationalError("servername changed"));
					return;
				}
			}
			if (client$6[kConnecting]) return;
			if (!socket && !client$6[kHTTP2Session]) {
				connect$1(client$6);
				return;
			}
			if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) return;
			if (client$6[kRunning$3] > 0 && !request$1.idempotent) return;
			if (client$6[kRunning$3] > 0 && (request$1.upgrade || request$1.method === "CONNECT")) return;
			if (client$6[kRunning$3] > 0 && util$13.bodyLength(request$1.body) !== 0 && (util$13.isStream(request$1.body) || util$13.isAsyncIterable(request$1.body))) return;
			if (!request$1.aborted && write(client$6, request$1)) client$6[kPendingIdx]++;
			else client$6[kQueue$1].splice(client$6[kPendingIdx], 1);
		}
	}
	function shouldSendContentLength(method) {
		return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
	}
	function write(client$6, request$1) {
		if (client$6[kHTTPConnVersion] === "h2") {
			writeH2(client$6, client$6[kHTTP2Session], request$1);
			return;
		}
		const { body, method, path: path$6, host, upgrade: upgrade$1, headers, blocking, reset } = request$1;
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		const bodyLength$1 = util$13.bodyLength(body);
		let contentLength = bodyLength$1;
		if (contentLength === null) contentLength = request$1.contentLength;
		if (contentLength === 0 && !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$1.contentLength !== null && request$1.contentLength !== contentLength) {
			if (client$6[kStrictContentLength]) {
				errorRequest(client$6, request$1, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		const socket = client$6[kSocket];
		try {
			request$1.onConnect((err) => {
				if (request$1.aborted || request$1.completed) return;
				errorRequest(client$6, request$1, err || new RequestAbortedError$8());
				util$13.destroy(socket, new InformationalError("aborted"));
			});
		} catch (err) {
			errorRequest(client$6, request$1, err);
		}
		if (request$1.aborted) return false;
		if (method === "HEAD") socket[kReset] = true;
		if (upgrade$1 || method === "CONNECT") socket[kReset] = true;
		if (reset != null) socket[kReset] = reset;
		if (client$6[kMaxRequests] && socket[kCounter]++ >= client$6[kMaxRequests]) socket[kReset] = true;
		if (blocking) socket[kBlocking] = true;
		let header = `${method} ${path$6} HTTP/1.1\r\n`;
		if (typeof host === "string") header += `host: ${host}\r\n`;
		else header += client$6[kHostHeader];
		if (upgrade$1) header += `connection: upgrade\r\nupgrade: ${upgrade$1}\r\n`;
		else if (client$6[kPipelining] && !socket[kReset]) header += "connection: keep-alive\r\n";
		else header += "connection: close\r\n";
		if (headers) header += headers;
		if (channels$2.sendHeaders.hasSubscribers) channels$2.sendHeaders.publish({
			request: request$1,
			headers: header,
			socket
		});
		/* istanbul ignore else: assertion */
		if (!body || bodyLength$1 === 0) {
			if (contentLength === 0) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else {
				assert$12(contentLength === null, "no body must not have content length");
				socket.write(`${header}\r\n`, "latin1");
			}
			request$1.onRequestSent();
		} else if (util$13.isBuffer(body)) {
			assert$12(contentLength === body.byteLength, "buffer body must have content length");
			socket.cork();
			socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			socket.write(body);
			socket.uncork();
			request$1.onBodySent(body);
			request$1.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
		} else if (util$13.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
			body: body.stream(),
			client: client$6,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else writeBlob({
			body,
			client: client$6,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$13.isStream(body)) writeStream({
			body,
			client: client$6,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else if (util$13.isIterable(body)) writeIterable({
			body,
			client: client$6,
			request: request$1,
			socket,
			contentLength,
			header,
			expectsPayload
		});
		else assert$12(false);
		return true;
	}
	function writeH2(client$6, session, request$1) {
		const { body, method, path: path$6, host, upgrade: upgrade$1, expectContinue, signal, headers: reqHeaders } = request$1;
		let headers;
		if (typeof reqHeaders === "string") headers = Request$4[kHTTP2CopyHeaders](reqHeaders.trim());
		else headers = reqHeaders;
		if (upgrade$1) {
			errorRequest(client$6, request$1, /* @__PURE__ */ new Error("Upgrade not supported for H2"));
			return false;
		}
		try {
			request$1.onConnect((err) => {
				if (request$1.aborted || request$1.completed) return;
				errorRequest(client$6, request$1, err || new RequestAbortedError$8());
			});
		} catch (err) {
			errorRequest(client$6, request$1, err);
		}
		if (request$1.aborted) return false;
		/** @type {import('node:http2').ClientHttp2Stream} */
		let stream$3;
		const h2State = client$6[kHTTP2SessionState];
		headers[HTTP2_HEADER_AUTHORITY] = host || client$6[kHost];
		headers[HTTP2_HEADER_METHOD] = method;
		if (method === "CONNECT") {
			session.ref();
			stream$3 = session.request(headers, {
				endStream: false,
				signal
			});
			if (stream$3.id && !stream$3.pending) {
				request$1.onUpgrade(null, null, stream$3);
				++h2State.openStreams;
			} else stream$3.once("ready", () => {
				request$1.onUpgrade(null, null, stream$3);
				++h2State.openStreams;
			});
			stream$3.once("close", () => {
				h2State.openStreams -= 1;
				if (h2State.openStreams === 0) session.unref();
			});
			return true;
		}
		headers[HTTP2_HEADER_PATH] = path$6;
		headers[HTTP2_HEADER_SCHEME] = "https";
		const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
		if (body && typeof body.read === "function") body.read(0);
		let contentLength = util$13.bodyLength(body);
		if (contentLength == null) contentLength = request$1.contentLength;
		if (contentLength === 0 || !expectsPayload) contentLength = null;
		if (shouldSendContentLength(method) && contentLength > 0 && request$1.contentLength != null && request$1.contentLength !== contentLength) {
			if (client$6[kStrictContentLength]) {
				errorRequest(client$6, request$1, new RequestContentLengthMismatchError());
				return false;
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (contentLength != null) {
			assert$12(body, "no body must not have content length");
			headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
		}
		session.ref();
		const shouldEndStream = method === "GET" || method === "HEAD";
		if (expectContinue) {
			headers[HTTP2_HEADER_EXPECT] = "100-continue";
			stream$3 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			stream$3.once("continue", writeBodyH2);
		} else {
			stream$3 = session.request(headers, {
				endStream: shouldEndStream,
				signal
			});
			writeBodyH2();
		}
		++h2State.openStreams;
		stream$3.once("response", (headers$1) => {
			const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers$1;
			if (request$1.onHeaders(Number(statusCode), realHeaders, stream$3.resume.bind(stream$3), "") === false) stream$3.pause();
		});
		stream$3.once("end", () => {
			request$1.onComplete([]);
		});
		stream$3.on("data", (chunk) => {
			if (request$1.onData(chunk) === false) stream$3.pause();
		});
		stream$3.once("close", () => {
			h2State.openStreams -= 1;
			if (h2State.openStreams === 0) session.unref();
		});
		stream$3.once("error", function(err) {
			if (client$6[kHTTP2Session] && !client$6[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$13.destroy(stream$3, err);
			}
		});
		stream$3.once("frameError", (type, code) => {
			const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
			errorRequest(client$6, request$1, err);
			if (client$6[kHTTP2Session] && !client$6[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
				h2State.streams -= 1;
				util$13.destroy(stream$3, err);
			}
		});
		return true;
		function writeBodyH2() {
			/* istanbul ignore else: assertion */
			if (!body) request$1.onRequestSent();
			else if (util$13.isBuffer(body)) {
				assert$12(contentLength === body.byteLength, "buffer body must have content length");
				stream$3.cork();
				stream$3.write(body);
				stream$3.uncork();
				stream$3.end();
				request$1.onBodySent(body);
				request$1.onRequestSent();
			} else if (util$13.isBlobLike(body)) if (typeof body.stream === "function") writeIterable({
				client: client$6,
				request: request$1,
				contentLength,
				h2stream: stream$3,
				expectsPayload,
				body: body.stream(),
				socket: client$6[kSocket],
				header: ""
			});
			else writeBlob({
				body,
				client: client$6,
				request: request$1,
				contentLength,
				expectsPayload,
				h2stream: stream$3,
				header: "",
				socket: client$6[kSocket]
			});
			else if (util$13.isStream(body)) writeStream({
				body,
				client: client$6,
				request: request$1,
				contentLength,
				expectsPayload,
				socket: client$6[kSocket],
				h2stream: stream$3,
				header: ""
			});
			else if (util$13.isIterable(body)) writeIterable({
				body,
				client: client$6,
				request: request$1,
				contentLength,
				expectsPayload,
				header: "",
				h2stream: stream$3,
				socket: client$6[kSocket]
			});
			else assert$12(false);
		}
	}
	function writeStream({ h2stream, body, client: client$6, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client$6[kRunning$3] === 0, "stream body cannot be pipelined");
		if (client$6[kHTTPConnVersion] === "h2") {
			const pipe = pipeline$2(body, h2stream, (err) => {
				if (err) {
					util$13.destroy(body, err);
					util$13.destroy(h2stream, err);
				} else request$1.onRequestSent();
			});
			pipe.on("data", onPipeData);
			pipe.once("end", () => {
				pipe.removeListener("data", onPipeData);
				util$13.destroy(pipe);
			});
			function onPipeData(chunk) {
				request$1.onBodySent(chunk);
			}
			return;
		}
		let finished$1 = false;
		const writer = new AsyncWriter({
			socket,
			request: request$1,
			contentLength,
			client: client$6,
			expectsPayload,
			header
		});
		const onData = function(chunk) {
			if (finished$1) return;
			try {
				if (!writer.write(chunk) && this.pause) this.pause();
			} catch (err) {
				util$13.destroy(this, err);
			}
		};
		const onDrain = function() {
			if (finished$1) return;
			if (body.resume) body.resume();
		};
		const onAbort = function() {
			if (finished$1) return;
			const err = new RequestAbortedError$8();
			queueMicrotask(() => onFinished(err));
		};
		const onFinished = function(err) {
			if (finished$1) return;
			finished$1 = true;
			assert$12(socket.destroyed || socket[kWriting] && client$6[kRunning$3] <= 1);
			socket.off("drain", onDrain).off("error", onFinished);
			body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
			if (!err) try {
				writer.end();
			} catch (er) {
				err = er;
			}
			writer.destroy(err);
			if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) util$13.destroy(body, err);
			else util$13.destroy(body);
		};
		body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
		if (body.resume) body.resume();
		socket.on("drain", onDrain).on("error", onFinished);
	}
	async function writeBlob({ h2stream, body, client: client$6, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength === body.size, "blob body must have content length");
		const isH2$1 = client$6[kHTTPConnVersion] === "h2";
		try {
			if (contentLength != null && contentLength !== body.size) throw new RequestContentLengthMismatchError();
			const buffer$3 = Buffer.from(await body.arrayBuffer());
			if (isH2$1) {
				h2stream.cork();
				h2stream.write(buffer$3);
				h2stream.uncork();
			} else {
				socket.cork();
				socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
				socket.write(buffer$3);
				socket.uncork();
			}
			request$1.onBodySent(buffer$3);
			request$1.onRequestSent();
			if (!expectsPayload) socket[kReset] = true;
			resume(client$6);
		} catch (err) {
			util$13.destroy(isH2$1 ? h2stream : socket, err);
		}
	}
	async function writeIterable({ h2stream, body, client: client$6, request: request$1, socket, contentLength, header, expectsPayload }) {
		assert$12(contentLength !== 0 || client$6[kRunning$3] === 0, "iterator body cannot be pipelined");
		let callback = null;
		function onDrain() {
			if (callback) {
				const cb = callback;
				callback = null;
				cb();
			}
		}
		const waitForDrain = () => new Promise((resolve, reject) => {
			assert$12(callback === null);
			if (socket[kError$2]) reject(socket[kError$2]);
			else callback = resolve;
		});
		if (client$6[kHTTPConnVersion] === "h2") {
			h2stream.on("close", onDrain).on("drain", onDrain);
			try {
				for await (const chunk of body) {
					if (socket[kError$2]) throw socket[kError$2];
					const res = h2stream.write(chunk);
					request$1.onBodySent(chunk);
					if (!res) await waitForDrain();
				}
			} catch (err) {
				h2stream.destroy(err);
			} finally {
				request$1.onRequestSent();
				h2stream.end();
				h2stream.off("close", onDrain).off("drain", onDrain);
			}
			return;
		}
		socket.on("close", onDrain).on("drain", onDrain);
		const writer = new AsyncWriter({
			socket,
			request: request$1,
			contentLength,
			client: client$6,
			expectsPayload,
			header
		});
		try {
			for await (const chunk of body) {
				if (socket[kError$2]) throw socket[kError$2];
				if (!writer.write(chunk)) await waitForDrain();
			}
			writer.end();
		} catch (err) {
			writer.destroy(err);
		} finally {
			socket.off("close", onDrain).off("drain", onDrain);
		}
	}
	var AsyncWriter = class {
		constructor({ socket, request: request$1, contentLength, client: client$6, expectsPayload, header }) {
			this.socket = socket;
			this.request = request$1;
			this.contentLength = contentLength;
			this.client = client$6;
			this.bytesWritten = 0;
			this.expectsPayload = expectsPayload;
			this.header = header;
			socket[kWriting] = true;
		}
		write(chunk) {
			const { socket, request: request$1, contentLength, client: client$6, bytesWritten, expectsPayload, header } = this;
			if (socket[kError$2]) throw socket[kError$2];
			if (socket.destroyed) return false;
			const len = Buffer.byteLength(chunk);
			if (!len) return true;
			if (contentLength !== null && bytesWritten + len > contentLength) {
				if (client$6[kStrictContentLength]) throw new RequestContentLengthMismatchError();
				process.emitWarning(new RequestContentLengthMismatchError());
			}
			socket.cork();
			if (bytesWritten === 0) {
				if (!expectsPayload) socket[kReset] = true;
				if (contentLength === null) socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
				else socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
			}
			if (contentLength === null) socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
			this.bytesWritten += len;
			const ret = socket.write(chunk);
			socket.uncork();
			request$1.onBodySent(chunk);
			if (!ret) {
				if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
					// istanbul ignore else: only for jest
					if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
				}
			}
			return ret;
		}
		end() {
			const { socket, contentLength, client: client$6, bytesWritten, expectsPayload, header, request: request$1 } = this;
			request$1.onRequestSent();
			socket[kWriting] = false;
			if (socket[kError$2]) throw socket[kError$2];
			if (socket.destroyed) return;
			if (bytesWritten === 0) if (expectsPayload) socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
			else socket.write(`${header}\r\n`, "latin1");
			else if (contentLength === null) socket.write("\r\n0\r\n\r\n", "latin1");
			if (contentLength !== null && bytesWritten !== contentLength) if (client$6[kStrictContentLength]) throw new RequestContentLengthMismatchError();
			else process.emitWarning(new RequestContentLengthMismatchError());
			if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
				// istanbul ignore else: only for jest
				if (socket[kParser].timeout.refresh) socket[kParser].timeout.refresh();
			}
			resume(client$6);
		}
		destroy(err) {
			const { socket, client: client$6 } = this;
			socket[kWriting] = false;
			if (err) {
				assert$12(client$6[kRunning$3] <= 1, "pipeline should only contain this request");
				util$13.destroy(socket, err);
			}
		}
	};
	function errorRequest(client$6, request$1, err) {
		try {
			request$1.onError(err);
			assert$12(request$1.aborted);
		} catch (err$1) {
			client$6.emit("error", err$1);
		}
	}
	module.exports = Client$5;
}));

//#endregion
//#region node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const kSize$3 = 2048;
	const kMask = kSize$3 - 1;
	var FixedCircularBuffer = class {
		constructor() {
			this.bottom = 0;
			this.top = 0;
			this.list = new Array(kSize$3);
			this.next = null;
		}
		isEmpty() {
			return this.top === this.bottom;
		}
		isFull() {
			return (this.top + 1 & kMask) === this.bottom;
		}
		push(data$1) {
			this.list[this.top] = data$1;
			this.top = this.top + 1 & kMask;
		}
		shift() {
			const nextItem = this.list[this.bottom];
			if (nextItem === void 0) return null;
			this.list[this.bottom] = void 0;
			this.bottom = this.bottom + 1 & kMask;
			return nextItem;
		}
	};
	module.exports = class FixedQueue$1 {
		constructor() {
			this.head = this.tail = new FixedCircularBuffer();
		}
		isEmpty() {
			return this.head.isEmpty();
		}
		push(data$1) {
			if (this.head.isFull()) this.head = this.head.next = new FixedCircularBuffer();
			this.head.push(data$1);
		}
		shift() {
			const tail = this.tail;
			const next = tail.shift();
			if (tail.isEmpty() && tail.next !== null) this.tail = tail.next;
			return next;
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/pool-stats.js
var require_pool_stats = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kFree: kFree$1, kConnected: kConnected$4, kPending: kPending$1, kQueued: kQueued$1, kRunning: kRunning$2, kSize: kSize$2 } = require_symbols$4();
	const kPool = Symbol("pool");
	var PoolStats$1 = class {
		constructor(pool) {
			this[kPool] = pool;
		}
		get connected() {
			return this[kPool][kConnected$4];
		}
		get free() {
			return this[kPool][kFree$1];
		}
		get pending() {
			return this[kPool][kPending$1];
		}
		get queued() {
			return this[kPool][kQueued$1];
		}
		get running() {
			return this[kPool][kRunning$2];
		}
		get size() {
			return this[kPool][kSize$2];
		}
	};
	module.exports = PoolStats$1;
}));

//#endregion
//#region node_modules/undici/lib/pool-base.js
var require_pool_base = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const DispatcherBase$2 = require_dispatcher_base();
	const FixedQueue = require_fixed_queue();
	const { kConnected: kConnected$3, kSize: kSize$1, kRunning: kRunning$1, kPending, kQueued, kBusy, kFree, kUrl: kUrl$2, kClose: kClose$4, kDestroy: kDestroy$2, kDispatch: kDispatch$1 } = require_symbols$4();
	const PoolStats = require_pool_stats();
	const kClients$4 = Symbol("clients");
	const kNeedDrain$2 = Symbol("needDrain");
	const kQueue = Symbol("queue");
	const kClosedResolve = Symbol("closed resolve");
	const kOnDrain$1 = Symbol("onDrain");
	const kOnConnect$1 = Symbol("onConnect");
	const kOnDisconnect$1 = Symbol("onDisconnect");
	const kOnConnectionError$1 = Symbol("onConnectionError");
	const kGetDispatcher$2 = Symbol("get dispatcher");
	const kAddClient$2 = Symbol("add client");
	const kRemoveClient$1 = Symbol("remove client");
	const kStats = Symbol("stats");
	var PoolBase$2 = class extends DispatcherBase$2 {
		constructor() {
			super();
			this[kQueue] = new FixedQueue();
			this[kClients$4] = [];
			this[kQueued] = 0;
			const pool = this;
			this[kOnDrain$1] = function onDrain(origin, targets) {
				const queue = pool[kQueue];
				let needDrain = false;
				while (!needDrain) {
					const item = queue.shift();
					if (!item) break;
					pool[kQueued]--;
					needDrain = !this.dispatch(item.opts, item.handler);
				}
				this[kNeedDrain$2] = needDrain;
				if (!this[kNeedDrain$2] && pool[kNeedDrain$2]) {
					pool[kNeedDrain$2] = false;
					pool.emit("drain", origin, [pool, ...targets]);
				}
				if (pool[kClosedResolve] && queue.isEmpty()) Promise.all(pool[kClients$4].map((c$5) => c$5.close())).then(pool[kClosedResolve]);
			};
			this[kOnConnect$1] = (origin, targets) => {
				pool.emit("connect", origin, [pool, ...targets]);
			};
			this[kOnDisconnect$1] = (origin, targets, err) => {
				pool.emit("disconnect", origin, [pool, ...targets], err);
			};
			this[kOnConnectionError$1] = (origin, targets, err) => {
				pool.emit("connectionError", origin, [pool, ...targets], err);
			};
			this[kStats] = new PoolStats(this);
		}
		get [kBusy]() {
			return this[kNeedDrain$2];
		}
		get [kConnected$3]() {
			return this[kClients$4].filter((client$6) => client$6[kConnected$3]).length;
		}
		get [kFree]() {
			return this[kClients$4].filter((client$6) => client$6[kConnected$3] && !client$6[kNeedDrain$2]).length;
		}
		get [kPending]() {
			let ret = this[kQueued];
			for (const { [kPending]: pending } of this[kClients$4]) ret += pending;
			return ret;
		}
		get [kRunning$1]() {
			let ret = 0;
			for (const { [kRunning$1]: running } of this[kClients$4]) ret += running;
			return ret;
		}
		get [kSize$1]() {
			let ret = this[kQueued];
			for (const { [kSize$1]: size } of this[kClients$4]) ret += size;
			return ret;
		}
		get stats() {
			return this[kStats];
		}
		async [kClose$4]() {
			if (this[kQueue].isEmpty()) return Promise.all(this[kClients$4].map((c$5) => c$5.close()));
			else return new Promise((resolve) => {
				this[kClosedResolve] = resolve;
			});
		}
		async [kDestroy$2](err) {
			while (true) {
				const item = this[kQueue].shift();
				if (!item) break;
				item.handler.onError(err);
			}
			return Promise.all(this[kClients$4].map((c$5) => c$5.destroy(err)));
		}
		[kDispatch$1](opts, handler) {
			const dispatcher = this[kGetDispatcher$2]();
			if (!dispatcher) {
				this[kNeedDrain$2] = true;
				this[kQueue].push({
					opts,
					handler
				});
				this[kQueued]++;
			} else if (!dispatcher.dispatch(opts, handler)) {
				dispatcher[kNeedDrain$2] = true;
				this[kNeedDrain$2] = !this[kGetDispatcher$2]();
			}
			return !this[kNeedDrain$2];
		}
		[kAddClient$2](client$6) {
			client$6.on("drain", this[kOnDrain$1]).on("connect", this[kOnConnect$1]).on("disconnect", this[kOnDisconnect$1]).on("connectionError", this[kOnConnectionError$1]);
			this[kClients$4].push(client$6);
			if (this[kNeedDrain$2]) process.nextTick(() => {
				if (this[kNeedDrain$2]) this[kOnDrain$1](client$6[kUrl$2], [this, client$6]);
			});
			return this;
		}
		[kRemoveClient$1](client$6) {
			client$6.close(() => {
				const idx = this[kClients$4].indexOf(client$6);
				if (idx !== -1) this[kClients$4].splice(idx, 1);
			});
			this[kNeedDrain$2] = this[kClients$4].some((dispatcher) => !dispatcher[kNeedDrain$2] && dispatcher.closed !== true && dispatcher.destroyed !== true);
		}
	};
	module.exports = {
		PoolBase: PoolBase$2,
		kClients: kClients$4,
		kNeedDrain: kNeedDrain$2,
		kAddClient: kAddClient$2,
		kRemoveClient: kRemoveClient$1,
		kGetDispatcher: kGetDispatcher$2
	};
}));

//#endregion
//#region node_modules/undici/lib/pool.js
var require_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { PoolBase: PoolBase$1, kClients: kClients$3, kNeedDrain: kNeedDrain$1, kAddClient: kAddClient$1, kGetDispatcher: kGetDispatcher$1 } = require_pool_base();
	const Client$4 = require_client();
	const { InvalidArgumentError: InvalidArgumentError$15 } = require_errors();
	const util$12 = require_util$6();
	const { kUrl: kUrl$1, kInterceptors: kInterceptors$3 } = require_symbols$4();
	const buildConnector$2 = require_connect();
	const kOptions$3 = Symbol("options");
	const kConnections = Symbol("connections");
	const kFactory$3 = Symbol("factory");
	function defaultFactory$3(origin, opts) {
		return new Client$4(origin, opts);
	}
	var Pool$5 = class extends PoolBase$1 {
		constructor(origin, { connections, factory = defaultFactory$3, connect: connect$2, connectTimeout, tls: tls$2, maxCachedSessions, socketPath, autoSelectFamily, autoSelectFamilyAttemptTimeout, allowH2, ...options } = {}) {
			super();
			if (connections != null && (!Number.isFinite(connections) || connections < 0)) throw new InvalidArgumentError$15("invalid connections");
			if (typeof factory !== "function") throw new InvalidArgumentError$15("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$15("connect must be a function or an object");
			if (typeof connect$2 !== "function") connect$2 = buildConnector$2({
				...tls$2,
				maxCachedSessions,
				allowH2,
				socketPath,
				timeout: connectTimeout,
				...util$12.nodeHasAutoSelectFamily && autoSelectFamily ? {
					autoSelectFamily,
					autoSelectFamilyAttemptTimeout
				} : void 0,
				...connect$2
			});
			this[kInterceptors$3] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
			this[kConnections] = connections || null;
			this[kUrl$1] = util$12.parseOrigin(origin);
			this[kOptions$3] = {
				...util$12.deepClone(options),
				connect: connect$2,
				allowH2
			};
			this[kOptions$3].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kFactory$3] = factory;
			this.on("connectionError", (origin$1, targets, error$2) => {
				for (const target of targets) {
					const idx = this[kClients$3].indexOf(target);
					if (idx !== -1) this[kClients$3].splice(idx, 1);
				}
			});
		}
		[kGetDispatcher$1]() {
			let dispatcher = this[kClients$3].find((dispatcher$1) => !dispatcher$1[kNeedDrain$1]);
			if (dispatcher) return dispatcher;
			if (!this[kConnections] || this[kClients$3].length < this[kConnections]) {
				dispatcher = this[kFactory$3](this[kUrl$1], this[kOptions$3]);
				this[kAddClient$1](dispatcher);
			}
			return dispatcher;
		}
	};
	module.exports = Pool$5;
}));

//#endregion
//#region node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { BalancedPoolMissingUpstreamError, InvalidArgumentError: InvalidArgumentError$14 } = require_errors();
	const { PoolBase, kClients: kClients$2, kNeedDrain, kAddClient, kRemoveClient, kGetDispatcher } = require_pool_base();
	const Pool$4 = require_pool();
	const { kUrl, kInterceptors: kInterceptors$2 } = require_symbols$4();
	const { parseOrigin } = require_util$6();
	const kFactory$2 = Symbol("factory");
	const kOptions$2 = Symbol("options");
	const kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
	const kCurrentWeight = Symbol("kCurrentWeight");
	const kIndex = Symbol("kIndex");
	const kWeight = Symbol("kWeight");
	const kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
	const kErrorPenalty = Symbol("kErrorPenalty");
	function getGreatestCommonDivisor(a$5, b$5) {
		if (b$5 === 0) return a$5;
		return getGreatestCommonDivisor(b$5, a$5 % b$5);
	}
	function defaultFactory$2(origin, opts) {
		return new Pool$4(origin, opts);
	}
	var BalancedPool$1 = class extends PoolBase {
		constructor(upstreams = [], { factory = defaultFactory$2, ...opts } = {}) {
			super();
			this[kOptions$2] = opts;
			this[kIndex] = -1;
			this[kCurrentWeight] = 0;
			this[kMaxWeightPerServer] = this[kOptions$2].maxWeightPerServer || 100;
			this[kErrorPenalty] = this[kOptions$2].errorPenalty || 15;
			if (!Array.isArray(upstreams)) upstreams = [upstreams];
			if (typeof factory !== "function") throw new InvalidArgumentError$14("factory must be a function.");
			this[kInterceptors$2] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
			this[kFactory$2] = factory;
			for (const upstream of upstreams) this.addUpstream(upstream);
			this._updateBalancedPoolStats();
		}
		addUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			if (this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true)) return this;
			const pool = this[kFactory$2](upstreamOrigin, Object.assign({}, this[kOptions$2]));
			this[kAddClient](pool);
			pool.on("connect", () => {
				pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
			});
			pool.on("connectionError", () => {
				pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
				this._updateBalancedPoolStats();
			});
			pool.on("disconnect", (...args) => {
				const err = args[2];
				if (err && err.code === "UND_ERR_SOCKET") {
					pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
					this._updateBalancedPoolStats();
				}
			});
			for (const client$6 of this[kClients$2]) client$6[kWeight] = this[kMaxWeightPerServer];
			this._updateBalancedPoolStats();
			return this;
		}
		_updateBalancedPoolStats() {
			this[kGreatestCommonDivisor] = this[kClients$2].map((p$5) => p$5[kWeight]).reduce(getGreatestCommonDivisor, 0);
		}
		removeUpstream(upstream) {
			const upstreamOrigin = parseOrigin(upstream).origin;
			const pool = this[kClients$2].find((pool$1) => pool$1[kUrl].origin === upstreamOrigin && pool$1.closed !== true && pool$1.destroyed !== true);
			if (pool) this[kRemoveClient](pool);
			return this;
		}
		get upstreams() {
			return this[kClients$2].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p$5) => p$5[kUrl].origin);
		}
		[kGetDispatcher]() {
			if (this[kClients$2].length === 0) throw new BalancedPoolMissingUpstreamError();
			if (!this[kClients$2].find((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true)) return;
			if (this[kClients$2].map((pool) => pool[kNeedDrain]).reduce((a$5, b$5) => a$5 && b$5, true)) return;
			let counter = 0;
			let maxWeightIndex = this[kClients$2].findIndex((pool) => !pool[kNeedDrain]);
			while (counter++ < this[kClients$2].length) {
				this[kIndex] = (this[kIndex] + 1) % this[kClients$2].length;
				const pool = this[kClients$2][this[kIndex]];
				if (pool[kWeight] > this[kClients$2][maxWeightIndex][kWeight] && !pool[kNeedDrain]) maxWeightIndex = this[kIndex];
				if (this[kIndex] === 0) {
					this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
					if (this[kCurrentWeight] <= 0) this[kCurrentWeight] = this[kMaxWeightPerServer];
				}
				if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) return pool;
			}
			this[kCurrentWeight] = this[kClients$2][maxWeightIndex][kWeight];
			this[kIndex] = maxWeightIndex;
			return this[kClients$2][maxWeightIndex];
		}
	};
	module.exports = BalancedPool$1;
}));

//#endregion
//#region node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/* istanbul ignore file: only for Node 12 */
	const { kConnected: kConnected$2, kSize } = require_symbols$4();
	var CompatWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value[kConnected$2] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
		}
	};
	var CompatFinalizer = class {
		constructor(finalizer) {
			this.finalizer = finalizer;
		}
		register(dispatcher, key) {
			if (dispatcher.on) dispatcher.on("disconnect", () => {
				if (dispatcher[kConnected$2] === 0 && dispatcher[kSize] === 0) this.finalizer(key);
			});
		}
	};
	module.exports = function() {
		if (process.env.NODE_V8_COVERAGE) return {
			WeakRef: CompatWeakRef,
			FinalizationRegistry: CompatFinalizer
		};
		return {
			WeakRef: global.WeakRef || CompatWeakRef,
			FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
		};
	};
}));

//#endregion
//#region node_modules/undici/lib/agent.js
var require_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$13 } = require_errors();
	const { kClients: kClients$1, kRunning, kClose: kClose$3, kDestroy: kDestroy$1, kDispatch, kInterceptors: kInterceptors$1 } = require_symbols$4();
	const DispatcherBase$1 = require_dispatcher_base();
	const Pool$3 = require_pool();
	const Client$3 = require_client();
	const util$11 = require_util$6();
	const createRedirectInterceptor$1 = require_redirectInterceptor();
	const { WeakRef: WeakRef$1, FinalizationRegistry: FinalizationRegistry$1 } = require_dispatcher_weakref()();
	const kOnConnect = Symbol("onConnect");
	const kOnDisconnect = Symbol("onDisconnect");
	const kOnConnectionError = Symbol("onConnectionError");
	const kMaxRedirections = Symbol("maxRedirections");
	const kOnDrain = Symbol("onDrain");
	const kFactory$1 = Symbol("factory");
	const kFinalizer = Symbol("finalizer");
	const kOptions$1 = Symbol("options");
	function defaultFactory$1(origin, opts) {
		return opts && opts.connections === 1 ? new Client$3(origin, opts) : new Pool$3(origin, opts);
	}
	var Agent$4 = class extends DispatcherBase$1 {
		constructor({ factory = defaultFactory$1, maxRedirections = 0, connect: connect$2, ...options } = {}) {
			super();
			if (typeof factory !== "function") throw new InvalidArgumentError$13("factory must be a function.");
			if (connect$2 != null && typeof connect$2 !== "function" && typeof connect$2 !== "object") throw new InvalidArgumentError$13("connect must be a function or an object");
			if (!Number.isInteger(maxRedirections) || maxRedirections < 0) throw new InvalidArgumentError$13("maxRedirections must be a positive number");
			if (connect$2 && typeof connect$2 !== "function") connect$2 = { ...connect$2 };
			this[kInterceptors$1] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor$1({ maxRedirections })];
			this[kOptions$1] = {
				...util$11.deepClone(options),
				connect: connect$2
			};
			this[kOptions$1].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
			this[kMaxRedirections] = maxRedirections;
			this[kFactory$1] = factory;
			this[kClients$1] = /* @__PURE__ */ new Map();
			this[kFinalizer] = new FinalizationRegistry$1(
				/* istanbul ignore next: gc is undeterministic */
				(key) => {
					const ref = this[kClients$1].get(key);
					if (ref !== void 0 && ref.deref() === void 0) this[kClients$1].delete(key);
				}
			);
			const agent = this;
			this[kOnDrain] = (origin, targets) => {
				agent.emit("drain", origin, [agent, ...targets]);
			};
			this[kOnConnect] = (origin, targets) => {
				agent.emit("connect", origin, [agent, ...targets]);
			};
			this[kOnDisconnect] = (origin, targets, err) => {
				agent.emit("disconnect", origin, [agent, ...targets], err);
			};
			this[kOnConnectionError] = (origin, targets, err) => {
				agent.emit("connectionError", origin, [agent, ...targets], err);
			};
		}
		get [kRunning]() {
			let ret = 0;
			for (const ref of this[kClients$1].values()) {
				const client$6 = ref.deref();
				/* istanbul ignore next: gc is undeterministic */
				if (client$6) ret += client$6[kRunning];
			}
			return ret;
		}
		[kDispatch](opts, handler) {
			let key;
			if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) key = String(opts.origin);
			else throw new InvalidArgumentError$13("opts.origin must be a non-empty string or URL.");
			const ref = this[kClients$1].get(key);
			let dispatcher = ref ? ref.deref() : null;
			if (!dispatcher) {
				dispatcher = this[kFactory$1](opts.origin, this[kOptions$1]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
				this[kClients$1].set(key, new WeakRef$1(dispatcher));
				this[kFinalizer].register(dispatcher, key);
			}
			return dispatcher.dispatch(opts, handler);
		}
		async [kClose$3]() {
			const closePromises = [];
			for (const ref of this[kClients$1].values()) {
				const client$6 = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client$6) closePromises.push(client$6.close());
			}
			await Promise.all(closePromises);
		}
		async [kDestroy$1](err) {
			const destroyPromises = [];
			for (const ref of this[kClients$1].values()) {
				const client$6 = ref.deref();
				/* istanbul ignore else: gc is undeterministic */
				if (client$6) destroyPromises.push(client$6.destroy(err));
			}
			await Promise.all(destroyPromises);
		}
	};
	module.exports = Agent$4;
}));

//#endregion
//#region node_modules/undici/lib/api/readable.js
var require_readable = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$11 = __require("assert");
	const { Readable: Readable$3 } = __require("stream");
	const { RequestAbortedError: RequestAbortedError$7, NotSupportedError, InvalidArgumentError: InvalidArgumentError$12 } = require_errors();
	const util$10 = require_util$6();
	const { ReadableStreamFrom, toUSVString: toUSVString$1 } = require_util$6();
	let Blob$1;
	const kConsume = Symbol("kConsume");
	const kReading = Symbol("kReading");
	const kBody = Symbol("kBody");
	const kAbort = Symbol("abort");
	const kContentType = Symbol("kContentType");
	const noop = () => {};
	module.exports = class BodyReadable extends Readable$3 {
		constructor({ resume: resume$1, abort: abort$1, contentType = "", highWaterMark = 64 * 1024 }) {
			super({
				autoDestroy: true,
				read: resume$1,
				highWaterMark
			});
			this._readableState.dataEmitted = false;
			this[kAbort] = abort$1;
			this[kConsume] = null;
			this[kBody] = null;
			this[kContentType] = contentType;
			this[kReading] = false;
		}
		destroy(err) {
			if (this.destroyed) return this;
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$7();
			if (err) this[kAbort]();
			return super.destroy(err);
		}
		emit(ev, ...args) {
			if (ev === "data") this._readableState.dataEmitted = true;
			else if (ev === "error") this._readableState.errorEmitted = true;
			return super.emit(ev, ...args);
		}
		on(ev, ...args) {
			if (ev === "data" || ev === "readable") this[kReading] = true;
			return super.on(ev, ...args);
		}
		addListener(ev, ...args) {
			return this.on(ev, ...args);
		}
		off(ev, ...args) {
			const ret = super.off(ev, ...args);
			if (ev === "data" || ev === "readable") this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
			return ret;
		}
		removeListener(ev, ...args) {
			return this.off(ev, ...args);
		}
		push(chunk) {
			if (this[kConsume] && chunk !== null && this.readableLength === 0) {
				consumePush(this[kConsume], chunk);
				return this[kReading] ? super.push(chunk) : true;
			}
			return super.push(chunk);
		}
		async text() {
			return consume(this, "text");
		}
		async json() {
			return consume(this, "json");
		}
		async blob() {
			return consume(this, "blob");
		}
		async arrayBuffer() {
			return consume(this, "arrayBuffer");
		}
		async formData() {
			throw new NotSupportedError();
		}
		get bodyUsed() {
			return util$10.isDisturbed(this);
		}
		get body() {
			if (!this[kBody]) {
				this[kBody] = ReadableStreamFrom(this);
				if (this[kConsume]) {
					this[kBody].getReader();
					assert$11(this[kBody].locked);
				}
			}
			return this[kBody];
		}
		dump(opts) {
			let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
			const signal = opts && opts.signal;
			if (signal) try {
				if (typeof signal !== "object" || !("aborted" in signal)) throw new InvalidArgumentError$12("signal must be an AbortSignal");
				util$10.throwIfAborted(signal);
			} catch (err) {
				return Promise.reject(err);
			}
			if (this.closed) return Promise.resolve(null);
			return new Promise((resolve, reject) => {
				const signalListenerCleanup = signal ? util$10.addAbortListener(signal, () => {
					this.destroy();
				}) : noop;
				this.on("close", function() {
					signalListenerCleanup();
					if (signal && signal.aborted) reject(signal.reason || Object.assign(/* @__PURE__ */ new Error("The operation was aborted"), { name: "AbortError" }));
					else resolve(null);
				}).on("error", noop).on("data", function(chunk) {
					limit -= chunk.length;
					if (limit <= 0) this.destroy();
				}).resume();
			});
		}
	};
	function isLocked(self) {
		return self[kBody] && self[kBody].locked === true || self[kConsume];
	}
	function isUnusable(self) {
		return util$10.isDisturbed(self) || isLocked(self);
	}
	async function consume(stream$3, type) {
		if (isUnusable(stream$3)) throw new TypeError("unusable");
		assert$11(!stream$3[kConsume]);
		return new Promise((resolve, reject) => {
			stream$3[kConsume] = {
				type,
				stream: stream$3,
				resolve,
				reject,
				length: 0,
				body: []
			};
			stream$3.on("error", function(err) {
				consumeFinish(this[kConsume], err);
			}).on("close", function() {
				if (this[kConsume].body !== null) consumeFinish(this[kConsume], new RequestAbortedError$7());
			});
			process.nextTick(consumeStart, stream$3[kConsume]);
		});
	}
	function consumeStart(consume$1) {
		if (consume$1.body === null) return;
		const { _readableState: state$1 } = consume$1.stream;
		for (const chunk of state$1.buffer) consumePush(consume$1, chunk);
		if (state$1.endEmitted) consumeEnd(this[kConsume]);
		else consume$1.stream.on("end", function() {
			consumeEnd(this[kConsume]);
		});
		consume$1.stream.resume();
		while (consume$1.stream.read() != null);
	}
	function consumeEnd(consume$1) {
		const { type, body, resolve, stream: stream$3, length } = consume$1;
		try {
			if (type === "text") resolve(toUSVString$1(Buffer.concat(body)));
			else if (type === "json") resolve(JSON.parse(Buffer.concat(body)));
			else if (type === "arrayBuffer") {
				const dst = new Uint8Array(length);
				let pos = 0;
				for (const buf of body) {
					dst.set(buf, pos);
					pos += buf.byteLength;
				}
				resolve(dst.buffer);
			} else if (type === "blob") {
				if (!Blob$1) Blob$1 = __require("buffer").Blob;
				resolve(new Blob$1(body, { type: stream$3[kContentType] }));
			}
			consumeFinish(consume$1);
		} catch (err) {
			stream$3.destroy(err);
		}
	}
	function consumePush(consume$1, chunk) {
		consume$1.length += chunk.length;
		consume$1.body.push(chunk);
	}
	function consumeFinish(consume$1, err) {
		if (consume$1.body === null) return;
		if (err) consume$1.reject(err);
		else consume$1.resolve();
		consume$1.type = null;
		consume$1.stream = null;
		consume$1.resolve = null;
		consume$1.reject = null;
		consume$1.length = 0;
		consume$1.body = null;
	}
}));

//#endregion
//#region node_modules/undici/lib/api/util.js
var require_util$4 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$10 = __require("assert");
	const { ResponseStatusCodeError } = require_errors();
	const { toUSVString } = require_util$6();
	async function getResolveErrorBodyCallback$2({ callback, body, contentType, statusCode, statusMessage, headers }) {
		assert$10(body);
		let chunks = [];
		let limit = 0;
		for await (const chunk of body) {
			chunks.push(chunk);
			limit += chunk.length;
			if (limit > 128 * 1024) {
				chunks = null;
				break;
			}
		}
		if (statusCode === 204 || !contentType || !chunks) {
			process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
			return;
		}
		try {
			if (contentType.startsWith("application/json")) {
				const payload$1 = JSON.parse(toUSVString(Buffer.concat(chunks)));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload$1));
				return;
			}
			if (contentType.startsWith("text/")) {
				const payload$1 = toUSVString(Buffer.concat(chunks));
				process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload$1));
				return;
			}
		} catch (err) {}
		process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
	}
	module.exports = { getResolveErrorBodyCallback: getResolveErrorBodyCallback$2 };
}));

//#endregion
//#region node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { addAbortListener: addAbortListener$1 } = require_util$6();
	const { RequestAbortedError: RequestAbortedError$6 } = require_errors();
	const kListener = Symbol("kListener");
	const kSignal$1 = Symbol("kSignal");
	function abort(self) {
		if (self.abort) self.abort();
		else self.onError(new RequestAbortedError$6());
	}
	function addSignal$5(self, signal) {
		self[kSignal$1] = null;
		self[kListener] = null;
		if (!signal) return;
		if (signal.aborted) {
			abort(self);
			return;
		}
		self[kSignal$1] = signal;
		self[kListener] = () => {
			abort(self);
		};
		addAbortListener$1(self[kSignal$1], self[kListener]);
	}
	function removeSignal$5(self) {
		if (!self[kSignal$1]) return;
		if ("removeEventListener" in self[kSignal$1]) self[kSignal$1].removeEventListener("abort", self[kListener]);
		else self[kSignal$1].removeListener("abort", self[kListener]);
		self[kSignal$1] = null;
		self[kListener] = null;
	}
	module.exports = {
		addSignal: addSignal$5,
		removeSignal: removeSignal$5
	};
}));

//#endregion
//#region node_modules/undici/lib/api/api-request.js
var require_api_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Readable$2 = require_readable();
	const { InvalidArgumentError: InvalidArgumentError$11, RequestAbortedError: RequestAbortedError$5 } = require_errors();
	const util$9 = require_util$6();
	const { getResolveErrorBodyCallback: getResolveErrorBodyCallback$1 } = require_util$4();
	const { AsyncResource: AsyncResource$4 } = __require("async_hooks");
	const { addSignal: addSignal$4, removeSignal: removeSignal$4 } = require_abort_signal();
	var RequestHandler$3 = class extends AsyncResource$4 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$11("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$11("invalid callback");
				if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) throw new InvalidArgumentError$11("invalid highWaterMark");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$11("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$11("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$11("invalid onInfo callback");
				super("UNDICI_REQUEST");
			} catch (err) {
				if (util$9.isStream(body)) util$9.destroy(body.on("error", util$9.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.body = body;
			this.trailers = {};
			this.context = null;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError;
			this.highWaterMark = highWaterMark;
			if (util$9.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$4(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$5();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { callback, opaque, abort: abort$1, context, responseHeaders, highWaterMark } = this;
			const headers = responseHeaders === "raw" ? util$9.parseRawHeaders(rawHeaders) : util$9.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			const contentType = (responseHeaders === "raw" ? util$9.parseHeaders(rawHeaders) : headers)["content-type"];
			const body = new Readable$2({
				resume: resume$1,
				abort: abort$1,
				contentType,
				highWaterMark
			});
			this.callback = null;
			this.res = body;
			if (callback !== null) if (this.throwOnError && statusCode >= 400) this.runInAsyncScope(getResolveErrorBodyCallback$1, null, {
				callback,
				body,
				contentType,
				statusCode,
				statusMessage,
				headers
			});
			else this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				trailers: this.trailers,
				opaque,
				body,
				context
			});
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$4(this);
			util$9.parseHeaders(trailers, this.trailers);
			res.push(null);
		}
		onError(err) {
			const { res, callback, body, opaque } = this;
			removeSignal$4(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (res) {
				this.res = null;
				queueMicrotask(() => {
					util$9.destroy(res, err);
				});
			}
			if (body) {
				this.body = null;
				util$9.destroy(body, err);
			}
		}
	};
	function request(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			request.call(this, opts, (err, data$1) => {
				return err ? reject(err) : resolve(data$1);
			});
		});
		try {
			this.dispatch(opts, new RequestHandler$3(opts, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = request;
	module.exports.RequestHandler = RequestHandler$3;
}));

//#endregion
//#region node_modules/undici/lib/api/api-stream.js
var require_api_stream = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { finished, PassThrough: PassThrough$1 } = __require("stream");
	const { InvalidArgumentError: InvalidArgumentError$10, InvalidReturnValueError: InvalidReturnValueError$1, RequestAbortedError: RequestAbortedError$4 } = require_errors();
	const util$8 = require_util$6();
	const { getResolveErrorBodyCallback } = require_util$4();
	const { AsyncResource: AsyncResource$3 } = __require("async_hooks");
	const { addSignal: addSignal$3, removeSignal: removeSignal$3 } = require_abort_signal();
	var StreamHandler = class extends AsyncResource$3 {
		constructor(opts, factory, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$10("invalid opts");
			const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
			try {
				if (typeof callback !== "function") throw new InvalidArgumentError$10("invalid callback");
				if (typeof factory !== "function") throw new InvalidArgumentError$10("invalid factory");
				if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$10("signal must be an EventEmitter or EventTarget");
				if (method === "CONNECT") throw new InvalidArgumentError$10("invalid method");
				if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$10("invalid onInfo callback");
				super("UNDICI_STREAM");
			} catch (err) {
				if (util$8.isStream(body)) util$8.destroy(body.on("error", util$8.nop), err);
				throw err;
			}
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.factory = factory;
			this.callback = callback;
			this.res = null;
			this.abort = null;
			this.context = null;
			this.trailers = null;
			this.body = body;
			this.onInfo = onInfo || null;
			this.throwOnError = throwOnError || false;
			if (util$8.isStream(body)) body.on("error", (err) => {
				this.onError(err);
			});
			addSignal$3(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$4();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const { factory, opaque, context, callback, responseHeaders } = this;
			const headers = responseHeaders === "raw" ? util$8.parseRawHeaders(rawHeaders) : util$8.parseHeaders(rawHeaders);
			if (statusCode < 200) {
				if (this.onInfo) this.onInfo({
					statusCode,
					headers
				});
				return;
			}
			this.factory = null;
			let res;
			if (this.throwOnError && statusCode >= 400) {
				const contentType = (responseHeaders === "raw" ? util$8.parseHeaders(rawHeaders) : headers)["content-type"];
				res = new PassThrough$1();
				this.callback = null;
				this.runInAsyncScope(getResolveErrorBodyCallback, null, {
					callback,
					body: res,
					contentType,
					statusCode,
					statusMessage,
					headers
				});
			} else {
				if (factory === null) return;
				res = this.runInAsyncScope(factory, null, {
					statusCode,
					headers,
					opaque,
					context
				});
				if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") throw new InvalidReturnValueError$1("expected Writable");
				finished(res, { readable: false }, (err) => {
					const { callback: callback$1, res: res$1, opaque: opaque$1, trailers, abort: abort$1 } = this;
					this.res = null;
					if (err || !res$1.readable) util$8.destroy(res$1, err);
					this.callback = null;
					this.runInAsyncScope(callback$1, null, err || null, {
						opaque: opaque$1,
						trailers
					});
					if (err) abort$1();
				});
			}
			res.on("drain", resume$1);
			this.res = res;
			return (res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain) !== true;
		}
		onData(chunk) {
			const { res } = this;
			return res ? res.write(chunk) : true;
		}
		onComplete(trailers) {
			const { res } = this;
			removeSignal$3(this);
			if (!res) return;
			this.trailers = util$8.parseHeaders(trailers);
			res.end();
		}
		onError(err) {
			const { res, callback, opaque, body } = this;
			removeSignal$3(this);
			this.factory = null;
			if (res) {
				this.res = null;
				util$8.destroy(res, err);
			} else if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
			if (body) {
				this.body = null;
				util$8.destroy(body, err);
			}
		}
	};
	function stream$1(opts, factory, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			stream$1.call(this, opts, factory, (err, data$1) => {
				return err ? reject(err) : resolve(data$1);
			});
		});
		try {
			this.dispatch(opts, new StreamHandler(opts, factory, callback));
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = stream$1;
}));

//#endregion
//#region node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Readable: Readable$1, Duplex, PassThrough } = __require("stream");
	const { InvalidArgumentError: InvalidArgumentError$9, InvalidReturnValueError, RequestAbortedError: RequestAbortedError$3 } = require_errors();
	const util$7 = require_util$6();
	const { AsyncResource: AsyncResource$2 } = __require("async_hooks");
	const { addSignal: addSignal$2, removeSignal: removeSignal$2 } = require_abort_signal();
	const assert$9 = __require("assert");
	const kResume = Symbol("resume");
	var PipelineRequest = class extends Readable$1 {
		constructor() {
			super({ autoDestroy: true });
			this[kResume] = null;
		}
		_read() {
			const { [kResume]: resume$1 } = this;
			if (resume$1) {
				this[kResume] = null;
				resume$1();
			}
		}
		_destroy(err, callback) {
			this._read();
			callback(err);
		}
	};
	var PipelineResponse = class extends Readable$1 {
		constructor(resume$1) {
			super({ autoDestroy: true });
			this[kResume] = resume$1;
		}
		_read() {
			this[kResume]();
		}
		_destroy(err, callback) {
			if (!err && !this._readableState.endEmitted) err = new RequestAbortedError$3();
			callback(err);
		}
	};
	var PipelineHandler = class extends AsyncResource$2 {
		constructor(opts, handler) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$9("invalid opts");
			if (typeof handler !== "function") throw new InvalidArgumentError$9("invalid handler");
			const { signal, method, opaque, onInfo, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$9("signal must be an EventEmitter or EventTarget");
			if (method === "CONNECT") throw new InvalidArgumentError$9("invalid method");
			if (onInfo && typeof onInfo !== "function") throw new InvalidArgumentError$9("invalid onInfo callback");
			super("UNDICI_PIPELINE");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.handler = handler;
			this.abort = null;
			this.context = null;
			this.onInfo = onInfo || null;
			this.req = new PipelineRequest().on("error", util$7.nop);
			this.ret = new Duplex({
				readableObjectMode: opts.objectMode,
				autoDestroy: true,
				read: () => {
					const { body } = this;
					if (body && body.resume) body.resume();
				},
				write: (chunk, encoding, callback) => {
					const { req } = this;
					if (req.push(chunk, encoding) || req._readableState.destroyed) callback();
					else req[kResume] = callback;
				},
				destroy: (err, callback) => {
					const { body, req, res, ret, abort: abort$1 } = this;
					if (!err && !ret._readableState.endEmitted) err = new RequestAbortedError$3();
					if (abort$1 && err) abort$1();
					util$7.destroy(body, err);
					util$7.destroy(req, err);
					util$7.destroy(res, err);
					removeSignal$2(this);
					callback(err);
				}
			}).on("prefinish", () => {
				const { req } = this;
				req.push(null);
			});
			this.res = null;
			addSignal$2(this, signal);
		}
		onConnect(abort$1, context) {
			const { ret, res } = this;
			assert$9(!res, "pipeline cannot be retried");
			if (ret.destroyed) throw new RequestAbortedError$3();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders(statusCode, rawHeaders, resume$1) {
			const { opaque, handler, context } = this;
			if (statusCode < 200) {
				if (this.onInfo) {
					const headers = this.responseHeaders === "raw" ? util$7.parseRawHeaders(rawHeaders) : util$7.parseHeaders(rawHeaders);
					this.onInfo({
						statusCode,
						headers
					});
				}
				return;
			}
			this.res = new PipelineResponse(resume$1);
			let body;
			try {
				this.handler = null;
				const headers = this.responseHeaders === "raw" ? util$7.parseRawHeaders(rawHeaders) : util$7.parseHeaders(rawHeaders);
				body = this.runInAsyncScope(handler, null, {
					statusCode,
					headers,
					opaque,
					body: this.res,
					context
				});
			} catch (err) {
				this.res.on("error", util$7.nop);
				throw err;
			}
			if (!body || typeof body.on !== "function") throw new InvalidReturnValueError("expected Readable");
			body.on("data", (chunk) => {
				const { ret, body: body$1 } = this;
				if (!ret.push(chunk) && body$1.pause) body$1.pause();
			}).on("error", (err) => {
				const { ret } = this;
				util$7.destroy(ret, err);
			}).on("end", () => {
				const { ret } = this;
				ret.push(null);
			}).on("close", () => {
				const { ret } = this;
				if (!ret._readableState.ended) util$7.destroy(ret, new RequestAbortedError$3());
			});
			this.body = body;
		}
		onData(chunk) {
			const { res } = this;
			return res.push(chunk);
		}
		onComplete(trailers) {
			const { res } = this;
			res.push(null);
		}
		onError(err) {
			const { ret } = this;
			this.handler = null;
			util$7.destroy(ret, err);
		}
	};
	function pipeline$1(opts, handler) {
		try {
			const pipelineHandler = new PipelineHandler(opts, handler);
			this.dispatch({
				...opts,
				body: pipelineHandler.req
			}, pipelineHandler);
			return pipelineHandler.ret;
		} catch (err) {
			return new PassThrough().destroy(err);
		}
	}
	module.exports = pipeline$1;
}));

//#endregion
//#region node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { InvalidArgumentError: InvalidArgumentError$8, RequestAbortedError: RequestAbortedError$2, SocketError: SocketError$1 } = require_errors();
	const { AsyncResource: AsyncResource$1 } = __require("async_hooks");
	const util$6 = require_util$6();
	const { addSignal: addSignal$1, removeSignal: removeSignal$1 } = require_abort_signal();
	const assert$8 = __require("assert");
	var UpgradeHandler = class extends AsyncResource$1 {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$8("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$8("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$8("signal must be an EventEmitter or EventTarget");
			super("UNDICI_UPGRADE");
			this.responseHeaders = responseHeaders || null;
			this.opaque = opaque || null;
			this.callback = callback;
			this.abort = null;
			this.context = null;
			addSignal$1(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$2();
			this.abort = abort$1;
			this.context = null;
		}
		onHeaders() {
			throw new SocketError$1("bad upgrade", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			assert$8.strictEqual(statusCode, 101);
			removeSignal$1(this);
			this.callback = null;
			const headers = this.responseHeaders === "raw" ? util$6.parseRawHeaders(rawHeaders) : util$6.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal$1(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function upgrade(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			upgrade.call(this, opts, (err, data$1) => {
				return err ? reject(err) : resolve(data$1);
			});
		});
		try {
			const upgradeHandler = new UpgradeHandler(opts, callback);
			this.dispatch({
				...opts,
				method: opts.method || "GET",
				upgrade: opts.protocol || "Websocket"
			}, upgradeHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = upgrade;
}));

//#endregion
//#region node_modules/undici/lib/api/api-connect.js
var require_api_connect = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { AsyncResource } = __require("async_hooks");
	const { InvalidArgumentError: InvalidArgumentError$7, RequestAbortedError: RequestAbortedError$1, SocketError } = require_errors();
	const util$5 = require_util$6();
	const { addSignal, removeSignal } = require_abort_signal();
	var ConnectHandler = class extends AsyncResource {
		constructor(opts, callback) {
			if (!opts || typeof opts !== "object") throw new InvalidArgumentError$7("invalid opts");
			if (typeof callback !== "function") throw new InvalidArgumentError$7("invalid callback");
			const { signal, opaque, responseHeaders } = opts;
			if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") throw new InvalidArgumentError$7("signal must be an EventEmitter or EventTarget");
			super("UNDICI_CONNECT");
			this.opaque = opaque || null;
			this.responseHeaders = responseHeaders || null;
			this.callback = callback;
			this.abort = null;
			addSignal(this, signal);
		}
		onConnect(abort$1, context) {
			if (!this.callback) throw new RequestAbortedError$1();
			this.abort = abort$1;
			this.context = context;
		}
		onHeaders() {
			throw new SocketError("bad connect", null);
		}
		onUpgrade(statusCode, rawHeaders, socket) {
			const { callback, opaque, context } = this;
			removeSignal(this);
			this.callback = null;
			let headers = rawHeaders;
			if (headers != null) headers = this.responseHeaders === "raw" ? util$5.parseRawHeaders(rawHeaders) : util$5.parseHeaders(rawHeaders);
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers,
				socket,
				opaque,
				context
			});
		}
		onError(err) {
			const { callback, opaque } = this;
			removeSignal(this);
			if (callback) {
				this.callback = null;
				queueMicrotask(() => {
					this.runInAsyncScope(callback, null, err, { opaque });
				});
			}
		}
	};
	function connect(opts, callback) {
		if (callback === void 0) return new Promise((resolve, reject) => {
			connect.call(this, opts, (err, data$1) => {
				return err ? reject(err) : resolve(data$1);
			});
		});
		try {
			const connectHandler = new ConnectHandler(opts, callback);
			this.dispatch({
				...opts,
				method: "CONNECT"
			}, connectHandler);
		} catch (err) {
			if (typeof callback !== "function") throw err;
			const opaque = opts && opts.opaque;
			queueMicrotask(() => callback(err, { opaque }));
		}
	}
	module.exports = connect;
}));

//#endregion
//#region node_modules/undici/lib/api/index.js
var require_api = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports.request = require_api_request();
	module.exports.stream = require_api_stream();
	module.exports.pipeline = require_api_pipeline();
	module.exports.upgrade = require_api_upgrade();
	module.exports.connect = require_api_connect();
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { UndiciError: UndiciError$1 } = require_errors();
	var MockNotMatchedError$1 = class MockNotMatchedError$1 extends UndiciError$1 {
		constructor(message) {
			super(message);
			Error.captureStackTrace(this, MockNotMatchedError$1);
			this.name = "MockNotMatchedError";
			this.message = message || "The request does not match any registered mock dispatches";
			this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
		}
	};
	module.exports = { MockNotMatchedError: MockNotMatchedError$1 };
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kAgent: Symbol("agent"),
		kOptions: Symbol("options"),
		kFactory: Symbol("factory"),
		kDispatches: Symbol("dispatches"),
		kDispatchKey: Symbol("dispatch key"),
		kDefaultHeaders: Symbol("default headers"),
		kDefaultTrailers: Symbol("default trailers"),
		kContentLength: Symbol("content length"),
		kMockAgent: Symbol("mock agent"),
		kMockAgentSet: Symbol("mock agent set"),
		kMockAgentGet: Symbol("mock agent get"),
		kMockDispatch: Symbol("mock dispatch"),
		kClose: Symbol("close"),
		kOriginalClose: Symbol("original agent close"),
		kOrigin: Symbol("origin"),
		kIsMockActive: Symbol("is mock active"),
		kNetConnect: Symbol("net connect"),
		kGetNetConnect: Symbol("get net connect"),
		kConnected: Symbol("connected")
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { MockNotMatchedError } = require_mock_errors();
	const { kDispatches: kDispatches$4, kMockAgent: kMockAgent$2, kOriginalDispatch: kOriginalDispatch$2, kOrigin: kOrigin$2, kGetNetConnect: kGetNetConnect$1 } = require_mock_symbols();
	const { buildURL: buildURL$1, nop } = require_util$6();
	const { STATUS_CODES: STATUS_CODES$1 } = __require("http");
	const { types: { isPromise } } = __require("util");
	function matchValue$1(match, value) {
		if (typeof match === "string") return match === value;
		if (match instanceof RegExp) return match.test(value);
		if (typeof match === "function") return match(value) === true;
		return false;
	}
	function lowerCaseEntries(headers) {
		return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
			return [headerName.toLocaleLowerCase(), headerValue];
		}));
	}
	/**
	* @param {import('../../index').Headers|string[]|Record<string, string>} headers
	* @param {string} key
	*/
	function getHeaderByName(headers, key) {
		if (Array.isArray(headers)) {
			for (let i$5 = 0; i$5 < headers.length; i$5 += 2) if (headers[i$5].toLocaleLowerCase() === key.toLocaleLowerCase()) return headers[i$5 + 1];
			return;
		} else if (typeof headers.get === "function") return headers.get(key);
		else return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
	}
	/** @param {string[]} headers */
	function buildHeadersFromArray(headers) {
		const clone = headers.slice();
		const entries = [];
		for (let index = 0; index < clone.length; index += 2) entries.push([clone[index], clone[index + 1]]);
		return Object.fromEntries(entries);
	}
	function matchHeaders(mockDispatch$1, headers) {
		if (typeof mockDispatch$1.headers === "function") {
			if (Array.isArray(headers)) headers = buildHeadersFromArray(headers);
			return mockDispatch$1.headers(headers ? lowerCaseEntries(headers) : {});
		}
		if (typeof mockDispatch$1.headers === "undefined") return true;
		if (typeof headers !== "object" || typeof mockDispatch$1.headers !== "object") return false;
		for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch$1.headers)) if (!matchValue$1(matchHeaderValue, getHeaderByName(headers, matchHeaderName))) return false;
		return true;
	}
	function safeUrl(path$6) {
		if (typeof path$6 !== "string") return path$6;
		const pathSegments = path$6.split("?");
		if (pathSegments.length !== 2) return path$6;
		const qp = new URLSearchParams(pathSegments.pop());
		qp.sort();
		return [...pathSegments, qp.toString()].join("?");
	}
	function matchKey(mockDispatch$1, { path: path$6, method, body, headers }) {
		const pathMatch = matchValue$1(mockDispatch$1.path, path$6);
		const methodMatch = matchValue$1(mockDispatch$1.method, method);
		const bodyMatch = typeof mockDispatch$1.body !== "undefined" ? matchValue$1(mockDispatch$1.body, body) : true;
		const headersMatch = matchHeaders(mockDispatch$1, headers);
		return pathMatch && methodMatch && bodyMatch && headersMatch;
	}
	function getResponseData$1(data$1) {
		if (Buffer.isBuffer(data$1)) return data$1;
		else if (typeof data$1 === "object") return JSON.stringify(data$1);
		else return data$1.toString();
	}
	function getMockDispatch(mockDispatches, key) {
		const basePath = key.query ? buildURL$1(key.path, key.query) : key.path;
		const resolvedPath$1 = typeof basePath === "string" ? safeUrl(basePath) : basePath;
		let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path: path$6 }) => matchValue$1(safeUrl(path$6), resolvedPath$1));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath$1}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue$1(method, key.method));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
		matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue$1(body, key.body) : true);
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
		matchedMockDispatches = matchedMockDispatches.filter((mockDispatch$1) => matchHeaders(mockDispatch$1, key.headers));
		if (matchedMockDispatches.length === 0) throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
		return matchedMockDispatches[0];
	}
	function addMockDispatch$1(mockDispatches, key, data$1) {
		const baseData = {
			timesInvoked: 0,
			times: 1,
			persist: false,
			consumed: false
		};
		const replyData = typeof data$1 === "function" ? { callback: data$1 } : { ...data$1 };
		const newMockDispatch = {
			...baseData,
			...key,
			pending: true,
			data: {
				error: null,
				...replyData
			}
		};
		mockDispatches.push(newMockDispatch);
		return newMockDispatch;
	}
	function deleteMockDispatch(mockDispatches, key) {
		const index = mockDispatches.findIndex((dispatch) => {
			if (!dispatch.consumed) return false;
			return matchKey(dispatch, key);
		});
		if (index !== -1) mockDispatches.splice(index, 1);
	}
	function buildKey$1(opts) {
		const { path: path$6, method, body, headers, query } = opts;
		return {
			path: path$6,
			method,
			body,
			headers,
			query
		};
	}
	function generateKeyValues(data$1) {
		return Object.entries(data$1).reduce((keyValuePairs, [key, value]) => [
			...keyValuePairs,
			Buffer.from(`${key}`),
			Array.isArray(value) ? value.map((x$5) => Buffer.from(`${x$5}`)) : Buffer.from(`${value}`)
		], []);
	}
	/**
	* @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
	* @param {number} statusCode
	*/
	function getStatusText(statusCode) {
		return STATUS_CODES$1[statusCode] || "unknown";
	}
	async function getResponse(body) {
		const buffers = [];
		for await (const data$1 of body) buffers.push(data$1);
		return Buffer.concat(buffers).toString("utf8");
	}
	/**
	* Mock dispatch function used to simulate undici dispatches
	*/
	function mockDispatch(opts, handler) {
		const key = buildKey$1(opts);
		const mockDispatch$1 = getMockDispatch(this[kDispatches$4], key);
		mockDispatch$1.timesInvoked++;
		if (mockDispatch$1.data.callback) mockDispatch$1.data = {
			...mockDispatch$1.data,
			...mockDispatch$1.data.callback(opts)
		};
		const { data: { statusCode, data: data$1, headers, trailers, error: error$2 }, delay, persist } = mockDispatch$1;
		const { timesInvoked, times } = mockDispatch$1;
		mockDispatch$1.consumed = !persist && timesInvoked >= times;
		mockDispatch$1.pending = timesInvoked < times;
		if (error$2 !== null) {
			deleteMockDispatch(this[kDispatches$4], key);
			handler.onError(error$2);
			return true;
		}
		if (typeof delay === "number" && delay > 0) setTimeout(() => {
			handleReply(this[kDispatches$4]);
		}, delay);
		else handleReply(this[kDispatches$4]);
		function handleReply(mockDispatches, _data$5 = data$1) {
			const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
			const body = typeof _data$5 === "function" ? _data$5({
				...opts,
				headers: optsHeaders
			}) : _data$5;
			if (isPromise(body)) {
				body.then((newData) => handleReply(mockDispatches, newData));
				return;
			}
			const responseData = getResponseData$1(body);
			const responseHeaders = generateKeyValues(headers);
			const responseTrailers = generateKeyValues(trailers);
			handler.abort = nop;
			handler.onHeaders(statusCode, responseHeaders, resume$1, getStatusText(statusCode));
			handler.onData(Buffer.from(responseData));
			handler.onComplete(responseTrailers);
			deleteMockDispatch(mockDispatches, key);
		}
		function resume$1() {}
		return true;
	}
	function buildMockDispatch$2() {
		const agent = this[kMockAgent$2];
		const origin = this[kOrigin$2];
		const originalDispatch = this[kOriginalDispatch$2];
		return function dispatch(opts, handler) {
			if (agent.isMockActive) try {
				mockDispatch.call(this, opts, handler);
			} catch (error$2) {
				if (error$2 instanceof MockNotMatchedError) {
					const netConnect = agent[kGetNetConnect$1]();
					if (netConnect === false) throw new MockNotMatchedError(`${error$2.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
					if (checkNetConnect(netConnect, origin)) originalDispatch.call(this, opts, handler);
					else throw new MockNotMatchedError(`${error$2.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
				} else throw error$2;
			}
			else originalDispatch.call(this, opts, handler);
		};
	}
	function checkNetConnect(netConnect, origin) {
		const url$1 = new URL(origin);
		if (netConnect === true) return true;
		else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue$1(matcher, url$1.host))) return true;
		return false;
	}
	function buildMockOptions$1(opts) {
		if (opts) {
			const { agent, ...mockOptions } = opts;
			return mockOptions;
		}
	}
	module.exports = {
		getResponseData: getResponseData$1,
		getMockDispatch,
		addMockDispatch: addMockDispatch$1,
		deleteMockDispatch,
		buildKey: buildKey$1,
		generateKeyValues,
		matchValue: matchValue$1,
		getResponse,
		getStatusText,
		mockDispatch,
		buildMockDispatch: buildMockDispatch$2,
		checkNetConnect,
		buildMockOptions: buildMockOptions$1,
		getHeaderByName
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$3, kDispatchKey, kDefaultHeaders, kDefaultTrailers, kContentLength, kMockDispatch } = require_mock_symbols();
	const { InvalidArgumentError: InvalidArgumentError$6 } = require_errors();
	const { buildURL } = require_util$6();
	/**
	* Defines the scope API for an interceptor reply
	*/
	var MockScope = class {
		constructor(mockDispatch$1) {
			this[kMockDispatch] = mockDispatch$1;
		}
		/**
		* Delay a reply by a set amount in ms.
		*/
		delay(waitInMs) {
			if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) throw new InvalidArgumentError$6("waitInMs must be a valid integer > 0");
			this[kMockDispatch].delay = waitInMs;
			return this;
		}
		/**
		* For a defined reply, never mark as consumed.
		*/
		persist() {
			this[kMockDispatch].persist = true;
			return this;
		}
		/**
		* Allow one to define a reply for a set amount of matching requests.
		*/
		times(repeatTimes) {
			if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) throw new InvalidArgumentError$6("repeatTimes must be a valid integer > 0");
			this[kMockDispatch].times = repeatTimes;
			return this;
		}
	};
	/**
	* Defines an interceptor for a Mock
	*/
	var MockInterceptor$2 = class {
		constructor(opts, mockDispatches) {
			if (typeof opts !== "object") throw new InvalidArgumentError$6("opts must be an object");
			if (typeof opts.path === "undefined") throw new InvalidArgumentError$6("opts.path must be defined");
			if (typeof opts.method === "undefined") opts.method = "GET";
			if (typeof opts.path === "string") if (opts.query) opts.path = buildURL(opts.path, opts.query);
			else {
				const parsedURL = new URL(opts.path, "data://");
				opts.path = parsedURL.pathname + parsedURL.search;
			}
			if (typeof opts.method === "string") opts.method = opts.method.toUpperCase();
			this[kDispatchKey] = buildKey(opts);
			this[kDispatches$3] = mockDispatches;
			this[kDefaultHeaders] = {};
			this[kDefaultTrailers] = {};
			this[kContentLength] = false;
		}
		createMockScopeDispatchData(statusCode, data$1, responseOptions = {}) {
			const responseData = getResponseData(data$1);
			const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
			return {
				statusCode,
				data: data$1,
				headers: {
					...this[kDefaultHeaders],
					...contentLength,
					...responseOptions.headers
				},
				trailers: {
					...this[kDefaultTrailers],
					...responseOptions.trailers
				}
			};
		}
		validateReplyParameters(statusCode, data$1, responseOptions) {
			if (typeof statusCode === "undefined") throw new InvalidArgumentError$6("statusCode must be defined");
			if (typeof data$1 === "undefined") throw new InvalidArgumentError$6("data must be defined");
			if (typeof responseOptions !== "object") throw new InvalidArgumentError$6("responseOptions must be an object");
		}
		/**
		* Mock an undici request with a defined reply.
		*/
		reply(replyData) {
			if (typeof replyData === "function") {
				const wrappedDefaultsCallback = (opts) => {
					const resolvedData = replyData(opts);
					if (typeof resolvedData !== "object") throw new InvalidArgumentError$6("reply options callback must return an object");
					const { statusCode: statusCode$1, data: data$2 = "", responseOptions: responseOptions$1 = {} } = resolvedData;
					this.validateReplyParameters(statusCode$1, data$2, responseOptions$1);
					return { ...this.createMockScopeDispatchData(statusCode$1, data$2, responseOptions$1) };
				};
				return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], wrappedDefaultsCallback));
			}
			const [statusCode, data$1 = "", responseOptions = {}] = [...arguments];
			this.validateReplyParameters(statusCode, data$1, responseOptions);
			const dispatchData = this.createMockScopeDispatchData(statusCode, data$1, responseOptions);
			return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], dispatchData));
		}
		/**
		* Mock an undici request with a defined error.
		*/
		replyWithError(error$2) {
			if (typeof error$2 === "undefined") throw new InvalidArgumentError$6("error must be defined");
			return new MockScope(addMockDispatch(this[kDispatches$3], this[kDispatchKey], { error: error$2 }));
		}
		/**
		* Set default reply headers on the interceptor for subsequent replies
		*/
		defaultReplyHeaders(headers) {
			if (typeof headers === "undefined") throw new InvalidArgumentError$6("headers must be defined");
			this[kDefaultHeaders] = headers;
			return this;
		}
		/**
		* Set default reply trailers on the interceptor for subsequent replies
		*/
		defaultReplyTrailers(trailers) {
			if (typeof trailers === "undefined") throw new InvalidArgumentError$6("trailers must be defined");
			this[kDefaultTrailers] = trailers;
			return this;
		}
		/**
		* Set reply content length header for replies on the interceptor
		*/
		replyContentLength() {
			this[kContentLength] = true;
			return this;
		}
	};
	module.exports.MockInterceptor = MockInterceptor$2;
	module.exports.MockScope = MockScope;
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-client.js
var require_mock_client = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { promisify: promisify$1 } = __require("util");
	const Client$2 = require_client();
	const { buildMockDispatch: buildMockDispatch$1 } = require_mock_utils();
	const { kDispatches: kDispatches$2, kMockAgent: kMockAgent$1, kClose: kClose$2, kOriginalClose: kOriginalClose$1, kOrigin: kOrigin$1, kOriginalDispatch: kOriginalDispatch$1, kConnected: kConnected$1 } = require_mock_symbols();
	const { MockInterceptor: MockInterceptor$1 } = require_mock_interceptor();
	const Symbols$1 = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$5 } = require_errors();
	/**
	* MockClient provides an API that extends the Client to influence the mockDispatches.
	*/
	var MockClient$2 = class extends Client$2 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$5("Argument opts.agent must implement Agent");
			this[kMockAgent$1] = opts.agent;
			this[kOrigin$1] = origin;
			this[kDispatches$2] = [];
			this[kConnected$1] = 1;
			this[kOriginalDispatch$1] = this.dispatch;
			this[kOriginalClose$1] = this.close.bind(this);
			this.dispatch = buildMockDispatch$1.call(this);
			this.close = this[kClose$2];
		}
		get [Symbols$1.kConnected]() {
			return this[kConnected$1];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor$1(opts, this[kDispatches$2]);
		}
		async [kClose$2]() {
			await promisify$1(this[kOriginalClose$1])();
			this[kConnected$1] = 0;
			this[kMockAgent$1][Symbols$1.kClients].delete(this[kOrigin$1]);
		}
	};
	module.exports = MockClient$2;
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { promisify } = __require("util");
	const Pool$2 = require_pool();
	const { buildMockDispatch } = require_mock_utils();
	const { kDispatches: kDispatches$1, kMockAgent, kClose: kClose$1, kOriginalClose, kOrigin, kOriginalDispatch, kConnected } = require_mock_symbols();
	const { MockInterceptor } = require_mock_interceptor();
	const Symbols = require_symbols$4();
	const { InvalidArgumentError: InvalidArgumentError$4 } = require_errors();
	/**
	* MockPool provides an API that extends the Pool to influence the mockDispatches.
	*/
	var MockPool$2 = class extends Pool$2 {
		constructor(origin, opts) {
			super(origin, opts);
			if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$4("Argument opts.agent must implement Agent");
			this[kMockAgent] = opts.agent;
			this[kOrigin] = origin;
			this[kDispatches$1] = [];
			this[kConnected] = 1;
			this[kOriginalDispatch] = this.dispatch;
			this[kOriginalClose] = this.close.bind(this);
			this.dispatch = buildMockDispatch.call(this);
			this.close = this[kClose$1];
		}
		get [Symbols.kConnected]() {
			return this[kConnected];
		}
		/**
		* Sets up the base interceptor for mocking replies from undici.
		*/
		intercept(opts) {
			return new MockInterceptor(opts, this[kDispatches$1]);
		}
		async [kClose$1]() {
			await promisify(this[kOriginalClose])();
			this[kConnected] = 0;
			this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
		}
	};
	module.exports = MockPool$2;
}));

//#endregion
//#region node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const singulars = {
		pronoun: "it",
		is: "is",
		was: "was",
		this: "this"
	};
	const plurals = {
		pronoun: "they",
		is: "are",
		was: "were",
		this: "these"
	};
	module.exports = class Pluralizer$1 {
		constructor(singular, plural) {
			this.singular = singular;
			this.plural = plural;
		}
		pluralize(count) {
			const one = count === 1;
			const keys = one ? singulars : plurals;
			const noun = one ? this.singular : this.plural;
			return {
				...keys,
				count,
				noun
			};
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Transform } = __require("stream");
	const { Console } = __require("console");
	/**
	* Gets the output of `console.table()` as a string.
	*/
	module.exports = class PendingInterceptorsFormatter$1 {
		constructor({ disableColors } = {}) {
			this.transform = new Transform({ transform(chunk, _enc, cb) {
				cb(null, chunk);
			} });
			this.logger = new Console({
				stdout: this.transform,
				inspectOptions: { colors: !disableColors && !process.env.CI }
			});
		}
		format(pendingInterceptors) {
			const withPrettyHeaders = pendingInterceptors.map(({ method, path: path$6, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
				Method: method,
				Origin: origin,
				Path: path$6,
				"Status code": statusCode,
				Persistent: persist ? "" : "",
				Invocations: timesInvoked,
				Remaining: persist ? Infinity : times - timesInvoked
			}));
			this.logger.table(withPrettyHeaders);
			return this.transform.read().toString();
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kClients } = require_symbols$4();
	const Agent$3 = require_agent();
	const { kAgent: kAgent$1, kMockAgentSet, kMockAgentGet, kDispatches, kIsMockActive, kNetConnect, kGetNetConnect, kOptions, kFactory } = require_mock_symbols();
	const MockClient$1 = require_mock_client();
	const MockPool$1 = require_mock_pool();
	const { matchValue, buildMockOptions } = require_mock_utils();
	const { InvalidArgumentError: InvalidArgumentError$3, UndiciError } = require_errors();
	const Dispatcher$1 = require_dispatcher();
	const Pluralizer = require_pluralizer();
	const PendingInterceptorsFormatter = require_pending_interceptors_formatter();
	var FakeWeakRef = class {
		constructor(value) {
			this.value = value;
		}
		deref() {
			return this.value;
		}
	};
	var MockAgent$1 = class extends Dispatcher$1 {
		constructor(opts) {
			super(opts);
			this[kNetConnect] = true;
			this[kIsMockActive] = true;
			if (opts && opts.agent && typeof opts.agent.dispatch !== "function") throw new InvalidArgumentError$3("Argument opts.agent must implement Agent");
			const agent = opts && opts.agent ? opts.agent : new Agent$3(opts);
			this[kAgent$1] = agent;
			this[kClients] = agent[kClients];
			this[kOptions] = buildMockOptions(opts);
		}
		get(origin) {
			let dispatcher = this[kMockAgentGet](origin);
			if (!dispatcher) {
				dispatcher = this[kFactory](origin);
				this[kMockAgentSet](origin, dispatcher);
			}
			return dispatcher;
		}
		dispatch(opts, handler) {
			this.get(opts.origin);
			return this[kAgent$1].dispatch(opts, handler);
		}
		async close() {
			await this[kAgent$1].close();
			this[kClients].clear();
		}
		deactivate() {
			this[kIsMockActive] = false;
		}
		activate() {
			this[kIsMockActive] = true;
		}
		enableNetConnect(matcher) {
			if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) if (Array.isArray(this[kNetConnect])) this[kNetConnect].push(matcher);
			else this[kNetConnect] = [matcher];
			else if (typeof matcher === "undefined") this[kNetConnect] = true;
			else throw new InvalidArgumentError$3("Unsupported matcher. Must be one of String|Function|RegExp.");
		}
		disableNetConnect() {
			this[kNetConnect] = false;
		}
		get isMockActive() {
			return this[kIsMockActive];
		}
		[kMockAgentSet](origin, dispatcher) {
			this[kClients].set(origin, new FakeWeakRef(dispatcher));
		}
		[kFactory](origin) {
			const mockOptions = Object.assign({ agent: this }, this[kOptions]);
			return this[kOptions] && this[kOptions].connections === 1 ? new MockClient$1(origin, mockOptions) : new MockPool$1(origin, mockOptions);
		}
		[kMockAgentGet](origin) {
			const ref = this[kClients].get(origin);
			if (ref) return ref.deref();
			if (typeof origin !== "string") {
				const dispatcher = this[kFactory]("http://localhost:9999");
				this[kMockAgentSet](origin, dispatcher);
				return dispatcher;
			}
			for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
				const nonExplicitDispatcher = nonExplicitRef.deref();
				if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
					const dispatcher = this[kFactory](origin);
					this[kMockAgentSet](origin, dispatcher);
					dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
					return dispatcher;
				}
			}
		}
		[kGetNetConnect]() {
			return this[kNetConnect];
		}
		pendingInterceptors() {
			const mockAgentClients = this[kClients];
			return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({
				...dispatch,
				origin
			}))).filter(({ pending }) => pending);
		}
		assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
			const pending = this.pendingInterceptors();
			if (pending.length === 0) return;
			const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
			throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
		}
	};
	module.exports = MockAgent$1;
}));

//#endregion
//#region node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kProxy, kClose, kDestroy, kInterceptors } = require_symbols$4();
	const { URL: URL$1 } = __require("url");
	const Agent$2 = require_agent();
	const Pool$1 = require_pool();
	const DispatcherBase = require_dispatcher_base();
	const { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError } = require_errors();
	const buildConnector$1 = require_connect();
	const kAgent = Symbol("proxy agent");
	const kClient = Symbol("proxy client");
	const kProxyHeaders = Symbol("proxy headers");
	const kRequestTls = Symbol("request tls settings");
	const kProxyTls = Symbol("proxy tls settings");
	const kConnectEndpoint = Symbol("connect endpoint function");
	function defaultProtocolPort(protocol) {
		return protocol === "https:" ? 443 : 80;
	}
	function buildProxyOptions(opts) {
		if (typeof opts === "string") opts = { uri: opts };
		if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
		return {
			uri: opts.uri,
			protocol: opts.protocol || "https"
		};
	}
	function defaultFactory(origin, opts) {
		return new Pool$1(origin, opts);
	}
	var ProxyAgent$1 = class extends DispatcherBase {
		constructor(opts) {
			super(opts);
			this[kProxy] = buildProxyOptions(opts);
			this[kAgent] = new Agent$2(opts);
			this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
			if (typeof opts === "string") opts = { uri: opts };
			if (!opts || !opts.uri) throw new InvalidArgumentError$2("Proxy opts.uri is mandatory");
			const { clientFactory = defaultFactory } = opts;
			if (typeof clientFactory !== "function") throw new InvalidArgumentError$2("Proxy opts.clientFactory must be a function.");
			this[kRequestTls] = opts.requestTls;
			this[kProxyTls] = opts.proxyTls;
			this[kProxyHeaders] = opts.headers || {};
			const resolvedUrl = new URL$1(opts.uri);
			const { origin, port, host, username, password } = resolvedUrl;
			if (opts.auth && opts.token) throw new InvalidArgumentError$2("opts.auth cannot be used in combination with opts.token");
			else if (opts.auth) this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
			else if (opts.token) this[kProxyHeaders]["proxy-authorization"] = opts.token;
			else if (username && password) this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
			const connect$2 = buildConnector$1({ ...opts.proxyTls });
			this[kConnectEndpoint] = buildConnector$1({ ...opts.requestTls });
			this[kClient] = clientFactory(resolvedUrl, { connect: connect$2 });
			this[kAgent] = new Agent$2({
				...opts,
				connect: async (opts$1, callback) => {
					let requestedHost = opts$1.host;
					if (!opts$1.port) requestedHost += `:${defaultProtocolPort(opts$1.protocol)}`;
					try {
						const { socket, statusCode } = await this[kClient].connect({
							origin,
							port,
							path: requestedHost,
							signal: opts$1.signal,
							headers: {
								...this[kProxyHeaders],
								host
							}
						});
						if (statusCode !== 200) {
							socket.on("error", () => {}).destroy();
							callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
						}
						if (opts$1.protocol !== "https:") {
							callback(null, socket);
							return;
						}
						let servername;
						if (this[kRequestTls]) servername = this[kRequestTls].servername;
						else servername = opts$1.servername;
						this[kConnectEndpoint]({
							...opts$1,
							servername,
							httpSocket: socket
						}, callback);
					} catch (err) {
						callback(err);
					}
				}
			});
		}
		dispatch(opts, handler) {
			const { host } = new URL$1(opts.origin);
			const headers = buildHeaders(opts.headers);
			throwIfProxyAuthIsSent(headers);
			return this[kAgent].dispatch({
				...opts,
				headers: {
					...headers,
					host
				}
			}, handler);
		}
		async [kClose]() {
			await this[kAgent].close();
			await this[kClient].close();
		}
		async [kDestroy]() {
			await this[kAgent].destroy();
			await this[kClient].destroy();
		}
	};
	/**
	* @param {string[] | Record<string, string>} headers
	* @returns {Record<string, string>}
	*/
	function buildHeaders(headers) {
		if (Array.isArray(headers)) {
			/** @type {Record<string, string>} */
			const headersPair = {};
			for (let i$5 = 0; i$5 < headers.length; i$5 += 2) headersPair[headers[i$5]] = headers[i$5 + 1];
			return headersPair;
		}
		return headers;
	}
	/**
	* @param {Record<string, string>} headers
	*
	* Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
	* Nevertheless, it was changed and to avoid a security vulnerability by end users
	* this check was created.
	* It should be removed in the next major version for performance reasons
	*/
	function throwIfProxyAuthIsSent(headers) {
		if (headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization")) throw new InvalidArgumentError$2("Proxy-Authorization should be sent in ProxyAgent constructor");
	}
	module.exports = ProxyAgent$1;
}));

//#endregion
//#region node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$7 = __require("assert");
	const { kRetryHandlerDefaultRetry } = require_symbols$4();
	const { RequestRetryError } = require_errors();
	const { isDisturbed: isDisturbed$1, parseHeaders, parseRangeHeader } = require_util$6();
	function calculateRetryAfterHeader(retryAfter) {
		const current = Date.now();
		return new Date(retryAfter).getTime() - current;
	}
	var RetryHandler$1 = class RetryHandler$1 {
		constructor(opts, handlers) {
			const { retryOptions, ...dispatchOpts } = opts;
			const { retry: retryFn, maxRetries, maxTimeout, minTimeout, timeoutFactor, methods, errorCodes, retryAfter, statusCodes } = retryOptions ?? {};
			this.dispatch = handlers.dispatch;
			this.handler = handlers.handler;
			this.opts = dispatchOpts;
			this.abort = null;
			this.aborted = false;
			this.retryOpts = {
				retry: retryFn ?? RetryHandler$1[kRetryHandlerDefaultRetry],
				retryAfter: retryAfter ?? true,
				maxTimeout: maxTimeout ?? 30 * 1e3,
				timeout: minTimeout ?? 500,
				timeoutFactor: timeoutFactor ?? 2,
				maxRetries: maxRetries ?? 5,
				methods: methods ?? [
					"GET",
					"HEAD",
					"OPTIONS",
					"PUT",
					"DELETE",
					"TRACE"
				],
				statusCodes: statusCodes ?? [
					500,
					502,
					503,
					504,
					429
				],
				errorCodes: errorCodes ?? [
					"ECONNRESET",
					"ECONNREFUSED",
					"ENOTFOUND",
					"ENETDOWN",
					"ENETUNREACH",
					"EHOSTDOWN",
					"EHOSTUNREACH",
					"EPIPE"
				]
			};
			this.retryCount = 0;
			this.start = 0;
			this.end = null;
			this.etag = null;
			this.resume = null;
			this.handler.onConnect((reason) => {
				this.aborted = true;
				if (this.abort) this.abort(reason);
				else this.reason = reason;
			});
		}
		onRequestSent() {
			if (this.handler.onRequestSent) this.handler.onRequestSent();
		}
		onUpgrade(statusCode, headers, socket) {
			if (this.handler.onUpgrade) this.handler.onUpgrade(statusCode, headers, socket);
		}
		onConnect(abort$1) {
			if (this.aborted) abort$1(this.reason);
			else this.abort = abort$1;
		}
		onBodySent(chunk) {
			if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
		}
		static [kRetryHandlerDefaultRetry](err, { state: state$1, opts }, cb) {
			const { statusCode, code, headers } = err;
			const { method, retryOptions } = opts;
			const { maxRetries, timeout, maxTimeout, timeoutFactor, statusCodes, errorCodes, methods } = retryOptions;
			let { counter, currentTimeout } = state$1;
			currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
			if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
				cb(err);
				return;
			}
			if (Array.isArray(methods) && !methods.includes(method)) {
				cb(err);
				return;
			}
			if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
				cb(err);
				return;
			}
			if (counter > maxRetries) {
				cb(err);
				return;
			}
			let retryAfterHeader = headers != null && headers["retry-after"];
			if (retryAfterHeader) {
				retryAfterHeader = Number(retryAfterHeader);
				retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
			}
			const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
			state$1.currentTimeout = retryTimeout;
			setTimeout(() => cb(null), retryTimeout);
		}
		onHeaders(statusCode, rawHeaders, resume$1, statusMessage) {
			const headers = parseHeaders(rawHeaders);
			this.retryCount += 1;
			if (statusCode >= 300) {
				this.abort(new RequestRetryError("Request failed", statusCode, {
					headers,
					count: this.retryCount
				}));
				return false;
			}
			if (this.resume != null) {
				this.resume = null;
				if (statusCode !== 206) return true;
				const contentRange = parseRangeHeader(headers["content-range"]);
				if (!contentRange) {
					this.abort(new RequestRetryError("Content-Range mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				if (this.etag != null && this.etag !== headers.etag) {
					this.abort(new RequestRetryError("ETag mismatch", statusCode, {
						headers,
						count: this.retryCount
					}));
					return false;
				}
				const { start, size, end = size } = contentRange;
				assert$7(this.start === start, "content-range mismatch");
				assert$7(this.end == null || this.end === end, "content-range mismatch");
				this.resume = resume$1;
				return true;
			}
			if (this.end == null) {
				if (statusCode === 206) {
					const range$1 = parseRangeHeader(headers["content-range"]);
					if (range$1 == null) return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
					const { start, size, end = size } = range$1;
					assert$7(start != null && Number.isFinite(start) && this.start !== start, "content-range mismatch");
					assert$7(Number.isFinite(start));
					assert$7(end != null && Number.isFinite(end) && this.end !== end, "invalid content-length");
					this.start = start;
					this.end = end;
				}
				if (this.end == null) {
					const contentLength = headers["content-length"];
					this.end = contentLength != null ? Number(contentLength) : null;
				}
				assert$7(Number.isFinite(this.start));
				assert$7(this.end == null || Number.isFinite(this.end), "invalid content-length");
				this.resume = resume$1;
				this.etag = headers.etag != null ? headers.etag : null;
				return this.handler.onHeaders(statusCode, rawHeaders, resume$1, statusMessage);
			}
			const err = new RequestRetryError("Request failed", statusCode, {
				headers,
				count: this.retryCount
			});
			this.abort(err);
			return false;
		}
		onData(chunk) {
			this.start += chunk.length;
			return this.handler.onData(chunk);
		}
		onComplete(rawTrailers) {
			this.retryCount = 0;
			return this.handler.onComplete(rawTrailers);
		}
		onError(err) {
			if (this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err);
			this.retryOpts.retry(err, {
				state: {
					counter: this.retryCount++,
					currentTimeout: this.retryAfter
				},
				opts: {
					retryOptions: this.retryOpts,
					...this.opts
				}
			}, onRetry.bind(this));
			function onRetry(err$1) {
				if (err$1 != null || this.aborted || isDisturbed$1(this.opts.body)) return this.handler.onError(err$1);
				if (this.start !== 0) this.opts = {
					...this.opts,
					headers: {
						...this.opts.headers,
						range: `bytes=${this.start}-${this.end ?? ""}`
					}
				};
				try {
					this.dispatch(this.opts, this);
				} catch (err$2) {
					this.handler.onError(err$2);
				}
			}
		}
	};
	module.exports = RetryHandler$1;
}));

//#endregion
//#region node_modules/undici/lib/global.js
var require_global = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const globalDispatcher = Symbol.for("undici.globalDispatcher.1");
	const { InvalidArgumentError: InvalidArgumentError$1 } = require_errors();
	const Agent$1 = require_agent();
	if (getGlobalDispatcher$5() === void 0) setGlobalDispatcher$1(new Agent$1());
	function setGlobalDispatcher$1(agent) {
		if (!agent || typeof agent.dispatch !== "function") throw new InvalidArgumentError$1("Argument agent must implement Agent");
		Object.defineProperty(globalThis, globalDispatcher, {
			value: agent,
			writable: true,
			enumerable: false,
			configurable: false
		});
	}
	function getGlobalDispatcher$5() {
		return globalThis[globalDispatcher];
	}
	module.exports = {
		setGlobalDispatcher: setGlobalDispatcher$1,
		getGlobalDispatcher: getGlobalDispatcher$5
	};
}));

//#endregion
//#region node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = class DecoratorHandler$1 {
		constructor(handler) {
			this.handler = handler;
		}
		onConnect(...args) {
			return this.handler.onConnect(...args);
		}
		onError(...args) {
			return this.handler.onError(...args);
		}
		onUpgrade(...args) {
			return this.handler.onUpgrade(...args);
		}
		onHeaders(...args) {
			return this.handler.onHeaders(...args);
		}
		onData(...args) {
			return this.handler.onData(...args);
		}
		onComplete(...args) {
			return this.handler.onComplete(...args);
		}
		onBodySent(...args) {
			return this.handler.onBodySent(...args);
		}
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/headers.js
var require_headers = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kHeadersList: kHeadersList$5, kConstruct: kConstruct$4 } = require_symbols$4();
	const { kGuard: kGuard$4 } = require_symbols$3();
	const { kEnumerableProperty: kEnumerableProperty$7 } = require_util$6();
	const { makeIterator, isValidHeaderName: isValidHeaderName$1, isValidHeaderValue } = require_util$5();
	const util$4 = __require("util");
	const { webidl: webidl$10 } = require_webidl();
	const assert$6 = __require("assert");
	const kHeadersMap = Symbol("headers map");
	const kHeadersSortedMap = Symbol("headers map sorted");
	/**
	* @param {number} code
	*/
	function isHTTPWhiteSpaceCharCode(code) {
		return code === 10 || code === 13 || code === 9 || code === 32;
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
	* @param {string} potentialValue
	*/
	function headerValueNormalize(potentialValue) {
		let i$5 = 0;
		let j$5 = potentialValue.length;
		while (j$5 > i$5 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j$5 - 1))) --j$5;
		while (j$5 > i$5 && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i$5))) ++i$5;
		return i$5 === 0 && j$5 === potentialValue.length ? potentialValue : potentialValue.substring(i$5, j$5);
	}
	function fill$1(headers, object) {
		if (Array.isArray(object)) for (let i$5 = 0; i$5 < object.length; ++i$5) {
			const header = object[i$5];
			if (header.length !== 2) throw webidl$10.errors.exception({
				header: "Headers constructor",
				message: `expected name/value pair to be length 2, found ${header.length}.`
			});
			appendHeader(headers, header[0], header[1]);
		}
		else if (typeof object === "object" && object !== null) {
			const keys = Object.keys(object);
			for (let i$5 = 0; i$5 < keys.length; ++i$5) appendHeader(headers, keys[i$5], object[keys[i$5]]);
		} else throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	}
	/**
	* @see https://fetch.spec.whatwg.org/#concept-headers-append
	*/
	function appendHeader(headers, name, value) {
		value = headerValueNormalize(value);
		if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value: name,
			type: "header name"
		});
		else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
			prefix: "Headers.append",
			value,
			type: "header value"
		});
		if (headers[kGuard$4] === "immutable") throw new TypeError("immutable");
		else if (headers[kGuard$4] === "request-no-cors") {}
		return headers[kHeadersList$5].append(name, value);
	}
	var HeadersList$2 = class HeadersList$2 {
		/** @type {[string, string][]|null} */
		cookies = null;
		constructor(init) {
			if (init instanceof HeadersList$2) {
				this[kHeadersMap] = new Map(init[kHeadersMap]);
				this[kHeadersSortedMap] = init[kHeadersSortedMap];
				this.cookies = init.cookies === null ? null : [...init.cookies];
			} else {
				this[kHeadersMap] = new Map(init);
				this[kHeadersSortedMap] = null;
			}
		}
		contains(name) {
			name = name.toLowerCase();
			return this[kHeadersMap].has(name);
		}
		clear() {
			this[kHeadersMap].clear();
			this[kHeadersSortedMap] = null;
			this.cookies = null;
		}
		append(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			const exists$1 = this[kHeadersMap].get(lowercaseName);
			if (exists$1) {
				const delimiter = lowercaseName === "cookie" ? "; " : ", ";
				this[kHeadersMap].set(lowercaseName, {
					name: exists$1.name,
					value: `${exists$1.value}${delimiter}${value}`
				});
			} else this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
			if (lowercaseName === "set-cookie") {
				this.cookies ??= [];
				this.cookies.push(value);
			}
		}
		set(name, value) {
			this[kHeadersSortedMap] = null;
			const lowercaseName = name.toLowerCase();
			if (lowercaseName === "set-cookie") this.cookies = [value];
			this[kHeadersMap].set(lowercaseName, {
				name,
				value
			});
		}
		delete(name) {
			this[kHeadersSortedMap] = null;
			name = name.toLowerCase();
			if (name === "set-cookie") this.cookies = null;
			this[kHeadersMap].delete(name);
		}
		get(name) {
			const value = this[kHeadersMap].get(name.toLowerCase());
			return value === void 0 ? null : value.value;
		}
		*[Symbol.iterator]() {
			for (const [name, { value }] of this[kHeadersMap]) yield [name, value];
		}
		get entries() {
			const headers = {};
			if (this[kHeadersMap].size) for (const { name, value } of this[kHeadersMap].values()) headers[name] = value;
			return headers;
		}
	};
	var Headers$7 = class Headers$7 {
		constructor(init = void 0) {
			if (init === kConstruct$4) return;
			this[kHeadersList$5] = new HeadersList$2();
			this[kGuard$4] = "none";
			if (init !== void 0) {
				init = webidl$10.converters.HeadersInit(init);
				fill$1(this, init);
			}
		}
		append(name, value) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			return appendHeader(this, name, value);
		}
		delete(name) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.delete",
				value: name,
				type: "header name"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			if (!this[kHeadersList$5].contains(name)) return;
			this[kHeadersList$5].delete(name);
		}
		get(name) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.get",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].get(name);
		}
		has(name) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
			name = webidl$10.converters.ByteString(name);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.has",
				value: name,
				type: "header name"
			});
			return this[kHeadersList$5].contains(name);
		}
		set(name, value) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
			name = webidl$10.converters.ByteString(name);
			value = webidl$10.converters.ByteString(value);
			value = headerValueNormalize(value);
			if (!isValidHeaderName$1(name)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value: name,
				type: "header name"
			});
			else if (!isValidHeaderValue(value)) throw webidl$10.errors.invalidArgument({
				prefix: "Headers.set",
				value,
				type: "header value"
			});
			if (this[kGuard$4] === "immutable") throw new TypeError("immutable");
			else if (this[kGuard$4] === "request-no-cors") {}
			this[kHeadersList$5].set(name, value);
		}
		getSetCookie() {
			webidl$10.brandCheck(this, Headers$7);
			const list$1 = this[kHeadersList$5].cookies;
			if (list$1) return [...list$1];
			return [];
		}
		get [kHeadersSortedMap]() {
			if (this[kHeadersList$5][kHeadersSortedMap]) return this[kHeadersList$5][kHeadersSortedMap];
			const headers = [];
			const names = [...this[kHeadersList$5]].sort((a$5, b$5) => a$5[0] < b$5[0] ? -1 : 1);
			const cookies = this[kHeadersList$5].cookies;
			for (let i$5 = 0; i$5 < names.length; ++i$5) {
				const [name, value] = names[i$5];
				if (name === "set-cookie") for (let j$5 = 0; j$5 < cookies.length; ++j$5) headers.push([name, cookies[j$5]]);
				else {
					assert$6(value !== null);
					headers.push([name, value]);
				}
			}
			this[kHeadersList$5][kHeadersSortedMap] = headers;
			return headers;
		}
		keys() {
			webidl$10.brandCheck(this, Headers$7);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
		}
		values() {
			webidl$10.brandCheck(this, Headers$7);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
		}
		entries() {
			webidl$10.brandCheck(this, Headers$7);
			if (this[kGuard$4] === "immutable") {
				const value = this[kHeadersSortedMap];
				return makeIterator(() => value, "Headers", "key+value");
			}
			return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
		}
		/**
		* @param {(value: string, key: string, self: Headers) => void} callbackFn
		* @param {unknown} thisArg
		*/
		forEach(callbackFn, thisArg = globalThis) {
			webidl$10.brandCheck(this, Headers$7);
			webidl$10.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
			if (typeof callbackFn !== "function") throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
			for (const [key, value] of this) callbackFn.apply(thisArg, [
				value,
				key,
				this
			]);
		}
		[Symbol.for("nodejs.util.inspect.custom")]() {
			webidl$10.brandCheck(this, Headers$7);
			return this[kHeadersList$5];
		}
	};
	Headers$7.prototype[Symbol.iterator] = Headers$7.prototype.entries;
	Object.defineProperties(Headers$7.prototype, {
		append: kEnumerableProperty$7,
		delete: kEnumerableProperty$7,
		get: kEnumerableProperty$7,
		has: kEnumerableProperty$7,
		set: kEnumerableProperty$7,
		getSetCookie: kEnumerableProperty$7,
		keys: kEnumerableProperty$7,
		values: kEnumerableProperty$7,
		entries: kEnumerableProperty$7,
		forEach: kEnumerableProperty$7,
		[Symbol.iterator]: { enumerable: false },
		[Symbol.toStringTag]: {
			value: "Headers",
			configurable: true
		},
		[util$4.inspect.custom]: { enumerable: false }
	});
	webidl$10.converters.HeadersInit = function(V) {
		if (webidl$10.util.Type(V) === "Object") {
			if (V[Symbol.iterator]) return webidl$10.converters["sequence<sequence<ByteString>>"](V);
			return webidl$10.converters["record<ByteString, ByteString>"](V);
		}
		throw webidl$10.errors.conversionFailed({
			prefix: "Headers constructor",
			argument: "Argument 1",
			types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
		});
	};
	module.exports = {
		fill: fill$1,
		Headers: Headers$7,
		HeadersList: HeadersList$2
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/response.js
var require_response = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Headers: Headers$6, HeadersList: HeadersList$1, fill } = require_headers();
	const { extractBody: extractBody$1, cloneBody: cloneBody$1, mixinBody: mixinBody$1 } = require_body();
	const util$3 = require_util$6();
	const { kEnumerableProperty: kEnumerableProperty$6 } = util$3;
	const { isValidReasonPhrase, isCancelled: isCancelled$1, isAborted: isAborted$1, isBlobLike: isBlobLike$2, serializeJavascriptValueToJSONString, isErrorLike: isErrorLike$1, isomorphicEncode: isomorphicEncode$1 } = require_util$5();
	const { redirectStatusSet: redirectStatusSet$1, nullBodyStatus: nullBodyStatus$1, DOMException: DOMException$4 } = require_constants$3();
	const { kState: kState$6, kHeaders: kHeaders$3, kGuard: kGuard$3, kRealm: kRealm$3 } = require_symbols$3();
	const { webidl: webidl$9 } = require_webidl();
	const { FormData } = require_formdata();
	const { getGlobalOrigin: getGlobalOrigin$2 } = require_global$1();
	const { URLSerializer: URLSerializer$3 } = require_dataURL();
	const { kHeadersList: kHeadersList$4, kConstruct: kConstruct$3 } = require_symbols$4();
	const assert$5 = __require("assert");
	const { types: types$7 } = __require("util");
	const ReadableStream$2 = globalThis.ReadableStream || __require("stream/web").ReadableStream;
	const textEncoder = new TextEncoder("utf-8");
	var Response$2 = class Response$2 {
		static error() {
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$2();
			responseObject[kState$6] = makeNetworkError$1();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kHeadersList$4] = responseObject[kState$6].headersList;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			return responseObject;
		}
		static json(data$1, init = {}) {
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.json" });
			if (init !== null) init = webidl$9.converters.ResponseInit(init);
			const body = extractBody$1(textEncoder.encode(serializeJavascriptValueToJSONString(data$1)));
			const relevantRealm = { settingsObject: {} };
			const responseObject = new Response$2();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "response";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			initializeResponse(responseObject, init, {
				body: body[0],
				type: "application/json"
			});
			return responseObject;
		}
		static redirect(url$1, status = 302) {
			const relevantRealm = { settingsObject: {} };
			webidl$9.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
			url$1 = webidl$9.converters.USVString(url$1);
			status = webidl$9.converters["unsigned short"](status);
			let parsedURL;
			try {
				parsedURL = new URL(url$1, getGlobalOrigin$2());
			} catch (err) {
				throw Object.assign(/* @__PURE__ */ new TypeError("Failed to parse URL from " + url$1), { cause: err });
			}
			if (!redirectStatusSet$1.has(status)) throw new RangeError("Invalid status code " + status);
			const responseObject = new Response$2();
			responseObject[kRealm$3] = relevantRealm;
			responseObject[kHeaders$3][kGuard$3] = "immutable";
			responseObject[kHeaders$3][kRealm$3] = relevantRealm;
			responseObject[kState$6].status = status;
			const value = isomorphicEncode$1(URLSerializer$3(parsedURL));
			responseObject[kState$6].headersList.append("location", value);
			return responseObject;
		}
		constructor(body = null, init = {}) {
			if (body !== null) body = webidl$9.converters.BodyInit(body);
			init = webidl$9.converters.ResponseInit(init);
			this[kRealm$3] = { settingsObject: {} };
			this[kState$6] = makeResponse$1({});
			this[kHeaders$3] = new Headers$6(kConstruct$3);
			this[kHeaders$3][kGuard$3] = "response";
			this[kHeaders$3][kHeadersList$4] = this[kState$6].headersList;
			this[kHeaders$3][kRealm$3] = this[kRealm$3];
			let bodyWithType = null;
			if (body != null) {
				const [extractedBody, type] = extractBody$1(body);
				bodyWithType = {
					body: extractedBody,
					type
				};
			}
			initializeResponse(this, init, bodyWithType);
		}
		get type() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].type;
		}
		get url() {
			webidl$9.brandCheck(this, Response$2);
			const urlList = this[kState$6].urlList;
			const url$1 = urlList[urlList.length - 1] ?? null;
			if (url$1 === null) return "";
			return URLSerializer$3(url$1, true);
		}
		get redirected() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].urlList.length > 1;
		}
		get status() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].status;
		}
		get ok() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].status >= 200 && this[kState$6].status <= 299;
		}
		get statusText() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].statusText;
		}
		get headers() {
			webidl$9.brandCheck(this, Response$2);
			return this[kHeaders$3];
		}
		get body() {
			webidl$9.brandCheck(this, Response$2);
			return this[kState$6].body ? this[kState$6].body.stream : null;
		}
		get bodyUsed() {
			webidl$9.brandCheck(this, Response$2);
			return !!this[kState$6].body && util$3.isDisturbed(this[kState$6].body.stream);
		}
		clone() {
			webidl$9.brandCheck(this, Response$2);
			if (this.bodyUsed || this.body && this.body.locked) throw webidl$9.errors.exception({
				header: "Response.clone",
				message: "Body has already been consumed."
			});
			const clonedResponse = cloneResponse$1(this[kState$6]);
			const clonedResponseObject = new Response$2();
			clonedResponseObject[kState$6] = clonedResponse;
			clonedResponseObject[kRealm$3] = this[kRealm$3];
			clonedResponseObject[kHeaders$3][kHeadersList$4] = clonedResponse.headersList;
			clonedResponseObject[kHeaders$3][kGuard$3] = this[kHeaders$3][kGuard$3];
			clonedResponseObject[kHeaders$3][kRealm$3] = this[kHeaders$3][kRealm$3];
			return clonedResponseObject;
		}
	};
	mixinBody$1(Response$2);
	Object.defineProperties(Response$2.prototype, {
		type: kEnumerableProperty$6,
		url: kEnumerableProperty$6,
		status: kEnumerableProperty$6,
		ok: kEnumerableProperty$6,
		redirected: kEnumerableProperty$6,
		statusText: kEnumerableProperty$6,
		headers: kEnumerableProperty$6,
		clone: kEnumerableProperty$6,
		body: kEnumerableProperty$6,
		bodyUsed: kEnumerableProperty$6,
		[Symbol.toStringTag]: {
			value: "Response",
			configurable: true
		}
	});
	Object.defineProperties(Response$2, {
		json: kEnumerableProperty$6,
		redirect: kEnumerableProperty$6,
		error: kEnumerableProperty$6
	});
	function cloneResponse$1(response) {
		if (response.internalResponse) return filterResponse$1(cloneResponse$1(response.internalResponse), response.type);
		const newResponse = makeResponse$1({
			...response,
			body: null
		});
		if (response.body != null) newResponse.body = cloneBody$1(response.body);
		return newResponse;
	}
	function makeResponse$1(init) {
		return {
			aborted: false,
			rangeRequested: false,
			timingAllowPassed: false,
			requestIncludesCredentials: false,
			type: "default",
			status: 200,
			timingInfo: null,
			cacheState: "",
			statusText: "",
			...init,
			headersList: init.headersList ? new HeadersList$1(init.headersList) : new HeadersList$1(),
			urlList: init.urlList ? [...init.urlList] : []
		};
	}
	function makeNetworkError$1(reason) {
		return makeResponse$1({
			type: "error",
			status: 0,
			error: isErrorLike$1(reason) ? reason : new Error(reason ? String(reason) : reason),
			aborted: reason && reason.name === "AbortError"
		});
	}
	function makeFilteredResponse(response, state$1) {
		state$1 = {
			internalResponse: response,
			...state$1
		};
		return new Proxy(response, {
			get(target, p$5) {
				return p$5 in state$1 ? state$1[p$5] : target[p$5];
			},
			set(target, p$5, value) {
				assert$5(!(p$5 in state$1));
				target[p$5] = value;
				return true;
			}
		});
	}
	function filterResponse$1(response, type) {
		if (type === "basic") return makeFilteredResponse(response, {
			type: "basic",
			headersList: response.headersList
		});
		else if (type === "cors") return makeFilteredResponse(response, {
			type: "cors",
			headersList: response.headersList
		});
		else if (type === "opaque") return makeFilteredResponse(response, {
			type: "opaque",
			urlList: Object.freeze([]),
			status: 0,
			statusText: "",
			body: null
		});
		else if (type === "opaqueredirect") return makeFilteredResponse(response, {
			type: "opaqueredirect",
			status: 0,
			statusText: "",
			headersList: [],
			body: null
		});
		else assert$5(false);
	}
	function makeAppropriateNetworkError$1(fetchParams, err = null) {
		assert$5(isCancelled$1(fetchParams));
		return isAborted$1(fetchParams) ? makeNetworkError$1(Object.assign(new DOMException$4("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError$1(Object.assign(new DOMException$4("Request was cancelled."), { cause: err }));
	}
	function initializeResponse(response, init, body) {
		if (init.status !== null && (init.status < 200 || init.status > 599)) throw new RangeError("init[\"status\"] must be in the range of 200 to 599, inclusive.");
		if ("statusText" in init && init.statusText != null) {
			if (!isValidReasonPhrase(String(init.statusText))) throw new TypeError("Invalid statusText");
		}
		if ("status" in init && init.status != null) response[kState$6].status = init.status;
		if ("statusText" in init && init.statusText != null) response[kState$6].statusText = init.statusText;
		if ("headers" in init && init.headers != null) fill(response[kHeaders$3], init.headers);
		if (body) {
			if (nullBodyStatus$1.includes(response.status)) throw webidl$9.errors.exception({
				header: "Response constructor",
				message: "Invalid response status code " + response.status
			});
			response[kState$6].body = body.body;
			if (body.type != null && !response[kState$6].headersList.contains("Content-Type")) response[kState$6].headersList.append("content-type", body.type);
		}
	}
	webidl$9.converters.ReadableStream = webidl$9.interfaceConverter(ReadableStream$2);
	webidl$9.converters.FormData = webidl$9.interfaceConverter(FormData);
	webidl$9.converters.URLSearchParams = webidl$9.interfaceConverter(URLSearchParams);
	webidl$9.converters.XMLHttpRequestBodyInit = function(V) {
		if (typeof V === "string") return webidl$9.converters.USVString(V);
		if (isBlobLike$2(V)) return webidl$9.converters.Blob(V, { strict: false });
		if (types$7.isArrayBuffer(V) || types$7.isTypedArray(V) || types$7.isDataView(V)) return webidl$9.converters.BufferSource(V);
		if (util$3.isFormDataLike(V)) return webidl$9.converters.FormData(V, { strict: false });
		if (V instanceof URLSearchParams) return webidl$9.converters.URLSearchParams(V);
		return webidl$9.converters.DOMString(V);
	};
	webidl$9.converters.BodyInit = function(V) {
		if (V instanceof ReadableStream$2) return webidl$9.converters.ReadableStream(V);
		if (V?.[Symbol.asyncIterator]) return V;
		return webidl$9.converters.XMLHttpRequestBodyInit(V);
	};
	webidl$9.converters.ResponseInit = webidl$9.dictionaryConverter([
		{
			key: "status",
			converter: webidl$9.converters["unsigned short"],
			defaultValue: 200
		},
		{
			key: "statusText",
			converter: webidl$9.converters.ByteString,
			defaultValue: ""
		},
		{
			key: "headers",
			converter: webidl$9.converters.HeadersInit
		}
	]);
	module.exports = {
		makeNetworkError: makeNetworkError$1,
		makeResponse: makeResponse$1,
		makeAppropriateNetworkError: makeAppropriateNetworkError$1,
		filterResponse: filterResponse$1,
		Response: Response$2,
		cloneResponse: cloneResponse$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/request.js
var require_request = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { extractBody, mixinBody, cloneBody } = require_body();
	const { Headers: Headers$5, fill: fillHeaders, HeadersList } = require_headers();
	const { FinalizationRegistry } = require_dispatcher_weakref()();
	const util$2 = require_util$6();
	const { isValidHTTPToken, sameOrigin: sameOrigin$1, normalizeMethod, makePolicyContainer: makePolicyContainer$1, normalizeMethodRecord } = require_util$5();
	const { forbiddenMethodsSet, corsSafeListedMethodsSet, referrerPolicy, requestRedirect, requestMode, requestCredentials, requestCache, requestDuplex } = require_constants$3();
	const { kEnumerableProperty: kEnumerableProperty$5 } = util$2;
	const { kHeaders: kHeaders$2, kSignal, kState: kState$5, kGuard: kGuard$2, kRealm: kRealm$2 } = require_symbols$3();
	const { webidl: webidl$8 } = require_webidl();
	const { getGlobalOrigin: getGlobalOrigin$1 } = require_global$1();
	const { URLSerializer: URLSerializer$2 } = require_dataURL();
	const { kHeadersList: kHeadersList$3, kConstruct: kConstruct$2 } = require_symbols$4();
	const assert$4 = __require("assert");
	const { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
	let TransformStream$2 = globalThis.TransformStream;
	const kAbortController = Symbol("abortController");
	const requestFinalizer = new FinalizationRegistry(({ signal, abort: abort$1 }) => {
		signal.removeEventListener("abort", abort$1);
	});
	var Request$3 = class Request$3 {
		constructor(input, init = {}) {
			if (input === kConstruct$2) return;
			webidl$8.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
			input = webidl$8.converters.RequestInfo(input);
			init = webidl$8.converters.RequestInit(init);
			this[kRealm$2] = { settingsObject: {
				baseUrl: getGlobalOrigin$1(),
				get origin() {
					return this.baseUrl?.origin;
				},
				policyContainer: makePolicyContainer$1()
			} };
			let request$1 = null;
			let fallbackMode = null;
			const baseUrl = this[kRealm$2].settingsObject.baseUrl;
			let signal = null;
			if (typeof input === "string") {
				let parsedURL;
				try {
					parsedURL = new URL(input, baseUrl);
				} catch (err) {
					throw new TypeError("Failed to parse URL from " + input, { cause: err });
				}
				if (parsedURL.username || parsedURL.password) throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
				request$1 = makeRequest$2({ urlList: [parsedURL] });
				fallbackMode = "cors";
			} else {
				assert$4(input instanceof Request$3);
				request$1 = input[kState$5];
				signal = input[kSignal];
			}
			const origin = this[kRealm$2].settingsObject.origin;
			let window$1 = "client";
			if (request$1.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin$1(request$1.window, origin)) window$1 = request$1.window;
			if (init.window != null) throw new TypeError(`'window' option '${window$1}' must be null`);
			if ("window" in init) window$1 = "no-window";
			request$1 = makeRequest$2({
				method: request$1.method,
				headersList: request$1.headersList,
				unsafeRequest: request$1.unsafeRequest,
				client: this[kRealm$2].settingsObject,
				window: window$1,
				priority: request$1.priority,
				origin: request$1.origin,
				referrer: request$1.referrer,
				referrerPolicy: request$1.referrerPolicy,
				mode: request$1.mode,
				credentials: request$1.credentials,
				cache: request$1.cache,
				redirect: request$1.redirect,
				integrity: request$1.integrity,
				keepalive: request$1.keepalive,
				reloadNavigation: request$1.reloadNavigation,
				historyNavigation: request$1.historyNavigation,
				urlList: [...request$1.urlList]
			});
			const initHasKey = Object.keys(init).length !== 0;
			if (initHasKey) {
				if (request$1.mode === "navigate") request$1.mode = "same-origin";
				request$1.reloadNavigation = false;
				request$1.historyNavigation = false;
				request$1.origin = "client";
				request$1.referrer = "client";
				request$1.referrerPolicy = "";
				request$1.url = request$1.urlList[request$1.urlList.length - 1];
				request$1.urlList = [request$1.url];
			}
			if (init.referrer !== void 0) {
				const referrer = init.referrer;
				if (referrer === "") request$1.referrer = "no-referrer";
				else {
					let parsedReferrer;
					try {
						parsedReferrer = new URL(referrer, baseUrl);
					} catch (err) {
						throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
					}
					if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin$1(parsedReferrer, this[kRealm$2].settingsObject.baseUrl)) request$1.referrer = "client";
					else request$1.referrer = parsedReferrer;
				}
			}
			if (init.referrerPolicy !== void 0) request$1.referrerPolicy = init.referrerPolicy;
			let mode;
			if (init.mode !== void 0) mode = init.mode;
			else mode = fallbackMode;
			if (mode === "navigate") throw webidl$8.errors.exception({
				header: "Request constructor",
				message: "invalid request mode navigate."
			});
			if (mode != null) request$1.mode = mode;
			if (init.credentials !== void 0) request$1.credentials = init.credentials;
			if (init.cache !== void 0) request$1.cache = init.cache;
			if (request$1.cache === "only-if-cached" && request$1.mode !== "same-origin") throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
			if (init.redirect !== void 0) request$1.redirect = init.redirect;
			if (init.integrity != null) request$1.integrity = String(init.integrity);
			if (init.keepalive !== void 0) request$1.keepalive = Boolean(init.keepalive);
			if (init.method !== void 0) {
				let method = init.method;
				if (!isValidHTTPToken(method)) throw new TypeError(`'${method}' is not a valid HTTP method.`);
				if (forbiddenMethodsSet.has(method.toUpperCase())) throw new TypeError(`'${method}' HTTP method is unsupported.`);
				method = normalizeMethodRecord[method] ?? normalizeMethod(method);
				request$1.method = method;
			}
			if (init.signal !== void 0) signal = init.signal;
			this[kState$5] = request$1;
			const ac = new AbortController();
			this[kSignal] = ac.signal;
			this[kSignal][kRealm$2] = this[kRealm$2];
			if (signal != null) {
				if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
				if (signal.aborted) ac.abort(signal.reason);
				else {
					this[kAbortController] = ac;
					const acRef = new WeakRef(ac);
					const abort$1 = function() {
						const ac$1 = acRef.deref();
						if (ac$1 !== void 0) ac$1.abort(this.reason);
					};
					try {
						if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) setMaxListeners(100, signal);
						else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) setMaxListeners(100, signal);
					} catch {}
					util$2.addAbortListener(signal, abort$1);
					requestFinalizer.register(ac, {
						signal,
						abort: abort$1
					});
				}
			}
			this[kHeaders$2] = new Headers$5(kConstruct$2);
			this[kHeaders$2][kHeadersList$3] = request$1.headersList;
			this[kHeaders$2][kGuard$2] = "request";
			this[kHeaders$2][kRealm$2] = this[kRealm$2];
			if (mode === "no-cors") {
				if (!corsSafeListedMethodsSet.has(request$1.method)) throw new TypeError(`'${request$1.method} is unsupported in no-cors mode.`);
				this[kHeaders$2][kGuard$2] = "request-no-cors";
			}
			if (initHasKey) {
				/** @type {HeadersList} */
				const headersList = this[kHeaders$2][kHeadersList$3];
				const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
				headersList.clear();
				if (headers instanceof HeadersList) {
					for (const [key, val] of headers) headersList.append(key, val);
					headersList.cookies = headers.cookies;
				} else fillHeaders(this[kHeaders$2], headers);
			}
			const inputBody = input instanceof Request$3 ? input[kState$5].body : null;
			if ((init.body != null || inputBody != null) && (request$1.method === "GET" || request$1.method === "HEAD")) throw new TypeError("Request with GET/HEAD method cannot have body.");
			let initBody = null;
			if (init.body != null) {
				const [extractedBody, contentType] = extractBody(init.body, request$1.keepalive);
				initBody = extractedBody;
				if (contentType && !this[kHeaders$2][kHeadersList$3].contains("content-type")) this[kHeaders$2].append("content-type", contentType);
			}
			const inputOrInitBody = initBody ?? inputBody;
			if (inputOrInitBody != null && inputOrInitBody.source == null) {
				if (initBody != null && init.duplex == null) throw new TypeError("RequestInit: duplex option is required when sending a body.");
				if (request$1.mode !== "same-origin" && request$1.mode !== "cors") throw new TypeError("If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"");
				request$1.useCORSPreflightFlag = true;
			}
			let finalBody = inputOrInitBody;
			if (initBody == null && inputBody != null) {
				if (util$2.isDisturbed(inputBody.stream) || inputBody.stream.locked) throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
				if (!TransformStream$2) TransformStream$2 = __require("stream/web").TransformStream;
				const identityTransform = new TransformStream$2();
				inputBody.stream.pipeThrough(identityTransform);
				finalBody = {
					source: inputBody.source,
					length: inputBody.length,
					stream: identityTransform.readable
				};
			}
			this[kState$5].body = finalBody;
		}
		get method() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].method;
		}
		get url() {
			webidl$8.brandCheck(this, Request$3);
			return URLSerializer$2(this[kState$5].url);
		}
		get headers() {
			webidl$8.brandCheck(this, Request$3);
			return this[kHeaders$2];
		}
		get destination() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].destination;
		}
		get referrer() {
			webidl$8.brandCheck(this, Request$3);
			if (this[kState$5].referrer === "no-referrer") return "";
			if (this[kState$5].referrer === "client") return "about:client";
			return this[kState$5].referrer.toString();
		}
		get referrerPolicy() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].referrerPolicy;
		}
		get mode() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].mode;
		}
		get credentials() {
			return this[kState$5].credentials;
		}
		get cache() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].cache;
		}
		get redirect() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].redirect;
		}
		get integrity() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].integrity;
		}
		get keepalive() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].keepalive;
		}
		get isReloadNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].reloadNavigation;
		}
		get isHistoryNavigation() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].historyNavigation;
		}
		get signal() {
			webidl$8.brandCheck(this, Request$3);
			return this[kSignal];
		}
		get body() {
			webidl$8.brandCheck(this, Request$3);
			return this[kState$5].body ? this[kState$5].body.stream : null;
		}
		get bodyUsed() {
			webidl$8.brandCheck(this, Request$3);
			return !!this[kState$5].body && util$2.isDisturbed(this[kState$5].body.stream);
		}
		get duplex() {
			webidl$8.brandCheck(this, Request$3);
			return "half";
		}
		clone() {
			webidl$8.brandCheck(this, Request$3);
			if (this.bodyUsed || this.body?.locked) throw new TypeError("unusable");
			const clonedRequest = cloneRequest(this[kState$5]);
			const clonedRequestObject = new Request$3(kConstruct$2);
			clonedRequestObject[kState$5] = clonedRequest;
			clonedRequestObject[kRealm$2] = this[kRealm$2];
			clonedRequestObject[kHeaders$2] = new Headers$5(kConstruct$2);
			clonedRequestObject[kHeaders$2][kHeadersList$3] = clonedRequest.headersList;
			clonedRequestObject[kHeaders$2][kGuard$2] = this[kHeaders$2][kGuard$2];
			clonedRequestObject[kHeaders$2][kRealm$2] = this[kHeaders$2][kRealm$2];
			const ac = new AbortController();
			if (this.signal.aborted) ac.abort(this.signal.reason);
			else util$2.addAbortListener(this.signal, () => {
				ac.abort(this.signal.reason);
			});
			clonedRequestObject[kSignal] = ac.signal;
			return clonedRequestObject;
		}
	};
	mixinBody(Request$3);
	function makeRequest$2(init) {
		const request$1 = {
			method: "GET",
			localURLsOnly: false,
			unsafeRequest: false,
			body: null,
			client: null,
			reservedClient: null,
			replacesClientId: "",
			window: "client",
			keepalive: false,
			serviceWorkers: "all",
			initiator: "",
			destination: "",
			priority: null,
			origin: "client",
			policyContainer: "client",
			referrer: "client",
			referrerPolicy: "",
			mode: "no-cors",
			useCORSPreflightFlag: false,
			credentials: "same-origin",
			useCredentials: false,
			cache: "default",
			redirect: "follow",
			integrity: "",
			cryptoGraphicsNonceMetadata: "",
			parserMetadata: "",
			reloadNavigation: false,
			historyNavigation: false,
			userActivation: false,
			taintedOrigin: false,
			redirectCount: 0,
			responseTainting: "basic",
			preventNoCacheCacheControlHeaderModification: false,
			done: false,
			timingAllowFailed: false,
			...init,
			headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
		};
		request$1.url = request$1.urlList[0];
		return request$1;
	}
	function cloneRequest(request$1) {
		const newRequest = makeRequest$2({
			...request$1,
			body: null
		});
		if (request$1.body != null) newRequest.body = cloneBody(request$1.body);
		return newRequest;
	}
	Object.defineProperties(Request$3.prototype, {
		method: kEnumerableProperty$5,
		url: kEnumerableProperty$5,
		headers: kEnumerableProperty$5,
		redirect: kEnumerableProperty$5,
		clone: kEnumerableProperty$5,
		signal: kEnumerableProperty$5,
		duplex: kEnumerableProperty$5,
		destination: kEnumerableProperty$5,
		body: kEnumerableProperty$5,
		bodyUsed: kEnumerableProperty$5,
		isHistoryNavigation: kEnumerableProperty$5,
		isReloadNavigation: kEnumerableProperty$5,
		keepalive: kEnumerableProperty$5,
		integrity: kEnumerableProperty$5,
		cache: kEnumerableProperty$5,
		credentials: kEnumerableProperty$5,
		attribute: kEnumerableProperty$5,
		referrerPolicy: kEnumerableProperty$5,
		referrer: kEnumerableProperty$5,
		mode: kEnumerableProperty$5,
		[Symbol.toStringTag]: {
			value: "Request",
			configurable: true
		}
	});
	webidl$8.converters.Request = webidl$8.interfaceConverter(Request$3);
	webidl$8.converters.RequestInfo = function(V) {
		if (typeof V === "string") return webidl$8.converters.USVString(V);
		if (V instanceof Request$3) return webidl$8.converters.Request(V);
		return webidl$8.converters.USVString(V);
	};
	webidl$8.converters.AbortSignal = webidl$8.interfaceConverter(AbortSignal);
	webidl$8.converters.RequestInit = webidl$8.dictionaryConverter([
		{
			key: "method",
			converter: webidl$8.converters.ByteString
		},
		{
			key: "headers",
			converter: webidl$8.converters.HeadersInit
		},
		{
			key: "body",
			converter: webidl$8.nullableConverter(webidl$8.converters.BodyInit)
		},
		{
			key: "referrer",
			converter: webidl$8.converters.USVString
		},
		{
			key: "referrerPolicy",
			converter: webidl$8.converters.DOMString,
			allowedValues: referrerPolicy
		},
		{
			key: "mode",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestMode
		},
		{
			key: "credentials",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCredentials
		},
		{
			key: "cache",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestCache
		},
		{
			key: "redirect",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestRedirect
		},
		{
			key: "integrity",
			converter: webidl$8.converters.DOMString
		},
		{
			key: "keepalive",
			converter: webidl$8.converters.boolean
		},
		{
			key: "signal",
			converter: webidl$8.nullableConverter((signal) => webidl$8.converters.AbortSignal(signal, { strict: false }))
		},
		{
			key: "window",
			converter: webidl$8.converters.any
		},
		{
			key: "duplex",
			converter: webidl$8.converters.DOMString,
			allowedValues: requestDuplex
		}
	]);
	module.exports = {
		Request: Request$3,
		makeRequest: makeRequest$2
	};
}));

//#endregion
//#region node_modules/undici/lib/fetch/index.js
var require_fetch = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Response: Response$1, makeNetworkError, makeAppropriateNetworkError, filterResponse, makeResponse } = require_response();
	const { Headers: Headers$4 } = require_headers();
	const { Request: Request$2, makeRequest: makeRequest$1 } = require_request();
	const zlib = __require("zlib");
	const { bytesMatch, makePolicyContainer, clonePolicyContainer, requestBadPort, TAOCheck, appendRequestOriginHeader, responseLocationURL, requestCurrentURL, setRequestReferrerPolicyOnRedirect, tryUpgradeRequestToAPotentiallyTrustworthyURL, createOpaqueTimingInfo, appendFetchMetadata, corsCheck, crossOriginResourcePolicyCheck, determineRequestsReferrer, coarsenedSharedCurrentTime, createDeferredPromise: createDeferredPromise$1, isBlobLike: isBlobLike$1, sameOrigin, isCancelled, isAborted, isErrorLike, fullyReadBody, readableStreamClose, isomorphicEncode, urlIsLocal, urlIsHttpHttpsScheme: urlIsHttpHttpsScheme$1, urlHasHttpsScheme } = require_util$5();
	const { kState: kState$4, kHeaders: kHeaders$1, kGuard: kGuard$1, kRealm: kRealm$1 } = require_symbols$3();
	const assert$3 = __require("assert");
	const { safelyExtractBody } = require_body();
	const { redirectStatusSet, nullBodyStatus, safeMethodsSet, requestBodyHeader, subresourceSet, DOMException: DOMException$3 } = require_constants$3();
	const { kHeadersList: kHeadersList$2 } = require_symbols$4();
	const EE = __require("events");
	const { Readable, pipeline } = __require("stream");
	const { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util$6();
	const { dataURLProcessor, serializeAMimeType: serializeAMimeType$1 } = require_dataURL();
	const { TransformStream: TransformStream$1 } = __require("stream/web");
	const { getGlobalDispatcher: getGlobalDispatcher$4 } = require_global();
	const { webidl: webidl$7 } = require_webidl();
	const { STATUS_CODES } = __require("http");
	const GET_OR_HEAD = ["GET", "HEAD"];
	/** @type {import('buffer').resolveObjectURL} */
	let resolveObjectURL;
	let ReadableStream$1 = globalThis.ReadableStream;
	var Fetch = class extends EE {
		constructor(dispatcher) {
			super();
			this.dispatcher = dispatcher;
			this.connection = null;
			this.dump = false;
			this.state = "ongoing";
			this.setMaxListeners(21);
		}
		terminate(reason) {
			if (this.state !== "ongoing") return;
			this.state = "terminated";
			this.connection?.destroy(reason);
			this.emit("terminated", reason);
		}
		abort(error$2) {
			if (this.state !== "ongoing") return;
			this.state = "aborted";
			if (!error$2) error$2 = new DOMException$3("The operation was aborted.", "AbortError");
			this.serializedAbortReason = error$2;
			this.connection?.destroy(error$2);
			this.emit("terminated", error$2);
		}
	};
	function fetch$1(input, init = {}) {
		webidl$7.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
		const p$5 = createDeferredPromise$1();
		let requestObject;
		try {
			requestObject = new Request$2(input, init);
		} catch (e$5) {
			p$5.reject(e$5);
			return p$5.promise;
		}
		const request$1 = requestObject[kState$4];
		if (requestObject.signal.aborted) {
			abortFetch(p$5, request$1, null, requestObject.signal.reason);
			return p$5.promise;
		}
		if (request$1.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope") request$1.serviceWorkers = "none";
		let responseObject = null;
		const relevantRealm = null;
		let locallyAborted = false;
		let controller = null;
		addAbortListener(requestObject.signal, () => {
			locallyAborted = true;
			assert$3(controller != null);
			controller.abort(requestObject.signal.reason);
			abortFetch(p$5, request$1, responseObject, requestObject.signal.reason);
		});
		const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
		const processResponse = (response) => {
			if (locallyAborted) return Promise.resolve();
			if (response.aborted) {
				abortFetch(p$5, request$1, responseObject, controller.serializedAbortReason);
				return Promise.resolve();
			}
			if (response.type === "error") {
				p$5.reject(Object.assign(/* @__PURE__ */ new TypeError("fetch failed"), { cause: response.error }));
				return Promise.resolve();
			}
			responseObject = new Response$1();
			responseObject[kState$4] = response;
			responseObject[kRealm$1] = relevantRealm;
			responseObject[kHeaders$1][kHeadersList$2] = response.headersList;
			responseObject[kHeaders$1][kGuard$1] = "immutable";
			responseObject[kHeaders$1][kRealm$1] = relevantRealm;
			p$5.resolve(responseObject);
		};
		controller = fetching$2({
			request: request$1,
			processResponseEndOfBody: handleFetchDone,
			processResponse,
			dispatcher: init.dispatcher ?? getGlobalDispatcher$4()
		});
		return p$5.promise;
	}
	function finalizeAndReportTiming(response, initiatorType = "other") {
		if (response.type === "error" && response.aborted) return;
		if (!response.urlList?.length) return;
		const originalURL = response.urlList[0];
		let timingInfo = response.timingInfo;
		let cacheState = response.cacheState;
		if (!urlIsHttpHttpsScheme$1(originalURL)) return;
		if (timingInfo === null) return;
		if (!response.timingAllowPassed) {
			timingInfo = createOpaqueTimingInfo({ startTime: timingInfo.startTime });
			cacheState = "";
		}
		timingInfo.endTime = coarsenedSharedCurrentTime();
		response.timingInfo = timingInfo;
		markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
	}
	function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis$1, cacheState) {
		if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis$1, cacheState);
	}
	function abortFetch(p$5, request$1, responseObject, error$2) {
		if (!error$2) error$2 = new DOMException$3("The operation was aborted.", "AbortError");
		p$5.reject(error$2);
		if (request$1.body != null && isReadable(request$1.body?.stream)) request$1.body.stream.cancel(error$2).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
		if (responseObject == null) return;
		const response = responseObject[kState$4];
		if (response.body != null && isReadable(response.body?.stream)) response.body.stream.cancel(error$2).catch((err) => {
			if (err.code === "ERR_INVALID_STATE") return;
			throw err;
		});
	}
	function fetching$2({ request: request$1, processRequestBodyChunkLength, processRequestEndOfBody, processResponse, processResponseEndOfBody, processResponseConsumeBody, useParallelQueue = false, dispatcher }) {
		let taskDestination = null;
		let crossOriginIsolatedCapability = false;
		if (request$1.client != null) {
			taskDestination = request$1.client.globalObject;
			crossOriginIsolatedCapability = request$1.client.crossOriginIsolatedCapability;
		}
		const timingInfo = createOpaqueTimingInfo({ startTime: coarsenedSharedCurrentTime(crossOriginIsolatedCapability) });
		const fetchParams = {
			controller: new Fetch(dispatcher),
			request: request$1,
			timingInfo,
			processRequestBodyChunkLength,
			processRequestEndOfBody,
			processResponse,
			processResponseConsumeBody,
			processResponseEndOfBody,
			taskDestination,
			crossOriginIsolatedCapability
		};
		assert$3(!request$1.body || request$1.body.stream);
		if (request$1.window === "client") request$1.window = request$1.client?.globalObject?.constructor?.name === "Window" ? request$1.client : "no-window";
		if (request$1.origin === "client") request$1.origin = request$1.client?.origin;
		if (request$1.policyContainer === "client") if (request$1.client != null) request$1.policyContainer = clonePolicyContainer(request$1.client.policyContainer);
		else request$1.policyContainer = makePolicyContainer();
		if (!request$1.headersList.contains("accept")) request$1.headersList.append("accept", "*/*");
		if (!request$1.headersList.contains("accept-language")) request$1.headersList.append("accept-language", "*");
		if (request$1.priority === null) {}
		if (subresourceSet.has(request$1.destination)) {}
		mainFetch(fetchParams).catch((err) => {
			fetchParams.controller.terminate(err);
		});
		return fetchParams.controller;
	}
	async function mainFetch(fetchParams, recursive = false) {
		const request$1 = fetchParams.request;
		let response = null;
		if (request$1.localURLsOnly && !urlIsLocal(requestCurrentURL(request$1))) response = makeNetworkError("local URLs only");
		tryUpgradeRequestToAPotentiallyTrustworthyURL(request$1);
		if (requestBadPort(request$1) === "blocked") response = makeNetworkError("bad port");
		if (request$1.referrerPolicy === "") request$1.referrerPolicy = request$1.policyContainer.referrerPolicy;
		if (request$1.referrer !== "no-referrer") request$1.referrer = determineRequestsReferrer(request$1);
		if (response === null) response = await (async () => {
			const currentURL = requestCurrentURL(request$1);
			if (sameOrigin(currentURL, request$1.url) && request$1.responseTainting === "basic" || currentURL.protocol === "data:" || request$1.mode === "navigate" || request$1.mode === "websocket") {
				request$1.responseTainting = "basic";
				return await schemeFetch(fetchParams);
			}
			if (request$1.mode === "same-origin") return makeNetworkError("request mode cannot be \"same-origin\"");
			if (request$1.mode === "no-cors") {
				if (request$1.redirect !== "follow") return makeNetworkError("redirect mode cannot be \"follow\" for \"no-cors\" request");
				request$1.responseTainting = "opaque";
				return await schemeFetch(fetchParams);
			}
			if (!urlIsHttpHttpsScheme$1(requestCurrentURL(request$1))) return makeNetworkError("URL scheme must be a HTTP(S) scheme");
			request$1.responseTainting = "cors";
			return await httpFetch(fetchParams);
		})();
		if (recursive) return response;
		if (response.status !== 0 && !response.internalResponse) {
			if (request$1.responseTainting === "cors") {}
			if (request$1.responseTainting === "basic") response = filterResponse(response, "basic");
			else if (request$1.responseTainting === "cors") response = filterResponse(response, "cors");
			else if (request$1.responseTainting === "opaque") response = filterResponse(response, "opaque");
			else assert$3(false);
		}
		let internalResponse = response.status === 0 ? response : response.internalResponse;
		if (internalResponse.urlList.length === 0) internalResponse.urlList.push(...request$1.urlList);
		if (!request$1.timingAllowFailed) response.timingAllowPassed = true;
		if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request$1.headers.contains("range")) response = internalResponse = makeNetworkError();
		if (response.status !== 0 && (request$1.method === "HEAD" || request$1.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
			internalResponse.body = null;
			fetchParams.controller.dump = true;
		}
		if (request$1.integrity) {
			const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
			if (request$1.responseTainting === "opaque" || response.body == null) {
				processBodyError(response.error);
				return;
			}
			const processBody = (bytes) => {
				if (!bytesMatch(bytes, request$1.integrity)) {
					processBodyError("integrity mismatch");
					return;
				}
				response.body = safelyExtractBody(bytes)[0];
				fetchFinale(fetchParams, response);
			};
			await fullyReadBody(response.body, processBody, processBodyError);
		} else fetchFinale(fetchParams, response);
	}
	function schemeFetch(fetchParams) {
		if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) return Promise.resolve(makeAppropriateNetworkError(fetchParams));
		const { request: request$1 } = fetchParams;
		const { protocol: scheme } = requestCurrentURL(request$1);
		switch (scheme) {
			case "about:": return Promise.resolve(makeNetworkError("about scheme is not supported"));
			case "blob:": {
				if (!resolveObjectURL) resolveObjectURL = __require("buffer").resolveObjectURL;
				const blobURLEntry = requestCurrentURL(request$1);
				if (blobURLEntry.search.length !== 0) return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
				const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
				if (request$1.method !== "GET" || !isBlobLike$1(blobURLEntryObject)) return Promise.resolve(makeNetworkError("invalid method"));
				const bodyWithType = safelyExtractBody(blobURLEntryObject);
				const body = bodyWithType[0];
				const length = isomorphicEncode(`${body.length}`);
				const type = bodyWithType[1] ?? "";
				const response = makeResponse({
					statusText: "OK",
					headersList: [["content-length", {
						name: "Content-Length",
						value: length
					}], ["content-type", {
						name: "Content-Type",
						value: type
					}]]
				});
				response.body = body;
				return Promise.resolve(response);
			}
			case "data:": {
				const dataURLStruct = dataURLProcessor(requestCurrentURL(request$1));
				if (dataURLStruct === "failure") return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
				const mimeType = serializeAMimeType$1(dataURLStruct.mimeType);
				return Promise.resolve(makeResponse({
					statusText: "OK",
					headersList: [["content-type", {
						name: "Content-Type",
						value: mimeType
					}]],
					body: safelyExtractBody(dataURLStruct.body)[0]
				}));
			}
			case "file:": return Promise.resolve(makeNetworkError("not implemented... yet..."));
			case "http:":
			case "https:": return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
			default: return Promise.resolve(makeNetworkError("unknown scheme"));
		}
	}
	function finalizeResponse(fetchParams, response) {
		fetchParams.request.done = true;
		if (fetchParams.processResponseDone != null) queueMicrotask(() => fetchParams.processResponseDone(response));
	}
	function fetchFinale(fetchParams, response) {
		if (response.type === "error") {
			response.urlList = [fetchParams.request.urlList[0]];
			response.timingInfo = createOpaqueTimingInfo({ startTime: fetchParams.timingInfo.startTime });
		}
		const processResponseEndOfBody = () => {
			fetchParams.request.done = true;
			if (fetchParams.processResponseEndOfBody != null) queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
		};
		if (fetchParams.processResponse != null) queueMicrotask(() => fetchParams.processResponse(response));
		if (response.body == null) processResponseEndOfBody();
		else {
			const identityTransformAlgorithm = (chunk, controller) => {
				controller.enqueue(chunk);
			};
			const transformStream = new TransformStream$1({
				start() {},
				transform: identityTransformAlgorithm,
				flush: processResponseEndOfBody
			}, { size() {
				return 1;
			} }, { size() {
				return 1;
			} });
			response.body = { stream: response.body.stream.pipeThrough(transformStream) };
		}
		if (fetchParams.processResponseConsumeBody != null) {
			const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
			const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
			if (response.body == null) queueMicrotask(() => processBody(null));
			else return fullyReadBody(response.body, processBody, processBodyError);
			return Promise.resolve();
		}
	}
	async function httpFetch(fetchParams) {
		const request$1 = fetchParams.request;
		let response = null;
		let actualResponse = null;
		const timingInfo = fetchParams.timingInfo;
		if (request$1.serviceWorkers === "all") {}
		if (response === null) {
			if (request$1.redirect === "follow") request$1.serviceWorkers = "none";
			actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
			if (request$1.responseTainting === "cors" && corsCheck(request$1, response) === "failure") return makeNetworkError("cors failure");
			if (TAOCheck(request$1, response) === "failure") request$1.timingAllowFailed = true;
		}
		if ((request$1.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request$1.origin, request$1.client, request$1.destination, actualResponse) === "blocked") return makeNetworkError("blocked");
		if (redirectStatusSet.has(actualResponse.status)) {
			if (request$1.redirect !== "manual") fetchParams.controller.connection.destroy();
			if (request$1.redirect === "error") response = makeNetworkError("unexpected redirect");
			else if (request$1.redirect === "manual") response = actualResponse;
			else if (request$1.redirect === "follow") response = await httpRedirectFetch(fetchParams, response);
			else assert$3(false);
		}
		response.timingInfo = timingInfo;
		return response;
	}
	function httpRedirectFetch(fetchParams, response) {
		const request$1 = fetchParams.request;
		const actualResponse = response.internalResponse ? response.internalResponse : response;
		let locationURL;
		try {
			locationURL = responseLocationURL(actualResponse, requestCurrentURL(request$1).hash);
			if (locationURL == null) return response;
		} catch (err) {
			return Promise.resolve(makeNetworkError(err));
		}
		if (!urlIsHttpHttpsScheme$1(locationURL)) return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
		if (request$1.redirectCount === 20) return Promise.resolve(makeNetworkError("redirect count exceeded"));
		request$1.redirectCount += 1;
		if (request$1.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request$1, locationURL)) return Promise.resolve(makeNetworkError("cross origin not allowed for request mode \"cors\""));
		if (request$1.responseTainting === "cors" && (locationURL.username || locationURL.password)) return Promise.resolve(makeNetworkError("URL cannot contain credentials for request mode \"cors\""));
		if (actualResponse.status !== 303 && request$1.body != null && request$1.body.source == null) return Promise.resolve(makeNetworkError());
		if ([301, 302].includes(actualResponse.status) && request$1.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request$1.method)) {
			request$1.method = "GET";
			request$1.body = null;
			for (const headerName of requestBodyHeader) request$1.headersList.delete(headerName);
		}
		if (!sameOrigin(requestCurrentURL(request$1), locationURL)) {
			request$1.headersList.delete("authorization");
			request$1.headersList.delete("proxy-authorization", true);
			request$1.headersList.delete("cookie");
			request$1.headersList.delete("host");
		}
		if (request$1.body != null) {
			assert$3(request$1.body.source != null);
			request$1.body = safelyExtractBody(request$1.body.source)[0];
		}
		const timingInfo = fetchParams.timingInfo;
		timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
		if (timingInfo.redirectStartTime === 0) timingInfo.redirectStartTime = timingInfo.startTime;
		request$1.urlList.push(locationURL);
		setRequestReferrerPolicyOnRedirect(request$1, actualResponse);
		return mainFetch(fetchParams, true);
	}
	async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
		const request$1 = fetchParams.request;
		let httpFetchParams = null;
		let httpRequest$1 = null;
		let response = null;
		const httpCache = null;
		if (request$1.window === "no-window" && request$1.redirect === "error") {
			httpFetchParams = fetchParams;
			httpRequest$1 = request$1;
		} else {
			httpRequest$1 = makeRequest$1(request$1);
			httpFetchParams = { ...fetchParams };
			httpFetchParams.request = httpRequest$1;
		}
		const includeCredentials = request$1.credentials === "include" || request$1.credentials === "same-origin" && request$1.responseTainting === "basic";
		const contentLength = httpRequest$1.body ? httpRequest$1.body.length : null;
		let contentLengthHeaderValue = null;
		if (httpRequest$1.body == null && ["POST", "PUT"].includes(httpRequest$1.method)) contentLengthHeaderValue = "0";
		if (contentLength != null) contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
		if (contentLengthHeaderValue != null) httpRequest$1.headersList.append("content-length", contentLengthHeaderValue);
		if (contentLength != null && httpRequest$1.keepalive) {}
		if (httpRequest$1.referrer instanceof URL) httpRequest$1.headersList.append("referer", isomorphicEncode(httpRequest$1.referrer.href));
		appendRequestOriginHeader(httpRequest$1);
		appendFetchMetadata(httpRequest$1);
		if (!httpRequest$1.headersList.contains("user-agent")) httpRequest$1.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
		if (httpRequest$1.cache === "default" && (httpRequest$1.headersList.contains("if-modified-since") || httpRequest$1.headersList.contains("if-none-match") || httpRequest$1.headersList.contains("if-unmodified-since") || httpRequest$1.headersList.contains("if-match") || httpRequest$1.headersList.contains("if-range"))) httpRequest$1.cache = "no-store";
		if (httpRequest$1.cache === "no-cache" && !httpRequest$1.preventNoCacheCacheControlHeaderModification && !httpRequest$1.headersList.contains("cache-control")) httpRequest$1.headersList.append("cache-control", "max-age=0");
		if (httpRequest$1.cache === "no-store" || httpRequest$1.cache === "reload") {
			if (!httpRequest$1.headersList.contains("pragma")) httpRequest$1.headersList.append("pragma", "no-cache");
			if (!httpRequest$1.headersList.contains("cache-control")) httpRequest$1.headersList.append("cache-control", "no-cache");
		}
		if (httpRequest$1.headersList.contains("range")) httpRequest$1.headersList.append("accept-encoding", "identity");
		if (!httpRequest$1.headersList.contains("accept-encoding")) if (urlHasHttpsScheme(requestCurrentURL(httpRequest$1))) httpRequest$1.headersList.append("accept-encoding", "br, gzip, deflate");
		else httpRequest$1.headersList.append("accept-encoding", "gzip, deflate");
		httpRequest$1.headersList.delete("host");
		if (includeCredentials) {}
		if (httpCache == null) httpRequest$1.cache = "no-store";
		if (httpRequest$1.mode !== "no-store" && httpRequest$1.mode !== "reload") {}
		if (response == null) {
			if (httpRequest$1.mode === "only-if-cached") return makeNetworkError("only if cached");
			const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
			if (!safeMethodsSet.has(httpRequest$1.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {}
			if (response == null) response = forwardResponse;
		}
		response.urlList = [...httpRequest$1.urlList];
		if (httpRequest$1.headersList.contains("range")) response.rangeRequested = true;
		response.requestIncludesCredentials = includeCredentials;
		if (response.status === 407) {
			if (request$1.window === "no-window") return makeNetworkError();
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			return makeNetworkError("proxy authentication required");
		}
		if (response.status === 421 && !isNewConnectionFetch && (request$1.body == null || request$1.body.source != null)) {
			if (isCancelled(fetchParams)) return makeAppropriateNetworkError(fetchParams);
			fetchParams.controller.connection.destroy();
			response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
		}
		if (isAuthenticationFetch) {}
		return response;
	}
	async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
		assert$3(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
		fetchParams.controller.connection = {
			abort: null,
			destroyed: false,
			destroy(err) {
				if (!this.destroyed) {
					this.destroyed = true;
					this.abort?.(err ?? new DOMException$3("The operation was aborted.", "AbortError"));
				}
			}
		};
		const request$1 = fetchParams.request;
		let response = null;
		const timingInfo = fetchParams.timingInfo;
		request$1.cache = "no-store";
		if (request$1.mode === "websocket") {}
		let requestBody = null;
		if (request$1.body == null && fetchParams.processRequestEndOfBody) queueMicrotask(() => fetchParams.processRequestEndOfBody());
		else if (request$1.body != null) {
			const processBodyChunk = async function* (bytes) {
				if (isCancelled(fetchParams)) return;
				yield bytes;
				fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
			};
			const processEndOfBody = () => {
				if (isCancelled(fetchParams)) return;
				if (fetchParams.processRequestEndOfBody) fetchParams.processRequestEndOfBody();
			};
			const processBodyError = (e$5) => {
				if (isCancelled(fetchParams)) return;
				if (e$5.name === "AbortError") fetchParams.controller.abort();
				else fetchParams.controller.terminate(e$5);
			};
			requestBody = (async function* () {
				try {
					for await (const bytes of request$1.body.stream) yield* processBodyChunk(bytes);
					processEndOfBody();
				} catch (err) {
					processBodyError(err);
				}
			})();
		}
		try {
			const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
			if (socket) response = makeResponse({
				status,
				statusText,
				headersList,
				socket
			});
			else {
				const iterator = body[Symbol.asyncIterator]();
				fetchParams.controller.next = () => iterator.next();
				response = makeResponse({
					status,
					statusText,
					headersList
				});
			}
		} catch (err) {
			if (err.name === "AbortError") {
				fetchParams.controller.connection.destroy();
				return makeAppropriateNetworkError(fetchParams, err);
			}
			return makeNetworkError(err);
		}
		const pullAlgorithm = () => {
			fetchParams.controller.resume();
		};
		const cancelAlgorithm = (reason) => {
			fetchParams.controller.abort(reason);
		};
		if (!ReadableStream$1) ReadableStream$1 = __require("stream/web").ReadableStream;
		const stream$3 = new ReadableStream$1({
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm(controller);
			},
			async cancel(reason) {
				await cancelAlgorithm(reason);
			}
		}, {
			highWaterMark: 0,
			size() {
				return 1;
			}
		});
		response.body = { stream: stream$3 };
		fetchParams.controller.on("terminated", onAborted);
		fetchParams.controller.resume = async () => {
			while (true) {
				let bytes;
				let isFailure;
				try {
					const { done, value } = await fetchParams.controller.next();
					if (isAborted(fetchParams)) break;
					bytes = done ? void 0 : value;
				} catch (err) {
					if (fetchParams.controller.ended && !timingInfo.encodedBodySize) bytes = void 0;
					else {
						bytes = err;
						isFailure = true;
					}
				}
				if (bytes === void 0) {
					readableStreamClose(fetchParams.controller.controller);
					finalizeResponse(fetchParams, response);
					return;
				}
				timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
				if (isFailure) {
					fetchParams.controller.terminate(bytes);
					return;
				}
				fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
				if (isErrored(stream$3)) {
					fetchParams.controller.terminate();
					return;
				}
				if (!fetchParams.controller.controller.desiredSize) return;
			}
		};
		function onAborted(reason) {
			if (isAborted(fetchParams)) {
				response.aborted = true;
				if (isReadable(stream$3)) fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
			} else if (isReadable(stream$3)) fetchParams.controller.controller.error(new TypeError("terminated", { cause: isErrorLike(reason) ? reason : void 0 }));
			fetchParams.controller.connection.destroy();
		}
		return response;
		async function dispatch({ body }) {
			const url$1 = requestCurrentURL(request$1);
			/** @type {import('../..').Agent} */
			const agent = fetchParams.controller.dispatcher;
			return new Promise((resolve, reject) => agent.dispatch({
				path: url$1.pathname + url$1.search,
				origin: url$1.origin,
				method: request$1.method,
				body: fetchParams.controller.dispatcher.isMockActive ? request$1.body && (request$1.body.source || request$1.body.stream) : body,
				headers: request$1.headersList.entries,
				maxRedirections: 0,
				upgrade: request$1.mode === "websocket" ? "websocket" : void 0
			}, {
				body: null,
				abort: null,
				onConnect(abort$1) {
					const { connection } = fetchParams.controller;
					if (connection.destroyed) abort$1(new DOMException$3("The operation was aborted.", "AbortError"));
					else {
						fetchParams.controller.on("terminated", abort$1);
						this.abort = connection.abort = abort$1;
					}
				},
				onHeaders(status, headersList, resume$1, statusText) {
					if (status < 200) return;
					let codings = [];
					let location = "";
					const headers = new Headers$4();
					if (Array.isArray(headersList)) for (let n$5 = 0; n$5 < headersList.length; n$5 += 2) {
						const key = headersList[n$5 + 0].toString("latin1");
						const val = headersList[n$5 + 1].toString("latin1");
						if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x$5) => x$5.trim());
						else if (key.toLowerCase() === "location") location = val;
						headers[kHeadersList$2].append(key, val);
					}
					else {
						const keys = Object.keys(headersList);
						for (const key of keys) {
							const val = headersList[key];
							if (key.toLowerCase() === "content-encoding") codings = val.toLowerCase().split(",").map((x$5) => x$5.trim()).reverse();
							else if (key.toLowerCase() === "location") location = val;
							headers[kHeadersList$2].append(key, val);
						}
					}
					this.body = new Readable({ read: resume$1 });
					const decoders$1 = [];
					const willFollow = request$1.redirect === "follow" && location && redirectStatusSet.has(status);
					if (request$1.method !== "HEAD" && request$1.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) for (const coding of codings) if (coding === "x-gzip" || coding === "gzip") decoders$1.push(zlib.createGunzip({
						flush: zlib.constants.Z_SYNC_FLUSH,
						finishFlush: zlib.constants.Z_SYNC_FLUSH
					}));
					else if (coding === "deflate") decoders$1.push(zlib.createInflate());
					else if (coding === "br") decoders$1.push(zlib.createBrotliDecompress());
					else {
						decoders$1.length = 0;
						break;
					}
					resolve({
						status,
						statusText,
						headersList: headers[kHeadersList$2],
						body: decoders$1.length ? pipeline(this.body, ...decoders$1, () => {}) : this.body.on("error", () => {})
					});
					return true;
				},
				onData(chunk) {
					if (fetchParams.controller.dump) return;
					const bytes = chunk;
					timingInfo.encodedBodySize += bytes.byteLength;
					return this.body.push(bytes);
				},
				onComplete() {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					fetchParams.controller.ended = true;
					this.body.push(null);
				},
				onError(error$2) {
					if (this.abort) fetchParams.controller.off("terminated", this.abort);
					this.body?.destroy(error$2);
					fetchParams.controller.terminate(error$2);
					reject(error$2);
				},
				onUpgrade(status, headersList, socket) {
					if (status !== 101) return;
					const headers = new Headers$4();
					for (let n$5 = 0; n$5 < headersList.length; n$5 += 2) {
						const key = headersList[n$5 + 0].toString("latin1");
						const val = headersList[n$5 + 1].toString("latin1");
						headers[kHeadersList$2].append(key, val);
					}
					resolve({
						status,
						statusText: STATUS_CODES[status],
						headersList: headers[kHeadersList$2],
						socket
					});
					return true;
				}
			}));
		}
	}
	module.exports = {
		fetch: fetch$1,
		Fetch,
		fetching: fetching$2,
		finalizeAndReportTiming
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/symbols.js
var require_symbols$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kState: Symbol("FileReader state"),
		kResult: Symbol("FileReader result"),
		kError: Symbol("FileReader error"),
		kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
		kEvents: Symbol("FileReader events"),
		kAborted: Symbol("FileReader aborted")
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl: webidl$6 } = require_webidl();
	const kState$3 = Symbol("ProgressEvent state");
	/**
	* @see https://xhr.spec.whatwg.org/#progressevent
	*/
	var ProgressEvent$1 = class ProgressEvent$1 extends Event {
		constructor(type, eventInitDict = {}) {
			type = webidl$6.converters.DOMString(type);
			eventInitDict = webidl$6.converters.ProgressEventInit(eventInitDict ?? {});
			super(type, eventInitDict);
			this[kState$3] = {
				lengthComputable: eventInitDict.lengthComputable,
				loaded: eventInitDict.loaded,
				total: eventInitDict.total
			};
		}
		get lengthComputable() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].lengthComputable;
		}
		get loaded() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].loaded;
		}
		get total() {
			webidl$6.brandCheck(this, ProgressEvent$1);
			return this[kState$3].total;
		}
	};
	webidl$6.converters.ProgressEventInit = webidl$6.dictionaryConverter([
		{
			key: "lengthComputable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "loaded",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "total",
			converter: webidl$6.converters["unsigned long long"],
			defaultValue: 0
		},
		{
			key: "bubbles",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$6.converters.boolean,
			defaultValue: false
		}
	]);
	module.exports = { ProgressEvent: ProgressEvent$1 };
}));

//#endregion
//#region node_modules/undici/lib/fileapi/encoding.js
var require_encoding = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* @see https://encoding.spec.whatwg.org/#concept-encoding-get
	* @param {string|undefined} label
	*/
	function getEncoding$1(label) {
		if (!label) return "failure";
		switch (label.trim().toLowerCase()) {
			case "unicode-1-1-utf-8":
			case "unicode11utf8":
			case "unicode20utf8":
			case "utf-8":
			case "utf8":
			case "x-unicode20utf8": return "UTF-8";
			case "866":
			case "cp866":
			case "csibm866":
			case "ibm866": return "IBM866";
			case "csisolatin2":
			case "iso-8859-2":
			case "iso-ir-101":
			case "iso8859-2":
			case "iso88592":
			case "iso_8859-2":
			case "iso_8859-2:1987":
			case "l2":
			case "latin2": return "ISO-8859-2";
			case "csisolatin3":
			case "iso-8859-3":
			case "iso-ir-109":
			case "iso8859-3":
			case "iso88593":
			case "iso_8859-3":
			case "iso_8859-3:1988":
			case "l3":
			case "latin3": return "ISO-8859-3";
			case "csisolatin4":
			case "iso-8859-4":
			case "iso-ir-110":
			case "iso8859-4":
			case "iso88594":
			case "iso_8859-4":
			case "iso_8859-4:1988":
			case "l4":
			case "latin4": return "ISO-8859-4";
			case "csisolatincyrillic":
			case "cyrillic":
			case "iso-8859-5":
			case "iso-ir-144":
			case "iso8859-5":
			case "iso88595":
			case "iso_8859-5":
			case "iso_8859-5:1988": return "ISO-8859-5";
			case "arabic":
			case "asmo-708":
			case "csiso88596e":
			case "csiso88596i":
			case "csisolatinarabic":
			case "ecma-114":
			case "iso-8859-6":
			case "iso-8859-6-e":
			case "iso-8859-6-i":
			case "iso-ir-127":
			case "iso8859-6":
			case "iso88596":
			case "iso_8859-6":
			case "iso_8859-6:1987": return "ISO-8859-6";
			case "csisolatingreek":
			case "ecma-118":
			case "elot_928":
			case "greek":
			case "greek8":
			case "iso-8859-7":
			case "iso-ir-126":
			case "iso8859-7":
			case "iso88597":
			case "iso_8859-7":
			case "iso_8859-7:1987":
			case "sun_eu_greek": return "ISO-8859-7";
			case "csiso88598e":
			case "csisolatinhebrew":
			case "hebrew":
			case "iso-8859-8":
			case "iso-8859-8-e":
			case "iso-ir-138":
			case "iso8859-8":
			case "iso88598":
			case "iso_8859-8":
			case "iso_8859-8:1988":
			case "visual": return "ISO-8859-8";
			case "csiso88598i":
			case "iso-8859-8-i":
			case "logical": return "ISO-8859-8-I";
			case "csisolatin6":
			case "iso-8859-10":
			case "iso-ir-157":
			case "iso8859-10":
			case "iso885910":
			case "l6":
			case "latin6": return "ISO-8859-10";
			case "iso-8859-13":
			case "iso8859-13":
			case "iso885913": return "ISO-8859-13";
			case "iso-8859-14":
			case "iso8859-14":
			case "iso885914": return "ISO-8859-14";
			case "csisolatin9":
			case "iso-8859-15":
			case "iso8859-15":
			case "iso885915":
			case "iso_8859-15":
			case "l9": return "ISO-8859-15";
			case "iso-8859-16": return "ISO-8859-16";
			case "cskoi8r":
			case "koi":
			case "koi8":
			case "koi8-r":
			case "koi8_r": return "KOI8-R";
			case "koi8-ru":
			case "koi8-u": return "KOI8-U";
			case "csmacintosh":
			case "mac":
			case "macintosh":
			case "x-mac-roman": return "macintosh";
			case "iso-8859-11":
			case "iso8859-11":
			case "iso885911":
			case "tis-620":
			case "windows-874": return "windows-874";
			case "cp1250":
			case "windows-1250":
			case "x-cp1250": return "windows-1250";
			case "cp1251":
			case "windows-1251":
			case "x-cp1251": return "windows-1251";
			case "ansi_x3.4-1968":
			case "ascii":
			case "cp1252":
			case "cp819":
			case "csisolatin1":
			case "ibm819":
			case "iso-8859-1":
			case "iso-ir-100":
			case "iso8859-1":
			case "iso88591":
			case "iso_8859-1":
			case "iso_8859-1:1987":
			case "l1":
			case "latin1":
			case "us-ascii":
			case "windows-1252":
			case "x-cp1252": return "windows-1252";
			case "cp1253":
			case "windows-1253":
			case "x-cp1253": return "windows-1253";
			case "cp1254":
			case "csisolatin5":
			case "iso-8859-9":
			case "iso-ir-148":
			case "iso8859-9":
			case "iso88599":
			case "iso_8859-9":
			case "iso_8859-9:1989":
			case "l5":
			case "latin5":
			case "windows-1254":
			case "x-cp1254": return "windows-1254";
			case "cp1255":
			case "windows-1255":
			case "x-cp1255": return "windows-1255";
			case "cp1256":
			case "windows-1256":
			case "x-cp1256": return "windows-1256";
			case "cp1257":
			case "windows-1257":
			case "x-cp1257": return "windows-1257";
			case "cp1258":
			case "windows-1258":
			case "x-cp1258": return "windows-1258";
			case "x-mac-cyrillic":
			case "x-mac-ukrainian": return "x-mac-cyrillic";
			case "chinese":
			case "csgb2312":
			case "csiso58gb231280":
			case "gb2312":
			case "gb_2312":
			case "gb_2312-80":
			case "gbk":
			case "iso-ir-58":
			case "x-gbk": return "GBK";
			case "gb18030": return "gb18030";
			case "big5":
			case "big5-hkscs":
			case "cn-big5":
			case "csbig5":
			case "x-x-big5": return "Big5";
			case "cseucpkdfmtjapanese":
			case "euc-jp":
			case "x-euc-jp": return "EUC-JP";
			case "csiso2022jp":
			case "iso-2022-jp": return "ISO-2022-JP";
			case "csshiftjis":
			case "ms932":
			case "ms_kanji":
			case "shift-jis":
			case "shift_jis":
			case "sjis":
			case "windows-31j":
			case "x-sjis": return "Shift_JIS";
			case "cseuckr":
			case "csksc56011987":
			case "euc-kr":
			case "iso-ir-149":
			case "korean":
			case "ks_c_5601-1987":
			case "ks_c_5601-1989":
			case "ksc5601":
			case "ksc_5601":
			case "windows-949": return "EUC-KR";
			case "csiso2022kr":
			case "hz-gb-2312":
			case "iso-2022-cn":
			case "iso-2022-cn-ext":
			case "iso-2022-kr":
			case "replacement": return "replacement";
			case "unicodefffe":
			case "utf-16be": return "UTF-16BE";
			case "csunicode":
			case "iso-10646-ucs-2":
			case "ucs-2":
			case "unicode":
			case "unicodefeff":
			case "utf-16":
			case "utf-16le": return "UTF-16LE";
			case "x-user-defined": return "x-user-defined";
			default: return "failure";
		}
	}
	module.exports = { getEncoding: getEncoding$1 };
}));

//#endregion
//#region node_modules/undici/lib/fileapi/util.js
var require_util$3 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kState: kState$2, kError: kError$1, kResult: kResult$1, kAborted: kAborted$1, kLastProgressEventFired } = require_symbols$2();
	const { ProgressEvent } = require_progressevent();
	const { getEncoding } = require_encoding();
	const { DOMException: DOMException$2 } = require_constants$3();
	const { serializeAMimeType, parseMIMEType } = require_dataURL();
	const { types: types$6 } = __require("util");
	const { StringDecoder } = __require("string_decoder");
	const { btoa } = __require("buffer");
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$3 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	/**
	* @see https://w3c.github.io/FileAPI/#readOperation
	* @param {import('./filereader').FileReader} fr
	* @param {import('buffer').Blob} blob
	* @param {string} type
	* @param {string?} encodingName
	*/
	function readOperation$1(fr, blob, type, encodingName) {
		if (fr[kState$2] === "loading") throw new DOMException$2("Invalid state", "InvalidStateError");
		fr[kState$2] = "loading";
		fr[kResult$1] = null;
		fr[kError$1] = null;
		const reader = blob.stream().getReader();
		/** @type {Uint8Array[]} */
		const bytes = [];
		let chunkPromise = reader.read();
		let isFirstChunk = true;
		(async () => {
			while (!fr[kAborted$1]) try {
				const { done, value } = await chunkPromise;
				if (isFirstChunk && !fr[kAborted$1]) queueMicrotask(() => {
					fireAProgressEvent$1("loadstart", fr);
				});
				isFirstChunk = false;
				if (!done && types$6.isUint8Array(value)) {
					bytes.push(value);
					if ((fr[kLastProgressEventFired] === void 0 || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted$1]) {
						fr[kLastProgressEventFired] = Date.now();
						queueMicrotask(() => {
							fireAProgressEvent$1("progress", fr);
						});
					}
					chunkPromise = reader.read();
				} else if (done) {
					queueMicrotask(() => {
						fr[kState$2] = "done";
						try {
							const result = packageData(bytes, type, blob.type, encodingName);
							if (fr[kAborted$1]) return;
							fr[kResult$1] = result;
							fireAProgressEvent$1("load", fr);
						} catch (error$2) {
							fr[kError$1] = error$2;
							fireAProgressEvent$1("error", fr);
						}
						if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
					});
					break;
				}
			} catch (error$2) {
				if (fr[kAborted$1]) return;
				queueMicrotask(() => {
					fr[kState$2] = "done";
					fr[kError$1] = error$2;
					fireAProgressEvent$1("error", fr);
					if (fr[kState$2] !== "loading") fireAProgressEvent$1("loadend", fr);
				});
				break;
			}
		})();
	}
	/**
	* @see https://w3c.github.io/FileAPI/#fire-a-progress-event
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e The name of the event
	* @param {import('./filereader').FileReader} reader
	*/
	function fireAProgressEvent$1(e$5, reader) {
		const event = new ProgressEvent(e$5, {
			bubbles: false,
			cancelable: false
		});
		reader.dispatchEvent(event);
	}
	/**
	* @see https://w3c.github.io/FileAPI/#blob-package-data
	* @param {Uint8Array[]} bytes
	* @param {string} type
	* @param {string?} mimeType
	* @param {string?} encodingName
	*/
	function packageData(bytes, type, mimeType, encodingName) {
		switch (type) {
			case "DataURL": {
				let dataURL = "data:";
				const parsed = parseMIMEType(mimeType || "application/octet-stream");
				if (parsed !== "failure") dataURL += serializeAMimeType(parsed);
				dataURL += ";base64,";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) dataURL += btoa(decoder.write(chunk));
				dataURL += btoa(decoder.end());
				return dataURL;
			}
			case "Text": {
				let encoding = "failure";
				if (encodingName) encoding = getEncoding(encodingName);
				if (encoding === "failure" && mimeType) {
					const type$1 = parseMIMEType(mimeType);
					if (type$1 !== "failure") encoding = getEncoding(type$1.parameters.get("charset"));
				}
				if (encoding === "failure") encoding = "UTF-8";
				return decode$1(bytes, encoding);
			}
			case "ArrayBuffer": return combineByteSequences(bytes).buffer;
			case "BinaryString": {
				let binaryString = "";
				const decoder = new StringDecoder("latin1");
				for (const chunk of bytes) binaryString += decoder.write(chunk);
				binaryString += decoder.end();
				return binaryString;
			}
		}
	}
	/**
	* @see https://encoding.spec.whatwg.org/#decode
	* @param {Uint8Array[]} ioQueue
	* @param {string} encoding
	*/
	function decode$1(ioQueue, encoding) {
		const bytes = combineByteSequences(ioQueue);
		const BOMEncoding = BOMSniffing(bytes);
		let slice = 0;
		if (BOMEncoding !== null) {
			encoding = BOMEncoding;
			slice = BOMEncoding === "UTF-8" ? 3 : 2;
		}
		const sliced = bytes.slice(slice);
		return new TextDecoder(encoding).decode(sliced);
	}
	/**
	* @see https://encoding.spec.whatwg.org/#bom-sniff
	* @param {Uint8Array} ioQueue
	*/
	function BOMSniffing(ioQueue) {
		const [a$5, b$5, c$5] = ioQueue;
		if (a$5 === 239 && b$5 === 187 && c$5 === 191) return "UTF-8";
		else if (a$5 === 254 && b$5 === 255) return "UTF-16BE";
		else if (a$5 === 255 && b$5 === 254) return "UTF-16LE";
		return null;
	}
	/**
	* @param {Uint8Array[]} sequences
	*/
	function combineByteSequences(sequences) {
		const size = sequences.reduce((a$5, b$5) => {
			return a$5 + b$5.byteLength;
		}, 0);
		let offset = 0;
		return sequences.reduce((a$5, b$5) => {
			a$5.set(b$5, offset);
			offset += b$5.byteLength;
			return a$5;
		}, new Uint8Array(size));
	}
	module.exports = {
		staticPropertyDescriptors: staticPropertyDescriptors$3,
		readOperation: readOperation$1,
		fireAProgressEvent: fireAProgressEvent$1
	};
}));

//#endregion
//#region node_modules/undici/lib/fileapi/filereader.js
var require_filereader = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { staticPropertyDescriptors: staticPropertyDescriptors$2, readOperation, fireAProgressEvent } = require_util$3();
	const { kState: kState$1, kError, kResult, kEvents, kAborted } = require_symbols$2();
	const { webidl: webidl$5 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$4 } = require_util$6();
	var FileReader$1 = class FileReader$1 extends EventTarget {
		constructor() {
			super();
			this[kState$1] = "empty";
			this[kResult] = null;
			this[kError] = null;
			this[kEvents] = {
				loadend: null,
				error: null,
				abort: null,
				load: null,
				progress: null,
				loadstart: null
			};
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
		* @param {import('buffer').Blob} blob
		*/
		readAsArrayBuffer(blob) {
			webidl$5.brandCheck(this, FileReader$1);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "ArrayBuffer");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsBinaryString
		* @param {import('buffer').Blob} blob
		*/
		readAsBinaryString(blob) {
			webidl$5.brandCheck(this, FileReader$1);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "BinaryString");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#readAsDataText
		* @param {import('buffer').Blob} blob
		* @param {string?} encoding
		*/
		readAsText(blob, encoding = void 0) {
			webidl$5.brandCheck(this, FileReader$1);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			if (encoding !== void 0) encoding = webidl$5.converters.DOMString(encoding);
			readOperation(this, blob, "Text", encoding);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
		* @param {import('buffer').Blob} blob
		*/
		readAsDataURL(blob) {
			webidl$5.brandCheck(this, FileReader$1);
			webidl$5.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
			blob = webidl$5.converters.Blob(blob, { strict: false });
			readOperation(this, blob, "DataURL");
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dfn-abort
		*/
		abort() {
			if (this[kState$1] === "empty" || this[kState$1] === "done") {
				this[kResult] = null;
				return;
			}
			if (this[kState$1] === "loading") {
				this[kState$1] = "done";
				this[kResult] = null;
			}
			this[kAborted] = true;
			fireAProgressEvent("abort", this);
			if (this[kState$1] !== "loading") fireAProgressEvent("loadend", this);
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
		*/
		get readyState() {
			webidl$5.brandCheck(this, FileReader$1);
			switch (this[kState$1]) {
				case "empty": return this.EMPTY;
				case "loading": return this.LOADING;
				case "done": return this.DONE;
			}
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-result
		*/
		get result() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kResult];
		}
		/**
		* @see https://w3c.github.io/FileAPI/#dom-filereader-error
		*/
		get error() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kError];
		}
		get onloadend() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].loadend;
		}
		set onloadend(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].loadend) this.removeEventListener("loadend", this[kEvents].loadend);
			if (typeof fn === "function") {
				this[kEvents].loadend = fn;
				this.addEventListener("loadend", fn);
			} else this[kEvents].loadend = null;
		}
		get onerror() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].error;
		}
		set onerror(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].error) this.removeEventListener("error", this[kEvents].error);
			if (typeof fn === "function") {
				this[kEvents].error = fn;
				this.addEventListener("error", fn);
			} else this[kEvents].error = null;
		}
		get onloadstart() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].loadstart;
		}
		set onloadstart(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].loadstart) this.removeEventListener("loadstart", this[kEvents].loadstart);
			if (typeof fn === "function") {
				this[kEvents].loadstart = fn;
				this.addEventListener("loadstart", fn);
			} else this[kEvents].loadstart = null;
		}
		get onprogress() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].progress;
		}
		set onprogress(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].progress) this.removeEventListener("progress", this[kEvents].progress);
			if (typeof fn === "function") {
				this[kEvents].progress = fn;
				this.addEventListener("progress", fn);
			} else this[kEvents].progress = null;
		}
		get onload() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].load;
		}
		set onload(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].load) this.removeEventListener("load", this[kEvents].load);
			if (typeof fn === "function") {
				this[kEvents].load = fn;
				this.addEventListener("load", fn);
			} else this[kEvents].load = null;
		}
		get onabort() {
			webidl$5.brandCheck(this, FileReader$1);
			return this[kEvents].abort;
		}
		set onabort(fn) {
			webidl$5.brandCheck(this, FileReader$1);
			if (this[kEvents].abort) this.removeEventListener("abort", this[kEvents].abort);
			if (typeof fn === "function") {
				this[kEvents].abort = fn;
				this.addEventListener("abort", fn);
			} else this[kEvents].abort = null;
		}
	};
	FileReader$1.EMPTY = FileReader$1.prototype.EMPTY = 0;
	FileReader$1.LOADING = FileReader$1.prototype.LOADING = 1;
	FileReader$1.DONE = FileReader$1.prototype.DONE = 2;
	Object.defineProperties(FileReader$1.prototype, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2,
		readAsArrayBuffer: kEnumerableProperty$4,
		readAsBinaryString: kEnumerableProperty$4,
		readAsText: kEnumerableProperty$4,
		readAsDataURL: kEnumerableProperty$4,
		abort: kEnumerableProperty$4,
		readyState: kEnumerableProperty$4,
		result: kEnumerableProperty$4,
		error: kEnumerableProperty$4,
		onloadstart: kEnumerableProperty$4,
		onprogress: kEnumerableProperty$4,
		onload: kEnumerableProperty$4,
		onabort: kEnumerableProperty$4,
		onerror: kEnumerableProperty$4,
		onloadend: kEnumerableProperty$4,
		[Symbol.toStringTag]: {
			value: "FileReader",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(FileReader$1, {
		EMPTY: staticPropertyDescriptors$2,
		LOADING: staticPropertyDescriptors$2,
		DONE: staticPropertyDescriptors$2
	});
	module.exports = { FileReader: FileReader$1 };
}));

//#endregion
//#region node_modules/undici/lib/cache/symbols.js
var require_symbols$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = { kConstruct: require_symbols$4().kConstruct };
}));

//#endregion
//#region node_modules/undici/lib/cache/util.js
var require_util$2 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const assert$2 = __require("assert");
	const { URLSerializer: URLSerializer$1 } = require_dataURL();
	const { isValidHeaderName } = require_util$5();
	/**
	* @see https://url.spec.whatwg.org/#concept-url-equals
	* @param {URL} A
	* @param {URL} B
	* @param {boolean | undefined} excludeFragment
	* @returns {boolean}
	*/
	function urlEquals$1(A$2, B$2, excludeFragment = false) {
		return URLSerializer$1(A$2, excludeFragment) === URLSerializer$1(B$2, excludeFragment);
	}
	/**
	* @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262
	* @param {string} header
	*/
	function fieldValues(header) {
		assert$2(header !== null);
		const values = [];
		for (let value of header.split(",")) {
			value = value.trim();
			if (!value.length) continue;
			else if (!isValidHeaderName(value)) continue;
			values.push(value);
		}
		return values;
	}
	module.exports = {
		urlEquals: urlEquals$1,
		fieldValues
	};
}));

//#endregion
//#region node_modules/undici/lib/cache/cache.js
var require_cache = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kConstruct: kConstruct$1 } = require_symbols$1();
	const { urlEquals, fieldValues: getFieldValues } = require_util$2();
	const { kEnumerableProperty: kEnumerableProperty$3, isDisturbed } = require_util$6();
	const { kHeadersList: kHeadersList$1 } = require_symbols$4();
	const { webidl: webidl$4 } = require_webidl();
	const { Response, cloneResponse } = require_response();
	const { Request: Request$1 } = require_request();
	const { kState, kHeaders, kGuard, kRealm } = require_symbols$3();
	const { fetching: fetching$1 } = require_fetch();
	const { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util$5();
	const assert$1 = __require("assert");
	const { getGlobalDispatcher: getGlobalDispatcher$3 } = require_global();
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation
	* @typedef {Object} CacheBatchOperation
	* @property {'delete' | 'put'} type
	* @property {any} request
	* @property {any} response
	* @property {import('../../types/cache').CacheQueryOptions} options
	*/
	/**
	* @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list
	* @typedef {[any, any][]} requestResponseList
	*/
	var Cache$1 = class Cache$1 {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
		* @type {requestResponseList}
		*/
		#relevantRequestResponseList;
		constructor() {
			if (arguments[0] !== kConstruct$1) webidl$4.illegalConstructor();
			this.#relevantRequestResponseList = arguments[1];
		}
		async match(request$1, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
			request$1 = webidl$4.converters.RequestInfo(request$1);
			options = webidl$4.converters.CacheQueryOptions(options);
			const p$5 = await this.matchAll(request$1, options);
			if (p$5.length === 0) return;
			return p$5[0];
		}
		async matchAll(request$1 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$1 !== void 0) request$1 = webidl$4.converters.RequestInfo(request$1);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r$5 = null;
			if (request$1 !== void 0) {
				if (request$1 instanceof Request$1) {
					r$5 = request$1[kState];
					if (r$5.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$1 === "string") r$5 = new Request$1(request$1)[kState];
			}
			const responses = [];
			if (request$1 === void 0) for (const requestResponse of this.#relevantRequestResponseList) responses.push(requestResponse[1]);
			else {
				const requestResponses = this.#queryCache(r$5, options);
				for (const requestResponse of requestResponses) responses.push(requestResponse[1]);
			}
			const responseList = [];
			for (const response of responses) {
				const responseObject = new Response(response.body?.source ?? null);
				const body = responseObject[kState].body;
				responseObject[kState] = response;
				responseObject[kState].body = body;
				responseObject[kHeaders][kHeadersList$1] = response.headersList;
				responseObject[kHeaders][kGuard] = "immutable";
				responseList.push(responseObject);
			}
			return Object.freeze(responseList);
		}
		async add(request$1) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
			request$1 = webidl$4.converters.RequestInfo(request$1);
			const requests = [request$1];
			return await this.addAll(requests);
		}
		async addAll(requests) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
			requests = webidl$4.converters["sequence<RequestInfo>"](requests);
			const responsePromises = [];
			const requestList = [];
			for (const request$1 of requests) {
				if (typeof request$1 === "string") continue;
				const r$5 = request$1[kState];
				if (!urlIsHttpHttpsScheme(r$5.url) || r$5.method !== "GET") throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme when method is not GET."
				});
			}
			/** @type {ReturnType<typeof fetching>[]} */
			const fetchControllers = [];
			for (const request$1 of requests) {
				const r$5 = new Request$1(request$1)[kState];
				if (!urlIsHttpHttpsScheme(r$5.url)) throw webidl$4.errors.exception({
					header: "Cache.addAll",
					message: "Expected http/s scheme."
				});
				r$5.initiator = "fetch";
				r$5.destination = "subresource";
				requestList.push(r$5);
				const responsePromise = createDeferredPromise();
				fetchControllers.push(fetching$1({
					request: r$5,
					dispatcher: getGlobalDispatcher$3(),
					processResponse(response) {
						if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) responsePromise.reject(webidl$4.errors.exception({
							header: "Cache.addAll",
							message: "Received an invalid status code or the request failed."
						}));
						else if (response.headersList.contains("vary")) {
							const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
							for (const fieldValue of fieldValues$1) if (fieldValue === "*") {
								responsePromise.reject(webidl$4.errors.exception({
									header: "Cache.addAll",
									message: "invalid vary field value"
								}));
								for (const controller of fetchControllers) controller.abort();
								return;
							}
						}
					},
					processResponseEndOfBody(response) {
						if (response.aborted) {
							responsePromise.reject(new DOMException("aborted", "AbortError"));
							return;
						}
						responsePromise.resolve(response);
					}
				}));
				responsePromises.push(responsePromise.promise);
			}
			const responses = await Promise.all(responsePromises);
			const operations = [];
			let index = 0;
			for (const response of responses) {
				/** @type {CacheBatchOperation} */
				const operation$1 = {
					type: "put",
					request: requestList[index],
					response
				};
				operations.push(operation$1);
				index++;
			}
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e$5) {
				errorData = e$5;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(void 0);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async put(request$1, response) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
			request$1 = webidl$4.converters.RequestInfo(request$1);
			response = webidl$4.converters.Response(response);
			let innerRequest = null;
			if (request$1 instanceof Request$1) innerRequest = request$1[kState];
			else innerRequest = new Request$1(request$1)[kState];
			if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Expected an http/s scheme when method is not GET"
			});
			const innerResponse = response[kState];
			if (innerResponse.status === 206) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Got 206 status"
			});
			if (innerResponse.headersList.contains("vary")) {
				const fieldValues$1 = getFieldValues(innerResponse.headersList.get("vary"));
				for (const fieldValue of fieldValues$1) if (fieldValue === "*") throw webidl$4.errors.exception({
					header: "Cache.put",
					message: "Got * vary field value"
				});
			}
			if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) throw webidl$4.errors.exception({
				header: "Cache.put",
				message: "Response body is locked or disturbed"
			});
			const clonedResponse = cloneResponse(innerResponse);
			const bodyReadPromise = createDeferredPromise();
			if (innerResponse.body != null) readAllBytes(innerResponse.body.stream.getReader()).then(bodyReadPromise.resolve, bodyReadPromise.reject);
			else bodyReadPromise.resolve(void 0);
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation$1 = {
				type: "put",
				request: innerRequest,
				response: clonedResponse
			};
			operations.push(operation$1);
			const bytes = await bodyReadPromise.promise;
			if (clonedResponse.body != null) clonedResponse.body.source = bytes;
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			try {
				this.#batchCacheOperations(operations);
			} catch (e$5) {
				errorData = e$5;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve();
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		async delete(request$1, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			webidl$4.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
			request$1 = webidl$4.converters.RequestInfo(request$1);
			options = webidl$4.converters.CacheQueryOptions(options);
			/**
			* @type {Request}
			*/
			let r$5 = null;
			if (request$1 instanceof Request$1) {
				r$5 = request$1[kState];
				if (r$5.method !== "GET" && !options.ignoreMethod) return false;
			} else {
				assert$1(typeof request$1 === "string");
				r$5 = new Request$1(request$1)[kState];
			}
			/** @type {CacheBatchOperation[]} */
			const operations = [];
			/** @type {CacheBatchOperation} */
			const operation$1 = {
				type: "delete",
				request: r$5,
				options
			};
			operations.push(operation$1);
			const cacheJobPromise = createDeferredPromise();
			let errorData = null;
			let requestResponses;
			try {
				requestResponses = this.#batchCacheOperations(operations);
			} catch (e$5) {
				errorData = e$5;
			}
			queueMicrotask(() => {
				if (errorData === null) cacheJobPromise.resolve(!!requestResponses?.length);
				else cacheJobPromise.reject(errorData);
			});
			return cacheJobPromise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
		* @param {any} request
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @returns {readonly Request[]}
		*/
		async keys(request$1 = void 0, options = {}) {
			webidl$4.brandCheck(this, Cache$1);
			if (request$1 !== void 0) request$1 = webidl$4.converters.RequestInfo(request$1);
			options = webidl$4.converters.CacheQueryOptions(options);
			let r$5 = null;
			if (request$1 !== void 0) {
				if (request$1 instanceof Request$1) {
					r$5 = request$1[kState];
					if (r$5.method !== "GET" && !options.ignoreMethod) return [];
				} else if (typeof request$1 === "string") r$5 = new Request$1(request$1)[kState];
			}
			const promise = createDeferredPromise();
			const requests = [];
			if (request$1 === void 0) for (const requestResponse of this.#relevantRequestResponseList) requests.push(requestResponse[0]);
			else {
				const requestResponses = this.#queryCache(r$5, options);
				for (const requestResponse of requestResponses) requests.push(requestResponse[0]);
			}
			queueMicrotask(() => {
				const requestList = [];
				for (const request$2 of requests) {
					const requestObject = new Request$1("https://a");
					requestObject[kState] = request$2;
					requestObject[kHeaders][kHeadersList$1] = request$2.headersList;
					requestObject[kHeaders][kGuard] = "immutable";
					requestObject[kRealm] = request$2.client;
					requestList.push(requestObject);
				}
				promise.resolve(Object.freeze(requestList));
			});
			return promise.promise;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
		* @param {CacheBatchOperation[]} operations
		* @returns {requestResponseList}
		*/
		#batchCacheOperations(operations) {
			const cache$5 = this.#relevantRequestResponseList;
			const backupCache = [...cache$5];
			const addedItems = [];
			const resultList = [];
			try {
				for (const operation$1 of operations) {
					if (operation$1.type !== "delete" && operation$1.type !== "put") throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "operation type does not match \"delete\" or \"put\""
					});
					if (operation$1.type === "delete" && operation$1.response != null) throw webidl$4.errors.exception({
						header: "Cache.#batchCacheOperations",
						message: "delete operation should not have an associated response"
					});
					if (this.#queryCache(operation$1.request, operation$1.options, addedItems).length) throw new DOMException("???", "InvalidStateError");
					let requestResponses;
					if (operation$1.type === "delete") {
						requestResponses = this.#queryCache(operation$1.request, operation$1.options);
						if (requestResponses.length === 0) return [];
						for (const requestResponse of requestResponses) {
							const idx = cache$5.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache$5.splice(idx, 1);
						}
					} else if (operation$1.type === "put") {
						if (operation$1.response == null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "put operation should have an associated response"
						});
						const r$5 = operation$1.request;
						if (!urlIsHttpHttpsScheme(r$5.url)) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "expected http or https scheme"
						});
						if (r$5.method !== "GET") throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "not get method"
						});
						if (operation$1.options != null) throw webidl$4.errors.exception({
							header: "Cache.#batchCacheOperations",
							message: "options must not be defined"
						});
						requestResponses = this.#queryCache(operation$1.request);
						for (const requestResponse of requestResponses) {
							const idx = cache$5.indexOf(requestResponse);
							assert$1(idx !== -1);
							cache$5.splice(idx, 1);
						}
						cache$5.push([operation$1.request, operation$1.response]);
						addedItems.push([operation$1.request, operation$1.response]);
					}
					resultList.push([operation$1.request, operation$1.response]);
				}
				return resultList;
			} catch (e$5) {
				this.#relevantRequestResponseList.length = 0;
				this.#relevantRequestResponseList = backupCache;
				throw e$5;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#query-cache
		* @param {any} requestQuery
		* @param {import('../../types/cache').CacheQueryOptions} options
		* @param {requestResponseList} targetStorage
		* @returns {requestResponseList}
		*/
		#queryCache(requestQuery, options, targetStorage) {
			/** @type {requestResponseList} */
			const resultList = [];
			const storage = targetStorage ?? this.#relevantRequestResponseList;
			for (const requestResponse of storage) {
				const [cachedRequest, cachedResponse] = requestResponse;
				if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) resultList.push(requestResponse);
			}
			return resultList;
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
		* @param {any} requestQuery
		* @param {any} request
		* @param {any | null} response
		* @param {import('../../types/cache').CacheQueryOptions | undefined} options
		* @returns {boolean}
		*/
		#requestMatchesCachedItem(requestQuery, request$1, response = null, options) {
			const queryURL = new URL(requestQuery.url);
			const cachedURL = new URL(request$1.url);
			if (options?.ignoreSearch) {
				cachedURL.search = "";
				queryURL.search = "";
			}
			if (!urlEquals(queryURL, cachedURL, true)) return false;
			if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) return true;
			const fieldValues$1 = getFieldValues(response.headersList.get("vary"));
			for (const fieldValue of fieldValues$1) {
				if (fieldValue === "*") return false;
				if (request$1.headersList.get(fieldValue) !== requestQuery.headersList.get(fieldValue)) return false;
			}
			return true;
		}
	};
	Object.defineProperties(Cache$1.prototype, {
		[Symbol.toStringTag]: {
			value: "Cache",
			configurable: true
		},
		match: kEnumerableProperty$3,
		matchAll: kEnumerableProperty$3,
		add: kEnumerableProperty$3,
		addAll: kEnumerableProperty$3,
		put: kEnumerableProperty$3,
		delete: kEnumerableProperty$3,
		keys: kEnumerableProperty$3
	});
	const cacheQueryOptionConverters = [
		{
			key: "ignoreSearch",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreMethod",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		},
		{
			key: "ignoreVary",
			converter: webidl$4.converters.boolean,
			defaultValue: false
		}
	];
	webidl$4.converters.CacheQueryOptions = webidl$4.dictionaryConverter(cacheQueryOptionConverters);
	webidl$4.converters.MultiCacheQueryOptions = webidl$4.dictionaryConverter([...cacheQueryOptionConverters, {
		key: "cacheName",
		converter: webidl$4.converters.DOMString
	}]);
	webidl$4.converters.Response = webidl$4.interfaceConverter(Response);
	webidl$4.converters["sequence<RequestInfo>"] = webidl$4.sequenceConverter(webidl$4.converters.RequestInfo);
	module.exports = { Cache: Cache$1 };
}));

//#endregion
//#region node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kConstruct } = require_symbols$1();
	const { Cache } = require_cache();
	const { webidl: webidl$3 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$2 } = require_util$6();
	var CacheStorage = class CacheStorage {
		/**
		* @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
		* @type {Map<string, import('./cache').requestResponseList}
		*/
		#caches = /* @__PURE__ */ new Map();
		constructor() {
			if (arguments[0] !== kConstruct) webidl$3.illegalConstructor();
		}
		async match(request$1, options = {}) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
			request$1 = webidl$3.converters.RequestInfo(request$1);
			options = webidl$3.converters.MultiCacheQueryOptions(options);
			if (options.cacheName != null) {
				if (this.#caches.has(options.cacheName)) return await new Cache(kConstruct, this.#caches.get(options.cacheName)).match(request$1, options);
			} else for (const cacheList of this.#caches.values()) {
				const response = await new Cache(kConstruct, cacheList).match(request$1, options);
				if (response !== void 0) return response;
			}
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-has
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async has(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.has(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
		* @param {string} cacheName
		* @returns {Promise<Cache>}
		*/
		async open(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			if (this.#caches.has(cacheName)) return new Cache(kConstruct, this.#caches.get(cacheName));
			const cache$5 = [];
			this.#caches.set(cacheName, cache$5);
			return new Cache(kConstruct, cache$5);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
		* @param {string} cacheName
		* @returns {Promise<boolean>}
		*/
		async delete(cacheName) {
			webidl$3.brandCheck(this, CacheStorage);
			webidl$3.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
			cacheName = webidl$3.converters.DOMString(cacheName);
			return this.#caches.delete(cacheName);
		}
		/**
		* @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
		* @returns {string[]}
		*/
		async keys() {
			webidl$3.brandCheck(this, CacheStorage);
			return [...this.#caches.keys()];
		}
	};
	Object.defineProperties(CacheStorage.prototype, {
		[Symbol.toStringTag]: {
			value: "CacheStorage",
			configurable: true
		},
		match: kEnumerableProperty$2,
		has: kEnumerableProperty$2,
		open: kEnumerableProperty$2,
		delete: kEnumerableProperty$2,
		keys: kEnumerableProperty$2
	});
	module.exports = { CacheStorage };
}));

//#endregion
//#region node_modules/undici/lib/cookies/constants.js
var require_constants$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const maxAttributeValueSize$1 = 1024;
	const maxNameValuePairSize$1 = 4096;
	module.exports = {
		maxAttributeValueSize: maxAttributeValueSize$1,
		maxNameValuePairSize: maxNameValuePairSize$1
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/util.js
var require_util$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	/**
	* @param {string} value
	* @returns {boolean}
	*/
	function isCTLExcludingHtab$1(value) {
		if (value.length === 0) return false;
		for (const char of value) {
			const code = char.charCodeAt(0);
			if (code >= 0 || code <= 8 || code >= 10 || code <= 31 || code === 127) return false;
		}
	}
	/**
	CHAR           = <any US-ASCII character (octets 0 - 127)>
	token          = 1*<any CHAR except CTLs or separators>
	separators     = "(" | ")" | "<" | ">" | "@"
	| "," | ";" | ":" | "\" | <">
	| "/" | "[" | "]" | "?" | "="
	| "{" | "}" | SP | HT
	* @param {string} name
	*/
	function validateCookieName(name) {
		for (const char of name) {
			const code = char.charCodeAt(0);
			if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") throw new Error("Invalid cookie name");
		}
	}
	/**
	cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
	cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
	; US-ASCII characters excluding CTLs,
	; whitespace DQUOTE, comma, semicolon,
	; and backslash
	* @param {string} value
	*/
	function validateCookieValue(value) {
		for (const char of value) {
			const code = char.charCodeAt(0);
			if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) throw new Error("Invalid header value");
		}
	}
	/**
	* path-value        = <any CHAR except CTLs or ";">
	* @param {string} path
	*/
	function validateCookiePath(path$6) {
		for (const char of path$6) if (char.charCodeAt(0) < 33 || char === ";") throw new Error("Invalid cookie path");
	}
	/**
	* I have no idea why these values aren't allowed to be honest,
	* but Deno tests these. - Khafra
	* @param {string} domain
	*/
	function validateCookieDomain(domain) {
		if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) throw new Error("Invalid cookie domain");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
	* @param {number|Date} date
	IMF-fixdate  = day-name "," SP date1 SP time-of-day SP GMT
	; fixed length/zone/capitalization subset of the format
	; see Section 3.3 of [RFC5322]
	
	day-name     = %x4D.6F.6E ; "Mon", case-sensitive
	/ %x54.75.65 ; "Tue", case-sensitive
	/ %x57.65.64 ; "Wed", case-sensitive
	/ %x54.68.75 ; "Thu", case-sensitive
	/ %x46.72.69 ; "Fri", case-sensitive
	/ %x53.61.74 ; "Sat", case-sensitive
	/ %x53.75.6E ; "Sun", case-sensitive
	date1        = day SP month SP year
	; e.g., 02 Jun 1982
	
	day          = 2DIGIT
	month        = %x4A.61.6E ; "Jan", case-sensitive
	/ %x46.65.62 ; "Feb", case-sensitive
	/ %x4D.61.72 ; "Mar", case-sensitive
	/ %x41.70.72 ; "Apr", case-sensitive
	/ %x4D.61.79 ; "May", case-sensitive
	/ %x4A.75.6E ; "Jun", case-sensitive
	/ %x4A.75.6C ; "Jul", case-sensitive
	/ %x41.75.67 ; "Aug", case-sensitive
	/ %x53.65.70 ; "Sep", case-sensitive
	/ %x4F.63.74 ; "Oct", case-sensitive
	/ %x4E.6F.76 ; "Nov", case-sensitive
	/ %x44.65.63 ; "Dec", case-sensitive
	year         = 4DIGIT
	
	GMT          = %x47.4D.54 ; "GMT", case-sensitive
	
	time-of-day  = hour ":" minute ":" second
	; 00:00:00 - 23:59:60 (leap second)
	
	hour         = 2DIGIT
	minute       = 2DIGIT
	second       = 2DIGIT
	*/
	function toIMFDate(date$1) {
		if (typeof date$1 === "number") date$1 = new Date(date$1);
		return `${[
			"Sun",
			"Mon",
			"Tue",
			"Wed",
			"Thu",
			"Fri",
			"Sat"
		][date$1.getUTCDay()]}, ${date$1.getUTCDate().toString().padStart(2, "0")} ${[
			"Jan",
			"Feb",
			"Mar",
			"Apr",
			"May",
			"Jun",
			"Jul",
			"Aug",
			"Sep",
			"Oct",
			"Nov",
			"Dec"
		][date$1.getUTCMonth()]} ${date$1.getUTCFullYear()} ${date$1.getUTCHours().toString().padStart(2, "0")}:${date$1.getUTCMinutes().toString().padStart(2, "0")}:${date$1.getUTCSeconds().toString().padStart(2, "0")} GMT`;
	}
	/**
	max-age-av        = "Max-Age=" non-zero-digit *DIGIT
	; In practice, both expires-av and max-age-av
	; are limited to dates representable by the
	; user agent.
	* @param {number} maxAge
	*/
	function validateCookieMaxAge(maxAge) {
		if (maxAge < 0) throw new Error("Invalid cookie max-age");
	}
	/**
	* @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1
	* @param {import('./index').Cookie} cookie
	*/
	function stringify$1(cookie) {
		if (cookie.name.length === 0) return null;
		validateCookieName(cookie.name);
		validateCookieValue(cookie.value);
		const out = [`${cookie.name}=${cookie.value}`];
		if (cookie.name.startsWith("__Secure-")) cookie.secure = true;
		if (cookie.name.startsWith("__Host-")) {
			cookie.secure = true;
			cookie.domain = null;
			cookie.path = "/";
		}
		if (cookie.secure) out.push("Secure");
		if (cookie.httpOnly) out.push("HttpOnly");
		if (typeof cookie.maxAge === "number") {
			validateCookieMaxAge(cookie.maxAge);
			out.push(`Max-Age=${cookie.maxAge}`);
		}
		if (cookie.domain) {
			validateCookieDomain(cookie.domain);
			out.push(`Domain=${cookie.domain}`);
		}
		if (cookie.path) {
			validateCookiePath(cookie.path);
			out.push(`Path=${cookie.path}`);
		}
		if (cookie.expires && cookie.expires.toString() !== "Invalid Date") out.push(`Expires=${toIMFDate(cookie.expires)}`);
		if (cookie.sameSite) out.push(`SameSite=${cookie.sameSite}`);
		for (const part of cookie.unparsed) {
			if (!part.includes("=")) throw new Error("Invalid unparsed");
			const [key, ...value] = part.split("=");
			out.push(`${key.trim()}=${value.join("=")}`);
		}
		return out.join("; ");
	}
	module.exports = {
		isCTLExcludingHtab: isCTLExcludingHtab$1,
		validateCookieName,
		validateCookiePath,
		validateCookieValue,
		toIMFDate,
		stringify: stringify$1
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/parse.js
var require_parse = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { maxNameValuePairSize, maxAttributeValueSize } = require_constants$1();
	const { isCTLExcludingHtab } = require_util$1();
	const { collectASequenceOfCodePointsFast } = require_dataURL();
	const assert = __require("assert");
	/**
	* @description Parses the field-value attributes of a set-cookie header string.
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} header
	* @returns if the header is invalid, null will be returned
	*/
	function parseSetCookie$1(header) {
		if (isCTLExcludingHtab(header)) return null;
		let nameValuePair = "";
		let unparsedAttributes = "";
		let name = "";
		let value = "";
		if (header.includes(";")) {
			const position = { position: 0 };
			nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
			unparsedAttributes = header.slice(position.position);
		} else nameValuePair = header;
		if (!nameValuePair.includes("=")) value = nameValuePair;
		else {
			const position = { position: 0 };
			name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
			value = nameValuePair.slice(position.position + 1);
		}
		name = name.trim();
		value = value.trim();
		if (name.length + value.length > maxNameValuePairSize) return null;
		return {
			name,
			value,
			...parseUnparsedAttributes(unparsedAttributes)
		};
	}
	/**
	* Parses the remaining attributes of a set-cookie header
	* @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4
	* @param {string} unparsedAttributes
	* @param {[Object.<string, unknown>]={}} cookieAttributeList
	*/
	function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
		if (unparsedAttributes.length === 0) return cookieAttributeList;
		assert(unparsedAttributes[0] === ";");
		unparsedAttributes = unparsedAttributes.slice(1);
		let cookieAv = "";
		if (unparsedAttributes.includes(";")) {
			cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
			unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
		} else {
			cookieAv = unparsedAttributes;
			unparsedAttributes = "";
		}
		let attributeName = "";
		let attributeValue = "";
		if (cookieAv.includes("=")) {
			const position = { position: 0 };
			attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
			attributeValue = cookieAv.slice(position.position + 1);
		} else attributeName = cookieAv;
		attributeName = attributeName.trim();
		attributeValue = attributeValue.trim();
		if (attributeValue.length > maxAttributeValueSize) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
		const attributeNameLowercase = attributeName.toLowerCase();
		if (attributeNameLowercase === "expires") cookieAttributeList.expires = new Date(attributeValue);
		else if (attributeNameLowercase === "max-age") {
			const charCode = attributeValue.charCodeAt(0);
			if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			if (!/^\d+$/.test(attributeValue)) return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
			cookieAttributeList.maxAge = Number(attributeValue);
		} else if (attributeNameLowercase === "domain") {
			let cookieDomain = attributeValue;
			if (cookieDomain[0] === ".") cookieDomain = cookieDomain.slice(1);
			cookieDomain = cookieDomain.toLowerCase();
			cookieAttributeList.domain = cookieDomain;
		} else if (attributeNameLowercase === "path") {
			let cookiePath = "";
			if (attributeValue.length === 0 || attributeValue[0] !== "/") cookiePath = "/";
			else cookiePath = attributeValue;
			cookieAttributeList.path = cookiePath;
		} else if (attributeNameLowercase === "secure") cookieAttributeList.secure = true;
		else if (attributeNameLowercase === "httponly") cookieAttributeList.httpOnly = true;
		else if (attributeNameLowercase === "samesite") {
			let enforcement = "Default";
			const attributeValueLowercase = attributeValue.toLowerCase();
			if (attributeValueLowercase.includes("none")) enforcement = "None";
			if (attributeValueLowercase.includes("strict")) enforcement = "Strict";
			if (attributeValueLowercase.includes("lax")) enforcement = "Lax";
			cookieAttributeList.sameSite = enforcement;
		} else {
			cookieAttributeList.unparsed ??= [];
			cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
		}
		return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
	}
	module.exports = {
		parseSetCookie: parseSetCookie$1,
		parseUnparsedAttributes
	};
}));

//#endregion
//#region node_modules/undici/lib/cookies/index.js
var require_cookies = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { parseSetCookie } = require_parse();
	const { stringify } = require_util$1();
	const { webidl: webidl$2 } = require_webidl();
	const { Headers: Headers$3 } = require_headers();
	/**
	* @typedef {Object} Cookie
	* @property {string} name
	* @property {string} value
	* @property {Date|number|undefined} expires
	* @property {number|undefined} maxAge
	* @property {string|undefined} domain
	* @property {string|undefined} path
	* @property {boolean|undefined} secure
	* @property {boolean|undefined} httpOnly
	* @property {'Strict'|'Lax'|'None'} sameSite
	* @property {string[]} unparsed
	*/
	/**
	* @param {Headers} headers
	* @returns {Record<string, string>}
	*/
	function getCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getCookies" });
		webidl$2.brandCheck(headers, Headers$3, { strict: false });
		const cookie = headers.get("cookie");
		const out = {};
		if (!cookie) return out;
		for (const piece of cookie.split(";")) {
			const [name, ...value] = piece.split("=");
			out[name.trim()] = value.join("=");
		}
		return out;
	}
	/**
	* @param {Headers} headers
	* @param {string} name
	* @param {{ path?: string, domain?: string }|undefined} attributes
	* @returns {void}
	*/
	function deleteCookie(headers, name, attributes) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
		webidl$2.brandCheck(headers, Headers$3, { strict: false });
		name = webidl$2.converters.DOMString(name);
		attributes = webidl$2.converters.DeleteCookieAttributes(attributes);
		setCookie(headers, {
			name,
			value: "",
			expires: /* @__PURE__ */ new Date(0),
			...attributes
		});
	}
	/**
	* @param {Headers} headers
	* @returns {Cookie[]}
	*/
	function getSetCookies(headers) {
		webidl$2.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
		webidl$2.brandCheck(headers, Headers$3, { strict: false });
		const cookies = headers.getSetCookie();
		if (!cookies) return [];
		return cookies.map((pair) => parseSetCookie(pair));
	}
	/**
	* @param {Headers} headers
	* @param {Cookie} cookie
	* @returns {void}
	*/
	function setCookie(headers, cookie) {
		webidl$2.argumentLengthCheck(arguments, 2, { header: "setCookie" });
		webidl$2.brandCheck(headers, Headers$3, { strict: false });
		cookie = webidl$2.converters.Cookie(cookie);
		if (stringify(cookie)) headers.append("Set-Cookie", stringify(cookie));
	}
	webidl$2.converters.DeleteCookieAttributes = webidl$2.dictionaryConverter([{
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "path",
		defaultValue: null
	}, {
		converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
		key: "domain",
		defaultValue: null
	}]);
	webidl$2.converters.Cookie = webidl$2.dictionaryConverter([
		{
			converter: webidl$2.converters.DOMString,
			key: "name"
		},
		{
			converter: webidl$2.converters.DOMString,
			key: "value"
		},
		{
			converter: webidl$2.nullableConverter((value) => {
				if (typeof value === "number") return webidl$2.converters["unsigned long long"](value);
				return new Date(value);
			}),
			key: "expires",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters["long long"]),
			key: "maxAge",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "domain",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.DOMString),
			key: "path",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "secure",
			defaultValue: null
		},
		{
			converter: webidl$2.nullableConverter(webidl$2.converters.boolean),
			key: "httpOnly",
			defaultValue: null
		},
		{
			converter: webidl$2.converters.USVString,
			key: "sameSite",
			allowedValues: [
				"Strict",
				"Lax",
				"None"
			]
		},
		{
			converter: webidl$2.sequenceConverter(webidl$2.converters.DOMString),
			key: "unparsed",
			defaultValue: []
		}
	]);
	module.exports = {
		getCookies,
		deleteCookie,
		getSetCookies,
		setCookie
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/constants.js
var require_constants = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const uid$1 = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
	/** @type {PropertyDescriptor} */
	const staticPropertyDescriptors$1 = {
		enumerable: true,
		writable: false,
		configurable: false
	};
	const states$4 = {
		CONNECTING: 0,
		OPEN: 1,
		CLOSING: 2,
		CLOSED: 3
	};
	const opcodes$3 = {
		CONTINUATION: 0,
		TEXT: 1,
		BINARY: 2,
		CLOSE: 8,
		PING: 9,
		PONG: 10
	};
	const maxUnsigned16Bit$1 = 2 ** 16 - 1;
	const parserStates$1 = {
		INFO: 0,
		PAYLOADLENGTH_16: 2,
		PAYLOADLENGTH_64: 3,
		READ_DATA: 4
	};
	const emptyBuffer$2 = Buffer.allocUnsafe(0);
	module.exports = {
		uid: uid$1,
		staticPropertyDescriptors: staticPropertyDescriptors$1,
		states: states$4,
		opcodes: opcodes$3,
		maxUnsigned16Bit: maxUnsigned16Bit$1,
		parserStates: parserStates$1,
		emptyBuffer: emptyBuffer$2
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/symbols.js
var require_symbols = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		kWebSocketURL: Symbol("url"),
		kReadyState: Symbol("ready state"),
		kController: Symbol("controller"),
		kResponse: Symbol("response"),
		kBinaryType: Symbol("binary type"),
		kSentClose: Symbol("sent close"),
		kReceivedClose: Symbol("received close"),
		kByteParser: Symbol("byte parser")
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/events.js
var require_events = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl: webidl$1 } = require_webidl();
	const { kEnumerableProperty: kEnumerableProperty$1 } = require_util$6();
	const { MessagePort } = __require("worker_threads");
	/**
	* @see https://html.spec.whatwg.org/multipage/comms.html#messageevent
	*/
	var MessageEvent$1 = class MessageEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.MessageEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get data() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.data;
		}
		get origin() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.origin;
		}
		get lastEventId() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.lastEventId;
		}
		get source() {
			webidl$1.brandCheck(this, MessageEvent$1);
			return this.#eventInit.source;
		}
		get ports() {
			webidl$1.brandCheck(this, MessageEvent$1);
			if (!Object.isFrozen(this.#eventInit.ports)) Object.freeze(this.#eventInit.ports);
			return this.#eventInit.ports;
		}
		initMessageEvent(type, bubbles = false, cancelable = false, data$1 = null, origin = "", lastEventId = "", source = null, ports = []) {
			webidl$1.brandCheck(this, MessageEvent$1);
			webidl$1.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
			return new MessageEvent$1(type, {
				bubbles,
				cancelable,
				data: data$1,
				origin,
				lastEventId,
				source,
				ports
			});
		}
	};
	/**
	* @see https://websockets.spec.whatwg.org/#the-closeevent-interface
	*/
	var CloseEvent$1 = class CloseEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict = {}) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.CloseEventInit(eventInitDict);
			super(type, eventInitDict);
			this.#eventInit = eventInitDict;
		}
		get wasClean() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.wasClean;
		}
		get code() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.code;
		}
		get reason() {
			webidl$1.brandCheck(this, CloseEvent$1);
			return this.#eventInit.reason;
		}
	};
	var ErrorEvent$1 = class ErrorEvent$1 extends Event {
		#eventInit;
		constructor(type, eventInitDict) {
			webidl$1.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
			super(type, eventInitDict);
			type = webidl$1.converters.DOMString(type);
			eventInitDict = webidl$1.converters.ErrorEventInit(eventInitDict ?? {});
			this.#eventInit = eventInitDict;
		}
		get message() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.message;
		}
		get filename() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.filename;
		}
		get lineno() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.lineno;
		}
		get colno() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.colno;
		}
		get error() {
			webidl$1.brandCheck(this, ErrorEvent$1);
			return this.#eventInit.error;
		}
	};
	Object.defineProperties(MessageEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "MessageEvent",
			configurable: true
		},
		data: kEnumerableProperty$1,
		origin: kEnumerableProperty$1,
		lastEventId: kEnumerableProperty$1,
		source: kEnumerableProperty$1,
		ports: kEnumerableProperty$1,
		initMessageEvent: kEnumerableProperty$1
	});
	Object.defineProperties(CloseEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "CloseEvent",
			configurable: true
		},
		reason: kEnumerableProperty$1,
		code: kEnumerableProperty$1,
		wasClean: kEnumerableProperty$1
	});
	Object.defineProperties(ErrorEvent$1.prototype, {
		[Symbol.toStringTag]: {
			value: "ErrorEvent",
			configurable: true
		},
		message: kEnumerableProperty$1,
		filename: kEnumerableProperty$1,
		lineno: kEnumerableProperty$1,
		colno: kEnumerableProperty$1,
		error: kEnumerableProperty$1
	});
	webidl$1.converters.MessagePort = webidl$1.interfaceConverter(MessagePort);
	webidl$1.converters["sequence<MessagePort>"] = webidl$1.sequenceConverter(webidl$1.converters.MessagePort);
	const eventInit = [
		{
			key: "bubbles",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "cancelable",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "composed",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		}
	];
	webidl$1.converters.MessageEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "data",
			converter: webidl$1.converters.any,
			defaultValue: null
		},
		{
			key: "origin",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lastEventId",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "source",
			converter: webidl$1.nullableConverter(webidl$1.converters.MessagePort),
			defaultValue: null
		},
		{
			key: "ports",
			converter: webidl$1.converters["sequence<MessagePort>"],
			get defaultValue() {
				return [];
			}
		}
	]);
	webidl$1.converters.CloseEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "wasClean",
			converter: webidl$1.converters.boolean,
			defaultValue: false
		},
		{
			key: "code",
			converter: webidl$1.converters["unsigned short"],
			defaultValue: 0
		},
		{
			key: "reason",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		}
	]);
	webidl$1.converters.ErrorEventInit = webidl$1.dictionaryConverter([
		...eventInit,
		{
			key: "message",
			converter: webidl$1.converters.DOMString,
			defaultValue: ""
		},
		{
			key: "filename",
			converter: webidl$1.converters.USVString,
			defaultValue: ""
		},
		{
			key: "lineno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "colno",
			converter: webidl$1.converters["unsigned long"],
			defaultValue: 0
		},
		{
			key: "error",
			converter: webidl$1.converters.any
		}
	]);
	module.exports = {
		MessageEvent: MessageEvent$1,
		CloseEvent: CloseEvent$1,
		ErrorEvent: ErrorEvent$1
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/util.js
var require_util = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { kReadyState: kReadyState$3, kController: kController$1, kResponse: kResponse$2, kBinaryType: kBinaryType$1, kWebSocketURL: kWebSocketURL$1 } = require_symbols();
	const { states: states$3, opcodes: opcodes$2 } = require_constants();
	const { MessageEvent, ErrorEvent } = require_events();
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isEstablished$1(ws) {
		return ws[kReadyState$3] === states$3.OPEN;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosing$1(ws) {
		return ws[kReadyState$3] === states$3.CLOSING;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	*/
	function isClosed(ws) {
		return ws[kReadyState$3] === states$3.CLOSED;
	}
	/**
	* @see https://dom.spec.whatwg.org/#concept-event-fire
	* @param {string} e
	* @param {EventTarget} target
	* @param {EventInit | undefined} eventInitDict
	*/
	function fireEvent$2(e$5, target, eventConstructor = Event, eventInitDict) {
		const event = new eventConstructor(e$5, eventInitDict);
		target.dispatchEvent(event);
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @param {import('./websocket').WebSocket} ws
	* @param {number} type Opcode
	* @param {Buffer} data application data
	*/
	function websocketMessageReceived$1(ws, type, data$1) {
		if (ws[kReadyState$3] !== states$3.OPEN) return;
		let dataForEvent;
		if (type === opcodes$2.TEXT) try {
			dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data$1);
		} catch {
			failWebsocketConnection$3(ws, "Received invalid UTF-8 in text frame.");
			return;
		}
		else if (type === opcodes$2.BINARY) if (ws[kBinaryType$1] === "blob") dataForEvent = new Blob([data$1]);
		else dataForEvent = new Uint8Array(data$1).buffer;
		fireEvent$2("message", ws, MessageEvent, {
			origin: ws[kWebSocketURL$1].origin,
			data: dataForEvent
		});
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455
	* @see https://datatracker.ietf.org/doc/html/rfc2616
	* @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407
	* @param {string} protocol
	*/
	function isValidSubprotocol$1(protocol) {
		if (protocol.length === 0) return false;
		for (const char of protocol) {
			const code = char.charCodeAt(0);
			if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === "\"" || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) return false;
		}
		return true;
	}
	/**
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4
	* @param {number} code
	*/
	function isValidStatusCode$1(code) {
		if (code >= 1e3 && code < 1015) return code !== 1004 && code !== 1005 && code !== 1006;
		return code >= 3e3 && code <= 4999;
	}
	/**
	* @param {import('./websocket').WebSocket} ws
	* @param {string|undefined} reason
	*/
	function failWebsocketConnection$3(ws, reason) {
		const { [kController$1]: controller, [kResponse$2]: response } = ws;
		controller.abort();
		if (response?.socket && !response.socket.destroyed) response.socket.destroy();
		if (reason) fireEvent$2("error", ws, ErrorEvent, { error: new Error(reason) });
	}
	module.exports = {
		isEstablished: isEstablished$1,
		isClosing: isClosing$1,
		isClosed,
		fireEvent: fireEvent$2,
		isValidSubprotocol: isValidSubprotocol$1,
		isValidStatusCode: isValidStatusCode$1,
		failWebsocketConnection: failWebsocketConnection$3,
		websocketMessageReceived: websocketMessageReceived$1
	};
}));

//#endregion
//#region node_modules/undici/lib/websocket/connection.js
var require_connection = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const diagnosticsChannel$1 = __require("diagnostics_channel");
	const { uid, states: states$2 } = require_constants();
	const { kReadyState: kReadyState$2, kSentClose: kSentClose$2, kByteParser: kByteParser$1, kReceivedClose: kReceivedClose$1 } = require_symbols();
	const { fireEvent: fireEvent$1, failWebsocketConnection: failWebsocketConnection$2 } = require_util();
	const { CloseEvent } = require_events();
	const { makeRequest } = require_request();
	const { fetching } = require_fetch();
	const { Headers: Headers$2 } = require_headers();
	const { getGlobalDispatcher: getGlobalDispatcher$2 } = require_global();
	const { kHeadersList } = require_symbols$4();
	const channels$1 = {};
	channels$1.open = diagnosticsChannel$1.channel("undici:websocket:open");
	channels$1.close = diagnosticsChannel$1.channel("undici:websocket:close");
	channels$1.socketError = diagnosticsChannel$1.channel("undici:websocket:socket_error");
	/** @type {import('crypto')} */
	let crypto$3;
	try {
		crypto$3 = __require("crypto");
	} catch {}
	/**
	* @see https://websockets.spec.whatwg.org/#concept-websocket-establish
	* @param {URL} url
	* @param {string|string[]} protocols
	* @param {import('./websocket').WebSocket} ws
	* @param {(response: any) => void} onEstablish
	* @param {Partial<import('../../types/websocket').WebSocketInit>} options
	*/
	function establishWebSocketConnection$1(url$1, protocols$1, ws, onEstablish, options) {
		const requestURL = url$1;
		requestURL.protocol = url$1.protocol === "ws:" ? "http:" : "https:";
		const request$1 = makeRequest({
			urlList: [requestURL],
			serviceWorkers: "none",
			referrer: "no-referrer",
			mode: "websocket",
			credentials: "include",
			cache: "no-store",
			redirect: "error"
		});
		if (options.headers) request$1.headersList = new Headers$2(options.headers)[kHeadersList];
		const keyValue = crypto$3.randomBytes(16).toString("base64");
		request$1.headersList.append("sec-websocket-key", keyValue);
		request$1.headersList.append("sec-websocket-version", "13");
		for (const protocol of protocols$1) request$1.headersList.append("sec-websocket-protocol", protocol);
		const permessageDeflate = "";
		return fetching({
			request: request$1,
			useParallelQueue: true,
			dispatcher: options.dispatcher ?? getGlobalDispatcher$2(),
			processResponse(response) {
				if (response.type === "error" || response.status !== 101) {
					failWebsocketConnection$2(ws, "Received network error or non-101 status code.");
					return;
				}
				if (protocols$1.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Server did not respond with sent protocols.");
					return;
				}
				if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
					failWebsocketConnection$2(ws, "Server did not set Upgrade header to \"websocket\".");
					return;
				}
				if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
					failWebsocketConnection$2(ws, "Server did not set Connection header to \"upgrade\".");
					return;
				}
				if (response.headersList.get("Sec-WebSocket-Accept") !== crypto$3.createHash("sha1").update(keyValue + uid).digest("base64")) {
					failWebsocketConnection$2(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
					return;
				}
				const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
				if (secExtension !== null && secExtension !== permessageDeflate) {
					failWebsocketConnection$2(ws, "Received different permessage-deflate than the one set.");
					return;
				}
				const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
				if (secProtocol !== null && secProtocol !== request$1.headersList.get("Sec-WebSocket-Protocol")) {
					failWebsocketConnection$2(ws, "Protocol was not set in the opening handshake.");
					return;
				}
				response.socket.on("data", onSocketData);
				response.socket.on("close", onSocketClose);
				response.socket.on("error", onSocketError);
				if (channels$1.open.hasSubscribers) channels$1.open.publish({
					address: response.socket.address(),
					protocol: secProtocol,
					extensions: secExtension
				});
				onEstablish(response);
			}
		});
	}
	/**
	* @param {Buffer} chunk
	*/
	function onSocketData(chunk) {
		if (!this.ws[kByteParser$1].write(chunk)) this.pause();
	}
	/**
	* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
	* @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4
	*/
	function onSocketClose() {
		const { ws } = this;
		const wasClean = ws[kSentClose$2] && ws[kReceivedClose$1];
		let code = 1005;
		let reason = "";
		const result = ws[kByteParser$1].closingInfo;
		if (result) {
			code = result.code ?? 1005;
			reason = result.reason;
		} else if (!ws[kSentClose$2]) code = 1006;
		ws[kReadyState$2] = states$2.CLOSED;
		fireEvent$1("close", ws, CloseEvent, {
			wasClean,
			code,
			reason
		});
		if (channels$1.close.hasSubscribers) channels$1.close.publish({
			websocket: ws,
			code,
			reason
		});
	}
	function onSocketError(error$2) {
		const { ws } = this;
		ws[kReadyState$2] = states$2.CLOSING;
		if (channels$1.socketError.hasSubscribers) channels$1.socketError.publish(error$2);
		this.destroy();
	}
	module.exports = { establishWebSocketConnection: establishWebSocketConnection$1 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/frame.js
var require_frame = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { maxUnsigned16Bit } = require_constants();
	/** @type {import('crypto')} */
	let crypto$2;
	try {
		crypto$2 = __require("crypto");
	} catch {}
	var WebsocketFrameSend$2 = class {
		/**
		* @param {Buffer|undefined} data
		*/
		constructor(data$1) {
			this.frameData = data$1;
			this.maskKey = crypto$2.randomBytes(4);
		}
		createFrame(opcode) {
			const bodyLength$1 = this.frameData?.byteLength ?? 0;
			/** @type {number} */
			let payloadLength = bodyLength$1;
			let offset = 6;
			if (bodyLength$1 > maxUnsigned16Bit) {
				offset += 8;
				payloadLength = 127;
			} else if (bodyLength$1 > 125) {
				offset += 2;
				payloadLength = 126;
			}
			const buffer$3 = Buffer.allocUnsafe(bodyLength$1 + offset);
			buffer$3[0] = buffer$3[1] = 0;
			buffer$3[0] |= 128;
			buffer$3[0] = (buffer$3[0] & 240) + opcode;
			/*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
			buffer$3[offset - 4] = this.maskKey[0];
			buffer$3[offset - 3] = this.maskKey[1];
			buffer$3[offset - 2] = this.maskKey[2];
			buffer$3[offset - 1] = this.maskKey[3];
			buffer$3[1] = payloadLength;
			if (payloadLength === 126) buffer$3.writeUInt16BE(bodyLength$1, 2);
			else if (payloadLength === 127) {
				buffer$3[2] = buffer$3[3] = 0;
				buffer$3.writeUIntBE(bodyLength$1, 4, 6);
			}
			buffer$3[1] |= 128;
			for (let i$5 = 0; i$5 < bodyLength$1; i$5++) buffer$3[offset + i$5] = this.frameData[i$5] ^ this.maskKey[i$5 % 4];
			return buffer$3;
		}
	};
	module.exports = { WebsocketFrameSend: WebsocketFrameSend$2 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/receiver.js
var require_receiver = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { Writable } = __require("stream");
	const diagnosticsChannel = __require("diagnostics_channel");
	const { parserStates, opcodes: opcodes$1, states: states$1, emptyBuffer: emptyBuffer$1 } = require_constants();
	const { kReadyState: kReadyState$1, kSentClose: kSentClose$1, kResponse: kResponse$1, kReceivedClose } = require_symbols();
	const { isValidStatusCode, failWebsocketConnection: failWebsocketConnection$1, websocketMessageReceived } = require_util();
	const { WebsocketFrameSend: WebsocketFrameSend$1 } = require_frame();
	const channels = {};
	channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
	channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
	var ByteParser$1 = class extends Writable {
		#buffers = [];
		#byteOffset = 0;
		#state = parserStates.INFO;
		#info = {};
		#fragments = [];
		constructor(ws) {
			super();
			this.ws = ws;
		}
		/**
		* @param {Buffer} chunk
		* @param {() => void} callback
		*/
		_write(chunk, _, callback) {
			this.#buffers.push(chunk);
			this.#byteOffset += chunk.length;
			this.run(callback);
		}
		/**
		* Runs whenever a new chunk is received.
		* Callback is called whenever there are no more chunks buffering,
		* or not enough bytes are buffered to parse.
		*/
		run(callback) {
			while (true) {
				if (this.#state === parserStates.INFO) {
					if (this.#byteOffset < 2) return callback();
					const buffer$3 = this.consume(2);
					this.#info.fin = (buffer$3[0] & 128) !== 0;
					this.#info.opcode = buffer$3[0] & 15;
					this.#info.originalOpcode ??= this.#info.opcode;
					this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes$1.CONTINUATION;
					if (this.#info.fragmented && this.#info.opcode !== opcodes$1.BINARY && this.#info.opcode !== opcodes$1.TEXT) {
						failWebsocketConnection$1(this.ws, "Invalid frame type was fragmented.");
						return;
					}
					const payloadLength = buffer$3[1] & 127;
					if (payloadLength <= 125) {
						this.#info.payloadLength = payloadLength;
						this.#state = parserStates.READ_DATA;
					} else if (payloadLength === 126) this.#state = parserStates.PAYLOADLENGTH_16;
					else if (payloadLength === 127) this.#state = parserStates.PAYLOADLENGTH_64;
					if (this.#info.fragmented && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Fragmented frame exceeded 125 bytes.");
						return;
					} else if ((this.#info.opcode === opcodes$1.PING || this.#info.opcode === opcodes$1.PONG || this.#info.opcode === opcodes$1.CLOSE) && payloadLength > 125) {
						failWebsocketConnection$1(this.ws, "Payload length for control frame exceeded 125 bytes.");
						return;
					} else if (this.#info.opcode === opcodes$1.CLOSE) {
						if (payloadLength === 1) {
							failWebsocketConnection$1(this.ws, "Received close frame with a 1-byte body.");
							return;
						}
						const body = this.consume(payloadLength);
						this.#info.closeInfo = this.parseCloseBody(false, body);
						if (!this.ws[kSentClose$1]) {
							const body$1 = Buffer.allocUnsafe(2);
							body$1.writeUInt16BE(this.#info.closeInfo.code, 0);
							const closeFrame = new WebsocketFrameSend$1(body$1);
							this.ws[kResponse$1].socket.write(closeFrame.createFrame(opcodes$1.CLOSE), (err) => {
								if (!err) this.ws[kSentClose$1] = true;
							});
						}
						this.ws[kReadyState$1] = states$1.CLOSING;
						this.ws[kReceivedClose] = true;
						this.end();
						return;
					} else if (this.#info.opcode === opcodes$1.PING) {
						const body = this.consume(payloadLength);
						if (!this.ws[kReceivedClose]) {
							const frame = new WebsocketFrameSend$1(body);
							this.ws[kResponse$1].socket.write(frame.createFrame(opcodes$1.PONG));
							if (channels.ping.hasSubscribers) channels.ping.publish({ payload: body });
						}
						this.#state = parserStates.INFO;
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					} else if (this.#info.opcode === opcodes$1.PONG) {
						const body = this.consume(payloadLength);
						if (channels.pong.hasSubscribers) channels.pong.publish({ payload: body });
						if (this.#byteOffset > 0) continue;
						else {
							callback();
							return;
						}
					}
				} else if (this.#state === parserStates.PAYLOADLENGTH_16) {
					if (this.#byteOffset < 2) return callback();
					const buffer$3 = this.consume(2);
					this.#info.payloadLength = buffer$3.readUInt16BE(0);
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.PAYLOADLENGTH_64) {
					if (this.#byteOffset < 8) return callback();
					const buffer$3 = this.consume(8);
					const upper = buffer$3.readUInt32BE(0);
					if (upper > 2 ** 31 - 1) {
						failWebsocketConnection$1(this.ws, "Received payload length > 2^31 bytes.");
						return;
					}
					const lower = buffer$3.readUInt32BE(4);
					this.#info.payloadLength = (upper << 8) + lower;
					this.#state = parserStates.READ_DATA;
				} else if (this.#state === parserStates.READ_DATA) {
					if (this.#byteOffset < this.#info.payloadLength) return callback();
					else if (this.#byteOffset >= this.#info.payloadLength) {
						const body = this.consume(this.#info.payloadLength);
						this.#fragments.push(body);
						if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes$1.CONTINUATION) {
							const fullMessage = Buffer.concat(this.#fragments);
							websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
							this.#info = {};
							this.#fragments.length = 0;
						}
						this.#state = parserStates.INFO;
					}
				}
				if (this.#byteOffset > 0) continue;
				else {
					callback();
					break;
				}
			}
		}
		/**
		* Take n bytes from the buffered Buffers
		* @param {number} n
		* @returns {Buffer|null}
		*/
		consume(n$5) {
			if (n$5 > this.#byteOffset) return null;
			else if (n$5 === 0) return emptyBuffer$1;
			if (this.#buffers[0].length === n$5) {
				this.#byteOffset -= this.#buffers[0].length;
				return this.#buffers.shift();
			}
			const buffer$3 = Buffer.allocUnsafe(n$5);
			let offset = 0;
			while (offset !== n$5) {
				const next = this.#buffers[0];
				const { length } = next;
				if (length + offset === n$5) {
					buffer$3.set(this.#buffers.shift(), offset);
					break;
				} else if (length + offset > n$5) {
					buffer$3.set(next.subarray(0, n$5 - offset), offset);
					this.#buffers[0] = next.subarray(n$5 - offset);
					break;
				} else {
					buffer$3.set(this.#buffers.shift(), offset);
					offset += next.length;
				}
			}
			this.#byteOffset -= n$5;
			return buffer$3;
		}
		parseCloseBody(onlyCode, data$1) {
			/** @type {number|undefined} */
			let code;
			if (data$1.length >= 2) code = data$1.readUInt16BE(0);
			if (onlyCode) {
				if (!isValidStatusCode(code)) return null;
				return { code };
			}
			/** @type {Buffer} */
			let reason = data$1.subarray(2);
			if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) reason = reason.subarray(3);
			if (code !== void 0 && !isValidStatusCode(code)) return null;
			try {
				reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
			} catch {
				return null;
			}
			return {
				code,
				reason
			};
		}
		get closingInfo() {
			return this.#info.closeInfo;
		}
	};
	module.exports = { ByteParser: ByteParser$1 };
}));

//#endregion
//#region node_modules/undici/lib/websocket/websocket.js
var require_websocket = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const { webidl } = require_webidl();
	const { DOMException: DOMException$1 } = require_constants$3();
	const { URLSerializer } = require_dataURL();
	const { getGlobalOrigin } = require_global$1();
	const { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants();
	const { kWebSocketURL, kReadyState, kController, kBinaryType, kResponse, kSentClose, kByteParser } = require_symbols();
	const { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util();
	const { establishWebSocketConnection } = require_connection();
	const { WebsocketFrameSend } = require_frame();
	const { ByteParser } = require_receiver();
	const { kEnumerableProperty, isBlobLike } = require_util$6();
	const { getGlobalDispatcher: getGlobalDispatcher$1 } = require_global();
	const { types: types$5 } = __require("util");
	let experimentalWarned = false;
	var WebSocket = class WebSocket extends EventTarget {
		#events = {
			open: null,
			error: null,
			close: null,
			message: null
		};
		#bufferedAmount = 0;
		#protocol = "";
		#extensions = "";
		/**
		* @param {string} url
		* @param {string|string[]} protocols
		*/
		constructor(url$1, protocols$1 = []) {
			super();
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
			if (!experimentalWarned) {
				experimentalWarned = true;
				process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
			}
			const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols$1);
			url$1 = webidl.converters.USVString(url$1);
			protocols$1 = options.protocols;
			const baseURL = getGlobalOrigin();
			let urlRecord;
			try {
				urlRecord = new URL(url$1, baseURL);
			} catch (e$5) {
				throw new DOMException$1(e$5, "SyntaxError");
			}
			if (urlRecord.protocol === "http:") urlRecord.protocol = "ws:";
			else if (urlRecord.protocol === "https:") urlRecord.protocol = "wss:";
			if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") throw new DOMException$1(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
			if (urlRecord.hash || urlRecord.href.endsWith("#")) throw new DOMException$1("Got fragment", "SyntaxError");
			if (typeof protocols$1 === "string") protocols$1 = [protocols$1];
			if (protocols$1.length !== new Set(protocols$1.map((p$5) => p$5.toLowerCase())).size) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			if (protocols$1.length > 0 && !protocols$1.every((p$5) => isValidSubprotocol(p$5))) throw new DOMException$1("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
			this[kWebSocketURL] = new URL(urlRecord.href);
			this[kController] = establishWebSocketConnection(urlRecord, protocols$1, this, (response) => this.#onConnectionEstablished(response), options);
			this[kReadyState] = WebSocket.CONNECTING;
			this[kBinaryType] = "blob";
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-close
		* @param {number|undefined} code
		* @param {string|undefined} reason
		*/
		close(code = void 0, reason = void 0) {
			webidl.brandCheck(this, WebSocket);
			if (code !== void 0) code = webidl.converters["unsigned short"](code, { clamp: true });
			if (reason !== void 0) reason = webidl.converters.USVString(reason);
			if (code !== void 0) {
				if (code !== 1e3 && (code < 3e3 || code > 4999)) throw new DOMException$1("invalid code", "InvalidAccessError");
			}
			let reasonByteLength = 0;
			if (reason !== void 0) {
				reasonByteLength = Buffer.byteLength(reason);
				if (reasonByteLength > 123) throw new DOMException$1(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
			}
			if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {} else if (!isEstablished(this)) {
				failWebsocketConnection(this, "Connection was closed before it was established.");
				this[kReadyState] = WebSocket.CLOSING;
			} else if (!isClosing(this)) {
				const frame = new WebsocketFrameSend();
				if (code !== void 0 && reason === void 0) {
					frame.frameData = Buffer.allocUnsafe(2);
					frame.frameData.writeUInt16BE(code, 0);
				} else if (code !== void 0 && reason !== void 0) {
					frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
					frame.frameData.writeUInt16BE(code, 0);
					frame.frameData.write(reason, 2, "utf-8");
				} else frame.frameData = emptyBuffer;
				this[kResponse].socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
					if (!err) this[kSentClose] = true;
				});
				this[kReadyState] = states.CLOSING;
			} else this[kReadyState] = WebSocket.CLOSING;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#dom-websocket-send
		* @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
		*/
		send(data$1) {
			webidl.brandCheck(this, WebSocket);
			webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
			data$1 = webidl.converters.WebSocketSendData(data$1);
			if (this[kReadyState] === WebSocket.CONNECTING) throw new DOMException$1("Sent before connected.", "InvalidStateError");
			if (!isEstablished(this) || isClosing(this)) return;
			/** @type {import('stream').Duplex} */
			const socket = this[kResponse].socket;
			if (typeof data$1 === "string") {
				const value = Buffer.from(data$1);
				const buffer$3 = new WebsocketFrameSend(value).createFrame(opcodes.TEXT);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$3, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (types$5.isArrayBuffer(data$1)) {
				const value = Buffer.from(data$1);
				const buffer$3 = new WebsocketFrameSend(value).createFrame(opcodes.BINARY);
				this.#bufferedAmount += value.byteLength;
				socket.write(buffer$3, () => {
					this.#bufferedAmount -= value.byteLength;
				});
			} else if (ArrayBuffer.isView(data$1)) {
				const ab = Buffer.from(data$1, data$1.byteOffset, data$1.byteLength);
				const buffer$3 = new WebsocketFrameSend(ab).createFrame(opcodes.BINARY);
				this.#bufferedAmount += ab.byteLength;
				socket.write(buffer$3, () => {
					this.#bufferedAmount -= ab.byteLength;
				});
			} else if (isBlobLike(data$1)) {
				const frame = new WebsocketFrameSend();
				data$1.arrayBuffer().then((ab) => {
					const value = Buffer.from(ab);
					frame.frameData = value;
					const buffer$3 = frame.createFrame(opcodes.BINARY);
					this.#bufferedAmount += value.byteLength;
					socket.write(buffer$3, () => {
						this.#bufferedAmount -= value.byteLength;
					});
				});
			}
		}
		get readyState() {
			webidl.brandCheck(this, WebSocket);
			return this[kReadyState];
		}
		get bufferedAmount() {
			webidl.brandCheck(this, WebSocket);
			return this.#bufferedAmount;
		}
		get url() {
			webidl.brandCheck(this, WebSocket);
			return URLSerializer(this[kWebSocketURL]);
		}
		get extensions() {
			webidl.brandCheck(this, WebSocket);
			return this.#extensions;
		}
		get protocol() {
			webidl.brandCheck(this, WebSocket);
			return this.#protocol;
		}
		get onopen() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.open;
		}
		set onopen(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.open) this.removeEventListener("open", this.#events.open);
			if (typeof fn === "function") {
				this.#events.open = fn;
				this.addEventListener("open", fn);
			} else this.#events.open = null;
		}
		get onerror() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.error;
		}
		set onerror(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.error) this.removeEventListener("error", this.#events.error);
			if (typeof fn === "function") {
				this.#events.error = fn;
				this.addEventListener("error", fn);
			} else this.#events.error = null;
		}
		get onclose() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.close;
		}
		set onclose(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.close) this.removeEventListener("close", this.#events.close);
			if (typeof fn === "function") {
				this.#events.close = fn;
				this.addEventListener("close", fn);
			} else this.#events.close = null;
		}
		get onmessage() {
			webidl.brandCheck(this, WebSocket);
			return this.#events.message;
		}
		set onmessage(fn) {
			webidl.brandCheck(this, WebSocket);
			if (this.#events.message) this.removeEventListener("message", this.#events.message);
			if (typeof fn === "function") {
				this.#events.message = fn;
				this.addEventListener("message", fn);
			} else this.#events.message = null;
		}
		get binaryType() {
			webidl.brandCheck(this, WebSocket);
			return this[kBinaryType];
		}
		set binaryType(type) {
			webidl.brandCheck(this, WebSocket);
			if (type !== "blob" && type !== "arraybuffer") this[kBinaryType] = "blob";
			else this[kBinaryType] = type;
		}
		/**
		* @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
		*/
		#onConnectionEstablished(response) {
			this[kResponse] = response;
			const parser$1 = new ByteParser(this);
			parser$1.on("drain", function onParserDrain() {
				this.ws[kResponse].socket.resume();
			});
			response.socket.ws = this;
			this[kByteParser] = parser$1;
			this[kReadyState] = states.OPEN;
			const extensions = response.headersList.get("sec-websocket-extensions");
			if (extensions !== null) this.#extensions = extensions;
			const protocol = response.headersList.get("sec-websocket-protocol");
			if (protocol !== null) this.#protocol = protocol;
			fireEvent("open", this);
		}
	};
	WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
	WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
	WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
	WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
	Object.defineProperties(WebSocket.prototype, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors,
		url: kEnumerableProperty,
		readyState: kEnumerableProperty,
		bufferedAmount: kEnumerableProperty,
		onopen: kEnumerableProperty,
		onerror: kEnumerableProperty,
		onclose: kEnumerableProperty,
		close: kEnumerableProperty,
		onmessage: kEnumerableProperty,
		binaryType: kEnumerableProperty,
		send: kEnumerableProperty,
		extensions: kEnumerableProperty,
		protocol: kEnumerableProperty,
		[Symbol.toStringTag]: {
			value: "WebSocket",
			writable: false,
			enumerable: false,
			configurable: true
		}
	});
	Object.defineProperties(WebSocket, {
		CONNECTING: staticPropertyDescriptors,
		OPEN: staticPropertyDescriptors,
		CLOSING: staticPropertyDescriptors,
		CLOSED: staticPropertyDescriptors
	});
	webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
	webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
		if (webidl.util.Type(V) === "Object" && Symbol.iterator in V) return webidl.converters["sequence<DOMString>"](V);
		return webidl.converters.DOMString(V);
	};
	webidl.converters.WebSocketInit = webidl.dictionaryConverter([
		{
			key: "protocols",
			converter: webidl.converters["DOMString or sequence<DOMString>"],
			get defaultValue() {
				return [];
			}
		},
		{
			key: "dispatcher",
			converter: (V) => V,
			get defaultValue() {
				return getGlobalDispatcher$1();
			}
		},
		{
			key: "headers",
			converter: webidl.nullableConverter(webidl.converters.HeadersInit)
		}
	]);
	webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
		if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) return webidl.converters.WebSocketInit(V);
		return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
	};
	webidl.converters.WebSocketSendData = function(V) {
		if (webidl.util.Type(V) === "Object") {
			if (isBlobLike(V)) return webidl.converters.Blob(V, { strict: false });
			if (ArrayBuffer.isView(V) || types$5.isAnyArrayBuffer(V)) return webidl.converters.BufferSource(V);
		}
		return webidl.converters.USVString(V);
	};
	module.exports = { WebSocket };
}));

//#endregion
//#region node_modules/undici/index.js
var require_undici = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	const Client$1 = require_client();
	const Dispatcher = require_dispatcher();
	const errors = require_errors();
	const Pool = require_pool();
	const BalancedPool = require_balanced_pool();
	const Agent = require_agent();
	const util$1 = require_util$6();
	const { InvalidArgumentError } = errors;
	const api = require_api();
	const buildConnector = require_connect();
	const MockClient = require_mock_client();
	const MockAgent = require_mock_agent();
	const MockPool = require_mock_pool();
	const mockErrors = require_mock_errors();
	const ProxyAgent = require_proxy_agent();
	const RetryHandler = require_RetryHandler();
	const { getGlobalDispatcher, setGlobalDispatcher } = require_global();
	const DecoratorHandler = require_DecoratorHandler();
	const RedirectHandler = require_RedirectHandler();
	const createRedirectInterceptor = require_redirectInterceptor();
	let hasCrypto;
	try {
		__require("crypto");
		hasCrypto = true;
	} catch {
		hasCrypto = false;
	}
	Object.assign(Dispatcher.prototype, api);
	module.exports.Dispatcher = Dispatcher;
	module.exports.Client = Client$1;
	module.exports.Pool = Pool;
	module.exports.BalancedPool = BalancedPool;
	module.exports.Agent = Agent;
	module.exports.ProxyAgent = ProxyAgent;
	module.exports.RetryHandler = RetryHandler;
	module.exports.DecoratorHandler = DecoratorHandler;
	module.exports.RedirectHandler = RedirectHandler;
	module.exports.createRedirectInterceptor = createRedirectInterceptor;
	module.exports.buildConnector = buildConnector;
	module.exports.errors = errors;
	function makeDispatcher(fn) {
		return (url$1, opts, handler) => {
			if (typeof opts === "function") {
				handler = opts;
				opts = null;
			}
			if (!url$1 || typeof url$1 !== "string" && typeof url$1 !== "object" && !(url$1 instanceof URL)) throw new InvalidArgumentError("invalid url");
			if (opts != null && typeof opts !== "object") throw new InvalidArgumentError("invalid opts");
			if (opts && opts.path != null) {
				if (typeof opts.path !== "string") throw new InvalidArgumentError("invalid opts.path");
				let path$6 = opts.path;
				if (!opts.path.startsWith("/")) path$6 = `/${path$6}`;
				url$1 = new URL(util$1.parseOrigin(url$1).origin + path$6);
			} else {
				if (!opts) opts = typeof url$1 === "object" ? url$1 : {};
				url$1 = util$1.parseURL(url$1);
			}
			const { agent, dispatcher = getGlobalDispatcher() } = opts;
			if (agent) throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
			return fn.call(dispatcher, {
				...opts,
				origin: url$1.origin,
				path: url$1.search ? `${url$1.pathname}${url$1.search}` : url$1.pathname,
				method: opts.method || (opts.body ? "PUT" : "GET")
			}, handler);
		};
	}
	module.exports.setGlobalDispatcher = setGlobalDispatcher;
	module.exports.getGlobalDispatcher = getGlobalDispatcher;
	if (util$1.nodeMajor > 16 || util$1.nodeMajor === 16 && util$1.nodeMinor >= 8) {
		let fetchImpl = null;
		module.exports.fetch = async function fetch$2(resource) {
			if (!fetchImpl) fetchImpl = require_fetch().fetch;
			try {
				return await fetchImpl(...arguments);
			} catch (err) {
				if (typeof err === "object") Error.captureStackTrace(err, this);
				throw err;
			}
		};
		module.exports.Headers = require_headers().Headers;
		module.exports.Response = require_response().Response;
		module.exports.Request = require_request().Request;
		module.exports.FormData = require_formdata().FormData;
		module.exports.File = require_file().File;
		module.exports.FileReader = require_filereader().FileReader;
		const { setGlobalOrigin: setGlobalOrigin$1, getGlobalOrigin: getGlobalOrigin$5 } = require_global$1();
		module.exports.setGlobalOrigin = setGlobalOrigin$1;
		module.exports.getGlobalOrigin = getGlobalOrigin$5;
		const { CacheStorage: CacheStorage$1 } = require_cachestorage();
		const { kConstruct: kConstruct$5 } = require_symbols$1();
		module.exports.caches = new CacheStorage$1(kConstruct$5);
	}
	if (util$1.nodeMajor >= 16) {
		const { deleteCookie: deleteCookie$1, getCookies: getCookies$1, getSetCookies: getSetCookies$1, setCookie: setCookie$1 } = require_cookies();
		module.exports.deleteCookie = deleteCookie$1;
		module.exports.getCookies = getCookies$1;
		module.exports.getSetCookies = getSetCookies$1;
		module.exports.setCookie = setCookie$1;
		const { parseMIMEType: parseMIMEType$4, serializeAMimeType: serializeAMimeType$5 } = require_dataURL();
		module.exports.parseMIMEType = parseMIMEType$4;
		module.exports.serializeAMimeType = serializeAMimeType$5;
	}
	if (util$1.nodeMajor >= 18 && hasCrypto) {
		const { WebSocket: WebSocket$1 } = require_websocket();
		module.exports.WebSocket = WebSocket$1;
	}
	module.exports.request = makeDispatcher(api.request);
	module.exports.stream = makeDispatcher(api.stream);
	module.exports.pipeline = makeDispatcher(api.pipeline);
	module.exports.connect = makeDispatcher(api.connect);
	module.exports.upgrade = makeDispatcher(api.upgrade);
	module.exports.MockClient = MockClient;
	module.exports.MockPool = MockPool;
	module.exports.MockAgent = MockAgent;
	module.exports.mockErrors = mockErrors;
}));

//#endregion
//#region node_modules/@actions/http-client/lib/index.js
var require_lib = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$9 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$9 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$9 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$9(result, mod, k$5);
		}
		__setModuleDefault$9(result, mod);
		return result;
	};
	var __awaiter$10 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
	const http$2 = __importStar$9(__require("http"));
	const https$1 = __importStar$9(__require("https"));
	const pm = __importStar$9(require_proxy());
	const tunnel = __importStar$9(require_tunnel());
	const undici_1 = require_undici();
	var HttpCodes;
	(function(HttpCodes$1) {
		HttpCodes$1[HttpCodes$1["OK"] = 200] = "OK";
		HttpCodes$1[HttpCodes$1["MultipleChoices"] = 300] = "MultipleChoices";
		HttpCodes$1[HttpCodes$1["MovedPermanently"] = 301] = "MovedPermanently";
		HttpCodes$1[HttpCodes$1["ResourceMoved"] = 302] = "ResourceMoved";
		HttpCodes$1[HttpCodes$1["SeeOther"] = 303] = "SeeOther";
		HttpCodes$1[HttpCodes$1["NotModified"] = 304] = "NotModified";
		HttpCodes$1[HttpCodes$1["UseProxy"] = 305] = "UseProxy";
		HttpCodes$1[HttpCodes$1["SwitchProxy"] = 306] = "SwitchProxy";
		HttpCodes$1[HttpCodes$1["TemporaryRedirect"] = 307] = "TemporaryRedirect";
		HttpCodes$1[HttpCodes$1["PermanentRedirect"] = 308] = "PermanentRedirect";
		HttpCodes$1[HttpCodes$1["BadRequest"] = 400] = "BadRequest";
		HttpCodes$1[HttpCodes$1["Unauthorized"] = 401] = "Unauthorized";
		HttpCodes$1[HttpCodes$1["PaymentRequired"] = 402] = "PaymentRequired";
		HttpCodes$1[HttpCodes$1["Forbidden"] = 403] = "Forbidden";
		HttpCodes$1[HttpCodes$1["NotFound"] = 404] = "NotFound";
		HttpCodes$1[HttpCodes$1["MethodNotAllowed"] = 405] = "MethodNotAllowed";
		HttpCodes$1[HttpCodes$1["NotAcceptable"] = 406] = "NotAcceptable";
		HttpCodes$1[HttpCodes$1["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
		HttpCodes$1[HttpCodes$1["RequestTimeout"] = 408] = "RequestTimeout";
		HttpCodes$1[HttpCodes$1["Conflict"] = 409] = "Conflict";
		HttpCodes$1[HttpCodes$1["Gone"] = 410] = "Gone";
		HttpCodes$1[HttpCodes$1["TooManyRequests"] = 429] = "TooManyRequests";
		HttpCodes$1[HttpCodes$1["InternalServerError"] = 500] = "InternalServerError";
		HttpCodes$1[HttpCodes$1["NotImplemented"] = 501] = "NotImplemented";
		HttpCodes$1[HttpCodes$1["BadGateway"] = 502] = "BadGateway";
		HttpCodes$1[HttpCodes$1["ServiceUnavailable"] = 503] = "ServiceUnavailable";
		HttpCodes$1[HttpCodes$1["GatewayTimeout"] = 504] = "GatewayTimeout";
	})(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
	var Headers$1;
	(function(Headers$8) {
		Headers$8["Accept"] = "accept";
		Headers$8["ContentType"] = "content-type";
	})(Headers$1 || (exports.Headers = Headers$1 = {}));
	var MediaTypes;
	(function(MediaTypes$1) {
		MediaTypes$1["ApplicationJson"] = "application/json";
	})(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
	/**
	* Returns the proxy URL, depending upon the supplied url and proxy environment variables.
	* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
	*/
	function getProxyUrl(serverUrl) {
		const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
		return proxyUrl ? proxyUrl.href : "";
	}
	exports.getProxyUrl = getProxyUrl;
	const HttpRedirectCodes = [
		HttpCodes.MovedPermanently,
		HttpCodes.ResourceMoved,
		HttpCodes.SeeOther,
		HttpCodes.TemporaryRedirect,
		HttpCodes.PermanentRedirect
	];
	const HttpResponseRetryCodes = [
		HttpCodes.BadGateway,
		HttpCodes.ServiceUnavailable,
		HttpCodes.GatewayTimeout
	];
	const RetryableHttpVerbs = [
		"OPTIONS",
		"GET",
		"DELETE",
		"HEAD"
	];
	const ExponentialBackoffCeiling = 10;
	const ExponentialBackoffTimeSlice = 5;
	var HttpClientError = class HttpClientError extends Error {
		constructor(message, statusCode) {
			super(message);
			this.name = "HttpClientError";
			this.statusCode = statusCode;
			Object.setPrototypeOf(this, HttpClientError.prototype);
		}
	};
	exports.HttpClientError = HttpClientError;
	var HttpClientResponse = class {
		constructor(message) {
			this.message = message;
		}
		readBody() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					let output = Buffer.alloc(0);
					this.message.on("data", (chunk) => {
						output = Buffer.concat([output, chunk]);
					});
					this.message.on("end", () => {
						resolve(output.toString());
					});
				}));
			});
		}
		readBodyBuffer() {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve) => __awaiter$10(this, void 0, void 0, function* () {
					const chunks = [];
					this.message.on("data", (chunk) => {
						chunks.push(chunk);
					});
					this.message.on("end", () => {
						resolve(Buffer.concat(chunks));
					});
				}));
			});
		}
	};
	exports.HttpClientResponse = HttpClientResponse;
	function isHttps(requestUrl) {
		return new URL(requestUrl).protocol === "https:";
	}
	exports.isHttps = isHttps;
	var HttpClient = class {
		constructor(userAgent, handlers, requestOptions) {
			this._ignoreSslError = false;
			this._allowRedirects = true;
			this._allowRedirectDowngrade = false;
			this._maxRedirects = 50;
			this._allowRetries = false;
			this._maxRetries = 1;
			this._keepAlive = false;
			this._disposed = false;
			this.userAgent = userAgent;
			this.handlers = handlers || [];
			this.requestOptions = requestOptions;
			if (requestOptions) {
				if (requestOptions.ignoreSslError != null) this._ignoreSslError = requestOptions.ignoreSslError;
				this._socketTimeout = requestOptions.socketTimeout;
				if (requestOptions.allowRedirects != null) this._allowRedirects = requestOptions.allowRedirects;
				if (requestOptions.allowRedirectDowngrade != null) this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
				if (requestOptions.maxRedirects != null) this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
				if (requestOptions.keepAlive != null) this._keepAlive = requestOptions.keepAlive;
				if (requestOptions.allowRetries != null) this._allowRetries = requestOptions.allowRetries;
				if (requestOptions.maxRetries != null) this._maxRetries = requestOptions.maxRetries;
			}
		}
		options(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
			});
		}
		get(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("GET", requestUrl, null, additionalHeaders || {});
			});
		}
		del(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("DELETE", requestUrl, null, additionalHeaders || {});
			});
		}
		post(requestUrl, data$1, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("POST", requestUrl, data$1, additionalHeaders || {});
			});
		}
		patch(requestUrl, data$1, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PATCH", requestUrl, data$1, additionalHeaders || {});
			});
		}
		put(requestUrl, data$1, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("PUT", requestUrl, data$1, additionalHeaders || {});
			});
		}
		head(requestUrl, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request("HEAD", requestUrl, null, additionalHeaders || {});
			});
		}
		sendStream(verb, requestUrl, stream$3, additionalHeaders) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return this.request(verb, requestUrl, stream$3, additionalHeaders);
			});
		}
		/**
		* Gets a typed object from an endpoint
		* Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
		*/
		getJson(requestUrl, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				additionalHeaders[Headers$1.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.Accept, MediaTypes.ApplicationJson);
				const res = yield this.get(requestUrl, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		postJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data$1 = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$1.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$1.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.post(requestUrl, data$1, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		putJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data$1 = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$1.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$1.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.put(requestUrl, data$1, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		patchJson(requestUrl, obj, additionalHeaders = {}) {
			return __awaiter$10(this, void 0, void 0, function* () {
				const data$1 = JSON.stringify(obj, null, 2);
				additionalHeaders[Headers$1.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.Accept, MediaTypes.ApplicationJson);
				additionalHeaders[Headers$1.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers$1.ContentType, MediaTypes.ApplicationJson);
				const res = yield this.patch(requestUrl, data$1, additionalHeaders);
				return this._processResponse(res, this.requestOptions);
			});
		}
		/**
		* Makes a raw http request.
		* All other methods such as get, post, patch, and request ultimately call this.
		* Prefer get, del, post and patch
		*/
		request(verb, requestUrl, data$1, headers) {
			return __awaiter$10(this, void 0, void 0, function* () {
				if (this._disposed) throw new Error("Client has already been disposed.");
				const parsedUrl = new URL(requestUrl);
				let info$1 = this._prepareRequest(verb, parsedUrl, headers);
				const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
				let numTries = 0;
				let response;
				do {
					response = yield this.requestRaw(info$1, data$1);
					if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
						let authenticationHandler;
						for (const handler of this.handlers) if (handler.canHandleAuthentication(response)) {
							authenticationHandler = handler;
							break;
						}
						if (authenticationHandler) return authenticationHandler.handleAuthentication(this, info$1, data$1);
						else return response;
					}
					let redirectsRemaining = this._maxRedirects;
					while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
						const redirectUrl = response.message.headers["location"];
						if (!redirectUrl) break;
						const parsedRedirectUrl = new URL(redirectUrl);
						if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
						yield response.readBody();
						if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
							for (const header in headers) if (header.toLowerCase() === "authorization") delete headers[header];
						}
						info$1 = this._prepareRequest(verb, parsedRedirectUrl, headers);
						response = yield this.requestRaw(info$1, data$1);
						redirectsRemaining--;
					}
					if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) return response;
					numTries += 1;
					if (numTries < maxTries) {
						yield response.readBody();
						yield this._performExponentialBackoff(numTries);
					}
				} while (numTries < maxTries);
				return response;
			});
		}
		/**
		* Needs to be called if keepAlive is set to true in request options.
		*/
		dispose() {
			if (this._agent) this._agent.destroy();
			this._disposed = true;
		}
		/**
		* Raw request.
		* @param info
		* @param data
		*/
		requestRaw(info$1, data$1) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => {
					function callbackForResult(err, res) {
						if (err) reject(err);
						else if (!res) reject(/* @__PURE__ */ new Error("Unknown error"));
						else resolve(res);
					}
					this.requestRawWithCallback(info$1, data$1, callbackForResult);
				});
			});
		}
		/**
		* Raw request with callback.
		* @param info
		* @param data
		* @param onResult
		*/
		requestRawWithCallback(info$1, data$1, onResult) {
			if (typeof data$1 === "string") {
				if (!info$1.options.headers) info$1.options.headers = {};
				info$1.options.headers["Content-Length"] = Buffer.byteLength(data$1, "utf8");
			}
			let callbackCalled = false;
			function handleResult(err, res) {
				if (!callbackCalled) {
					callbackCalled = true;
					onResult(err, res);
				}
			}
			const req = info$1.httpModule.request(info$1.options, (msg) => {
				handleResult(void 0, new HttpClientResponse(msg));
			});
			let socket;
			req.on("socket", (sock) => {
				socket = sock;
			});
			req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
				if (socket) socket.end();
				handleResult(/* @__PURE__ */ new Error(`Request timeout: ${info$1.options.path}`));
			});
			req.on("error", function(err) {
				handleResult(err);
			});
			if (data$1 && typeof data$1 === "string") req.write(data$1, "utf8");
			if (data$1 && typeof data$1 !== "string") {
				data$1.on("close", function() {
					req.end();
				});
				data$1.pipe(req);
			} else req.end();
		}
		/**
		* Gets an http agent. This function is useful when you need an http agent that handles
		* routing through a proxy server - depending upon the url and proxy environment variables.
		* @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
		*/
		getAgent(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			return this._getAgent(parsedUrl);
		}
		getAgentDispatcher(serverUrl) {
			const parsedUrl = new URL(serverUrl);
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			if (!(proxyUrl && proxyUrl.hostname)) return;
			return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
		}
		_prepareRequest(method, requestUrl, headers) {
			const info$1 = {};
			info$1.parsedUrl = requestUrl;
			const usingSsl = info$1.parsedUrl.protocol === "https:";
			info$1.httpModule = usingSsl ? https$1 : http$2;
			const defaultPort = usingSsl ? 443 : 80;
			info$1.options = {};
			info$1.options.host = info$1.parsedUrl.hostname;
			info$1.options.port = info$1.parsedUrl.port ? parseInt(info$1.parsedUrl.port) : defaultPort;
			info$1.options.path = (info$1.parsedUrl.pathname || "") + (info$1.parsedUrl.search || "");
			info$1.options.method = method;
			info$1.options.headers = this._mergeHeaders(headers);
			if (this.userAgent != null) info$1.options.headers["user-agent"] = this.userAgent;
			info$1.options.agent = this._getAgent(info$1.parsedUrl);
			if (this.handlers) for (const handler of this.handlers) handler.prepareRequest(info$1.options);
			return info$1;
		}
		_mergeHeaders(headers) {
			if (this.requestOptions && this.requestOptions.headers) return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
			return lowercaseKeys(headers || {});
		}
		_getExistingOrDefaultHeader(additionalHeaders, header, _default) {
			let clientHeader;
			if (this.requestOptions && this.requestOptions.headers) clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
			return additionalHeaders[header] || clientHeader || _default;
		}
		_getAgent(parsedUrl) {
			let agent;
			const proxyUrl = pm.getProxyUrl(parsedUrl);
			const useProxy = proxyUrl && proxyUrl.hostname;
			if (this._keepAlive && useProxy) agent = this._proxyAgent;
			if (!useProxy) agent = this._agent;
			if (agent) return agent;
			const usingSsl = parsedUrl.protocol === "https:";
			let maxSockets = 100;
			if (this.requestOptions) maxSockets = this.requestOptions.maxSockets || http$2.globalAgent.maxSockets;
			if (proxyUrl && proxyUrl.hostname) {
				const agentOptions = {
					maxSockets,
					keepAlive: this._keepAlive,
					proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && { proxyAuth: `${proxyUrl.username}:${proxyUrl.password}` }), {
						host: proxyUrl.hostname,
						port: proxyUrl.port
					})
				};
				let tunnelAgent;
				const overHttps = proxyUrl.protocol === "https:";
				if (usingSsl) tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
				else tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
				agent = tunnelAgent(agentOptions);
				this._proxyAgent = agent;
			}
			if (!agent) {
				const options = {
					keepAlive: this._keepAlive,
					maxSockets
				};
				agent = usingSsl ? new https$1.Agent(options) : new http$2.Agent(options);
				this._agent = agent;
			}
			if (usingSsl && this._ignoreSslError) agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
			return agent;
		}
		_getProxyAgentDispatcher(parsedUrl, proxyUrl) {
			let proxyAgent;
			if (this._keepAlive) proxyAgent = this._proxyAgentDispatcher;
			if (proxyAgent) return proxyAgent;
			const usingSsl = parsedUrl.protocol === "https:";
			proxyAgent = new undici_1.ProxyAgent(Object.assign({
				uri: proxyUrl.href,
				pipelining: !this._keepAlive ? 0 : 1
			}, (proxyUrl.username || proxyUrl.password) && { token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}` }));
			this._proxyAgentDispatcher = proxyAgent;
			if (usingSsl && this._ignoreSslError) proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, { rejectUnauthorized: false });
			return proxyAgent;
		}
		_performExponentialBackoff(retryNumber) {
			return __awaiter$10(this, void 0, void 0, function* () {
				retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
				const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
				return new Promise((resolve) => setTimeout(() => resolve(), ms));
			});
		}
		_processResponse(res, options) {
			return __awaiter$10(this, void 0, void 0, function* () {
				return new Promise((resolve, reject) => __awaiter$10(this, void 0, void 0, function* () {
					const statusCode = res.message.statusCode || 0;
					const response = {
						statusCode,
						result: null,
						headers: {}
					};
					if (statusCode === HttpCodes.NotFound) resolve(response);
					function dateTimeDeserializer(key, value) {
						if (typeof value === "string") {
							const a$5 = new Date(value);
							if (!isNaN(a$5.valueOf())) return a$5;
						}
						return value;
					}
					let obj;
					let contents;
					try {
						contents = yield res.readBody();
						if (contents && contents.length > 0) {
							if (options && options.deserializeDates) obj = JSON.parse(contents, dateTimeDeserializer);
							else obj = JSON.parse(contents);
							response.result = obj;
						}
						response.headers = res.message.headers;
					} catch (err) {}
					if (statusCode > 299) {
						let msg;
						if (obj && obj.message) msg = obj.message;
						else if (contents && contents.length > 0) msg = contents;
						else msg = `Failed request: (${statusCode})`;
						const err = new HttpClientError(msg, statusCode);
						err.result = response.result;
						reject(err);
					} else resolve(response);
				}));
			});
		}
	};
	exports.HttpClient = HttpClient;
	const lowercaseKeys = (obj) => Object.keys(obj).reduce((c$5, k$5) => (c$5[k$5.toLowerCase()] = obj[k$5], c$5), {});
}));

//#endregion
//#region node_modules/@actions/http-client/lib/auth.js
var require_auth = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$9 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
	var BasicCredentialHandler = class {
		constructor(username, password) {
			this.username = username;
			this.password = password;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BasicCredentialHandler = BasicCredentialHandler;
	var BearerCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Bearer ${this.token}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.BearerCredentialHandler = BearerCredentialHandler;
	var PersonalAccessTokenCredentialHandler = class {
		constructor(token) {
			this.token = token;
		}
		prepareRequest(options) {
			if (!options.headers) throw Error("The request has no headers");
			options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
		}
		canHandleAuthentication() {
			return false;
		}
		handleAuthentication() {
			return __awaiter$9(this, void 0, void 0, function* () {
				throw new Error("not implemented");
			});
		}
	};
	exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
}));

//#endregion
//#region node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$8 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.OidcClient = void 0;
	const http_client_1 = require_lib();
	const auth_1 = require_auth();
	const core_1$6 = require_core();
	var OidcClient = class OidcClient {
		static createHttpClient(allowRetry = true, maxRetry = 10) {
			const requestOptions = {
				allowRetries: allowRetry,
				maxRetries: maxRetry
			};
			return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
		}
		static getRequestToken() {
			const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
			if (!token) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
			return token;
		}
		static getIDTokenUrl() {
			const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
			if (!runtimeUrl) throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
			return runtimeUrl;
		}
		static getCall(id_token_url) {
			var _a$2;
			return __awaiter$8(this, void 0, void 0, function* () {
				const id_token = (_a$2 = (yield OidcClient.createHttpClient().getJson(id_token_url).catch((error$2) => {
					throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error$2.statusCode}\n 
        Error Message: ${error$2.message}`);
				})).result) === null || _a$2 === void 0 ? void 0 : _a$2.value;
				if (!id_token) throw new Error("Response json body do not have ID Token field");
				return id_token;
			});
		}
		static getIDToken(audience) {
			return __awaiter$8(this, void 0, void 0, function* () {
				try {
					let id_token_url = OidcClient.getIDTokenUrl();
					if (audience) id_token_url = `${id_token_url}&audience=${encodeURIComponent(audience)}`;
					(0, core_1$6.debug)(`ID token url is ${id_token_url}`);
					const id_token = yield OidcClient.getCall(id_token_url);
					(0, core_1$6.setSecret)(id_token);
					return id_token;
				} catch (error$2) {
					throw new Error(`Error message: ${error$2.message}`);
				}
			});
		}
	};
	exports.OidcClient = OidcClient;
}));

//#endregion
//#region node_modules/@actions/core/lib/summary.js
var require_summary = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __awaiter$7 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
	const os_1$2 = __require("os");
	const fs_1$1 = __require("fs");
	const { access, appendFile, writeFile: writeFile$1 } = fs_1$1.promises;
	exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
	exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
	var Summary = class {
		constructor() {
			this._buffer = "";
		}
		/**
		* Finds the summary file path from the environment, rejects if env var is not found or file does not exist
		* Also checks r/w permissions.
		*
		* @returns step summary file path
		*/
		filePath() {
			return __awaiter$7(this, void 0, void 0, function* () {
				if (this._filePath) return this._filePath;
				const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
				if (!pathFromEnv) throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
				try {
					yield access(pathFromEnv, fs_1$1.constants.R_OK | fs_1$1.constants.W_OK);
				} catch (_a$2) {
					throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
				}
				this._filePath = pathFromEnv;
				return this._filePath;
			});
		}
		/**
		* Wraps content in an HTML tag, adding any HTML attributes
		*
		* @param {string} tag HTML tag to wrap
		* @param {string | null} content content within the tag
		* @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
		*
		* @returns {string} content wrapped in HTML element
		*/
		wrap(tag$1, content, attrs = {}) {
			const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
			if (!content) return `<${tag$1}${htmlAttrs}>`;
			return `<${tag$1}${htmlAttrs}>${content}</${tag$1}>`;
		}
		/**
		* Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
		*
		* @param {SummaryWriteOptions} [options] (optional) options for write operation
		*
		* @returns {Promise<Summary>} summary instance
		*/
		write(options) {
			return __awaiter$7(this, void 0, void 0, function* () {
				const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
				const filePath = yield this.filePath();
				yield (overwrite ? writeFile$1 : appendFile)(filePath, this._buffer, { encoding: "utf8" });
				return this.emptyBuffer();
			});
		}
		/**
		* Clears the summary buffer and wipes the summary file
		*
		* @returns {Summary} summary instance
		*/
		clear() {
			return __awaiter$7(this, void 0, void 0, function* () {
				return this.emptyBuffer().write({ overwrite: true });
			});
		}
		/**
		* Returns the current summary buffer as a string
		*
		* @returns {string} string of summary buffer
		*/
		stringify() {
			return this._buffer;
		}
		/**
		* If the summary buffer is empty
		*
		* @returns {boolen} true if the buffer is empty
		*/
		isEmptyBuffer() {
			return this._buffer.length === 0;
		}
		/**
		* Resets the summary buffer without writing to summary file
		*
		* @returns {Summary} summary instance
		*/
		emptyBuffer() {
			this._buffer = "";
			return this;
		}
		/**
		* Adds raw text to the summary buffer
		*
		* @param {string} text content to add
		* @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addRaw(text, addEOL = false) {
			this._buffer += text;
			return addEOL ? this.addEOL() : this;
		}
		/**
		* Adds the operating system-specific end-of-line marker to the buffer
		*
		* @returns {Summary} summary instance
		*/
		addEOL() {
			return this.addRaw(os_1$2.EOL);
		}
		/**
		* Adds an HTML codeblock to the summary buffer
		*
		* @param {string} code content to render within fenced code block
		* @param {string} lang (optional) language to syntax highlight code
		*
		* @returns {Summary} summary instance
		*/
		addCodeBlock(code, lang) {
			const attrs = Object.assign({}, lang && { lang });
			const element = this.wrap("pre", this.wrap("code", code), attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML list to the summary buffer
		*
		* @param {string[]} items list of items to render
		* @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
		*
		* @returns {Summary} summary instance
		*/
		addList(items, ordered = false) {
			const tag$1 = ordered ? "ol" : "ul";
			const listItems = items.map((item) => this.wrap("li", item)).join("");
			const element = this.wrap(tag$1, listItems);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML table to the summary buffer
		*
		* @param {SummaryTableCell[]} rows table rows
		*
		* @returns {Summary} summary instance
		*/
		addTable(rows) {
			const tableBody = rows.map((row) => {
				const cells = row.map((cell) => {
					if (typeof cell === "string") return this.wrap("td", cell);
					const { header, data: data$1, colspan, rowspan } = cell;
					const tag$1 = header ? "th" : "td";
					const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
					return this.wrap(tag$1, data$1, attrs);
				}).join("");
				return this.wrap("tr", cells);
			}).join("");
			const element = this.wrap("table", tableBody);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds a collapsable HTML details element to the summary buffer
		*
		* @param {string} label text for the closed state
		* @param {string} content collapsable content
		*
		* @returns {Summary} summary instance
		*/
		addDetails(label, content) {
			const element = this.wrap("details", this.wrap("summary", label) + content);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML image tag to the summary buffer
		*
		* @param {string} src path to the image you to embed
		* @param {string} alt text description of the image
		* @param {SummaryImageOptions} options (optional) addition image attributes
		*
		* @returns {Summary} summary instance
		*/
		addImage(src, alt, options) {
			const { width, height } = options || {};
			const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
			const element = this.wrap("img", null, Object.assign({
				src,
				alt
			}, attrs));
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML section heading element
		*
		* @param {string} text heading text
		* @param {number | string} [level=1] (optional) the heading level, default: 1
		*
		* @returns {Summary} summary instance
		*/
		addHeading(text, level) {
			const tag$1 = `h${level}`;
			const allowedTag = [
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6"
			].includes(tag$1) ? tag$1 : "h1";
			const element = this.wrap(allowedTag, text);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML thematic break (<hr>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addSeparator() {
			const element = this.wrap("hr", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML line break (<br>) to the summary buffer
		*
		* @returns {Summary} summary instance
		*/
		addBreak() {
			const element = this.wrap("br", null);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML blockquote to the summary buffer
		*
		* @param {string} text quote text
		* @param {string} cite (optional) citation url
		*
		* @returns {Summary} summary instance
		*/
		addQuote(text, cite) {
			const attrs = Object.assign({}, cite && { cite });
			const element = this.wrap("blockquote", text, attrs);
			return this.addRaw(element).addEOL();
		}
		/**
		* Adds an HTML anchor tag to the summary buffer
		*
		* @param {string} text link text/content
		* @param {string} href hyperlink
		*
		* @returns {Summary} summary instance
		*/
		addLink(text, href) {
			const element = this.wrap("a", text, { href });
			return this.addRaw(element).addEOL();
		}
	};
	const _summary = new Summary();
	/**
	* @deprecated use `core.summary`
	*/
	exports.markdownSummary = _summary;
	exports.summary = _summary;
}));

//#endregion
//#region node_modules/@actions/core/lib/path-utils.js
var require_path_utils = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$8 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$8 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$8 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$8(result, mod, k$5);
		}
		__setModuleDefault$8(result, mod);
		return result;
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
	const path$5 = __importStar$8(__require("path"));
	/**
	* toPosixPath converts the given path to the posix form. On Windows, \\ will be
	* replaced with /.
	*
	* @param pth. Path to transform.
	* @return string Posix path.
	*/
	function toPosixPath(pth) {
		return pth.replace(/[\\]/g, "/");
	}
	exports.toPosixPath = toPosixPath;
	/**
	* toWin32Path converts the given path to the win32 form. On Linux, / will be
	* replaced with \\.
	*
	* @param pth. Path to transform.
	* @return string Win32 path.
	*/
	function toWin32Path(pth) {
		return pth.replace(/[/]/g, "\\");
	}
	exports.toWin32Path = toWin32Path;
	/**
	* toPlatformPath converts the given path to a platform-specific path. It does
	* this by replacing instances of / and \ with the platform-specific path
	* separator.
	*
	* @param pth The path to platformize.
	* @return string The platform-specific path.
	*/
	function toPlatformPath(pth) {
		return pth.replace(/[/\\]/g, path$5.sep);
	}
	exports.toPlatformPath = toPlatformPath;
}));

//#endregion
//#region node_modules/@actions/io/lib/io-util.js
var require_io_util = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$7 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		Object.defineProperty(o$5, k2, {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		});
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$7 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$7 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.hasOwnProperty.call(mod, k$5)) __createBinding$7(result, mod, k$5);
		}
		__setModuleDefault$7(result, mod);
		return result;
	};
	var __awaiter$6 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var _a$1;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
	const fs$1 = __importStar$7(__require("fs"));
	const path$4 = __importStar$7(__require("path"));
	_a$1 = fs$1.promises, exports.chmod = _a$1.chmod, exports.copyFile = _a$1.copyFile, exports.lstat = _a$1.lstat, exports.mkdir = _a$1.mkdir, exports.open = _a$1.open, exports.readdir = _a$1.readdir, exports.readlink = _a$1.readlink, exports.rename = _a$1.rename, exports.rm = _a$1.rm, exports.rmdir = _a$1.rmdir, exports.stat = _a$1.stat, exports.symlink = _a$1.symlink, exports.unlink = _a$1.unlink;
	exports.IS_WINDOWS = process.platform === "win32";
	exports.UV_FS_O_EXLOCK = 268435456;
	exports.READONLY = fs$1.constants.O_RDONLY;
	function exists(fsPath) {
		return __awaiter$6(this, void 0, void 0, function* () {
			try {
				yield exports.stat(fsPath);
			} catch (err) {
				if (err.code === "ENOENT") return false;
				throw err;
			}
			return true;
		});
	}
	exports.exists = exists;
	function isDirectory(fsPath, useStat = false) {
		return __awaiter$6(this, void 0, void 0, function* () {
			return (useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath)).isDirectory();
		});
	}
	exports.isDirectory = isDirectory;
	/**
	* On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:
	* \, \hello, \\hello\share, C:, and C:\hello (and corresponding alternate separator cases).
	*/
	function isRooted(p$5) {
		p$5 = normalizeSeparators(p$5);
		if (!p$5) throw new Error("isRooted() parameter \"p\" cannot be empty");
		if (exports.IS_WINDOWS) return p$5.startsWith("\\") || /^[A-Z]:/i.test(p$5);
		return p$5.startsWith("/");
	}
	exports.isRooted = isRooted;
	/**
	* Best effort attempt to determine whether a file exists and is executable.
	* @param filePath    file path to check
	* @param extensions  additional file extensions to try
	* @return if file exists and is executable, returns the file path. otherwise empty string.
	*/
	function tryGetExecutablePath(filePath, extensions) {
		return __awaiter$6(this, void 0, void 0, function* () {
			let stats = void 0;
			try {
				stats = yield exports.stat(filePath);
			} catch (err) {
				if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
			}
			if (stats && stats.isFile()) {
				if (exports.IS_WINDOWS) {
					const upperExt = path$4.extname(filePath).toUpperCase();
					if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) return filePath;
				} else if (isUnixExecutable(stats)) return filePath;
			}
			const originalFilePath = filePath;
			for (const extension of extensions) {
				filePath = originalFilePath + extension;
				stats = void 0;
				try {
					stats = yield exports.stat(filePath);
				} catch (err) {
					if (err.code !== "ENOENT") console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
				}
				if (stats && stats.isFile()) {
					if (exports.IS_WINDOWS) {
						try {
							const directory = path$4.dirname(filePath);
							const upperName = path$4.basename(filePath).toUpperCase();
							for (const actualName of yield exports.readdir(directory)) if (upperName === actualName.toUpperCase()) {
								filePath = path$4.join(directory, actualName);
								break;
							}
						} catch (err) {
							console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
						}
						return filePath;
					} else if (isUnixExecutable(stats)) return filePath;
				}
			}
			return "";
		});
	}
	exports.tryGetExecutablePath = tryGetExecutablePath;
	function normalizeSeparators(p$5) {
		p$5 = p$5 || "";
		if (exports.IS_WINDOWS) {
			p$5 = p$5.replace(/\//g, "\\");
			return p$5.replace(/\\\\+/g, "\\");
		}
		return p$5.replace(/\/\/+/g, "/");
	}
	function isUnixExecutable(stats) {
		return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
	}
	function getCmdPath() {
		var _a$2;
		return (_a$2 = process.env["COMSPEC"]) !== null && _a$2 !== void 0 ? _a$2 : `cmd.exe`;
	}
	exports.getCmdPath = getCmdPath;
}));

//#endregion
//#region node_modules/@actions/io/lib/io.js
var require_io = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$6 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		Object.defineProperty(o$5, k2, {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		});
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$6 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$6 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.hasOwnProperty.call(mod, k$5)) __createBinding$6(result, mod, k$5);
		}
		__setModuleDefault$6(result, mod);
		return result;
	};
	var __awaiter$5 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
	const assert_1 = __require("assert");
	const path$3 = __importStar$6(__require("path"));
	const ioUtil$1 = __importStar$6(require_io_util());
	/**
	* Copies a file or folder.
	* Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See CopyOptions.
	*/
	function cp(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			const { force, recursive, copySourceDirectory } = readCopyOptions(options);
			const destStat = (yield ioUtil$1.exists(dest)) ? yield ioUtil$1.stat(dest) : null;
			if (destStat && destStat.isFile() && !force) return;
			const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path$3.join(dest, path$3.basename(source)) : dest;
			if (!(yield ioUtil$1.exists(source))) throw new Error(`no such file or directory: ${source}`);
			if ((yield ioUtil$1.stat(source)).isDirectory()) if (!recursive) throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
			else yield cpDirRecursive(source, newDest, 0, force);
			else {
				if (path$3.relative(source, newDest) === "") throw new Error(`'${newDest}' and '${source}' are the same file`);
				yield copyFile(source, newDest, force);
			}
		});
	}
	exports.cp = cp;
	/**
	* Moves a path.
	*
	* @param     source    source path
	* @param     dest      destination path
	* @param     options   optional. See MoveOptions.
	*/
	function mv(source, dest, options = {}) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (yield ioUtil$1.exists(dest)) {
				let destExists = true;
				if (yield ioUtil$1.isDirectory(dest)) {
					dest = path$3.join(dest, path$3.basename(source));
					destExists = yield ioUtil$1.exists(dest);
				}
				if (destExists) if (options.force == null || options.force) yield rmRF(dest);
				else throw new Error("Destination already exists");
			}
			yield mkdirP(path$3.dirname(dest));
			yield ioUtil$1.rename(source, dest);
		});
	}
	exports.mv = mv;
	/**
	* Remove a path recursively with force
	*
	* @param inputPath path to remove
	*/
	function rmRF(inputPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (ioUtil$1.IS_WINDOWS) {
				if (/[*"<>|]/.test(inputPath)) throw new Error("File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows");
			}
			try {
				yield ioUtil$1.rm(inputPath, {
					force: true,
					maxRetries: 3,
					recursive: true,
					retryDelay: 300
				});
			} catch (err) {
				throw new Error(`File was unable to be removed ${err}`);
			}
		});
	}
	exports.rmRF = rmRF;
	/**
	* Make a directory.  Creates the full path with folders in between
	* Will throw if it fails
	*
	* @param   fsPath        path to create
	* @returns Promise<void>
	*/
	function mkdirP(fsPath) {
		return __awaiter$5(this, void 0, void 0, function* () {
			assert_1.ok(fsPath, "a path argument must be provided");
			yield ioUtil$1.mkdir(fsPath, { recursive: true });
		});
	}
	exports.mkdirP = mkdirP;
	/**
	* Returns path of a tool had the tool actually been invoked.  Resolves via paths.
	* If you check and the tool does not exist, it will throw.
	*
	* @param     tool              name of the tool
	* @param     check             whether to check if tool exists
	* @returns   Promise<string>   path to tool
	*/
	function which(tool, check) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			if (check) {
				const result = yield which(tool, false);
				if (!result) if (ioUtil$1.IS_WINDOWS) throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
				else throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
				return result;
			}
			const matches = yield findInPath(tool);
			if (matches && matches.length > 0) return matches[0];
			return "";
		});
	}
	exports.which = which;
	/**
	* Returns a list of all occurrences of the given tool on the system path.
	*
	* @returns   Promise<string[]>  the paths of the tool
	*/
	function findInPath(tool) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (!tool) throw new Error("parameter 'tool' is required");
			const extensions = [];
			if (ioUtil$1.IS_WINDOWS && process.env["PATHEXT"]) {
				for (const extension of process.env["PATHEXT"].split(path$3.delimiter)) if (extension) extensions.push(extension);
			}
			if (ioUtil$1.isRooted(tool)) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(tool, extensions);
				if (filePath) return [filePath];
				return [];
			}
			if (tool.includes(path$3.sep)) return [];
			const directories = [];
			if (process.env.PATH) {
				for (const p$5 of process.env.PATH.split(path$3.delimiter)) if (p$5) directories.push(p$5);
			}
			const matches = [];
			for (const directory of directories) {
				const filePath = yield ioUtil$1.tryGetExecutablePath(path$3.join(directory, tool), extensions);
				if (filePath) matches.push(filePath);
			}
			return matches;
		});
	}
	exports.findInPath = findInPath;
	function readCopyOptions(options) {
		return {
			force: options.force == null ? true : options.force,
			recursive: Boolean(options.recursive),
			copySourceDirectory: options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory)
		};
	}
	function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if (currentDepth >= 255) return;
			currentDepth++;
			yield mkdirP(destDir);
			const files = yield ioUtil$1.readdir(sourceDir);
			for (const fileName of files) {
				const srcFile = `${sourceDir}/${fileName}`;
				const destFile = `${destDir}/${fileName}`;
				if ((yield ioUtil$1.lstat(srcFile)).isDirectory()) yield cpDirRecursive(srcFile, destFile, currentDepth, force);
				else yield copyFile(srcFile, destFile, force);
			}
			yield ioUtil$1.chmod(destDir, (yield ioUtil$1.stat(sourceDir)).mode);
		});
	}
	function copyFile(srcFile, destFile, force) {
		return __awaiter$5(this, void 0, void 0, function* () {
			if ((yield ioUtil$1.lstat(srcFile)).isSymbolicLink()) {
				try {
					yield ioUtil$1.lstat(destFile);
					yield ioUtil$1.unlink(destFile);
				} catch (e$5) {
					if (e$5.code === "EPERM") {
						yield ioUtil$1.chmod(destFile, "0666");
						yield ioUtil$1.unlink(destFile);
					}
				}
				const symlinkFull = yield ioUtil$1.readlink(srcFile);
				yield ioUtil$1.symlink(symlinkFull, destFile, ioUtil$1.IS_WINDOWS ? "junction" : null);
			} else if (!(yield ioUtil$1.exists(destFile)) || force) yield ioUtil$1.copyFile(srcFile, destFile);
		});
	}
}));

//#endregion
//#region node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$5 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		Object.defineProperty(o$5, k2, {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		});
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$5 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$5 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.hasOwnProperty.call(mod, k$5)) __createBinding$5(result, mod, k$5);
		}
		__setModuleDefault$5(result, mod);
		return result;
	};
	var __awaiter$4 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.argStringToArray = exports.ToolRunner = void 0;
	const os$2 = __importStar$5(__require("os"));
	const events = __importStar$5(__require("events"));
	const child = __importStar$5(__require("child_process"));
	const path$2 = __importStar$5(__require("path"));
	const io = __importStar$5(require_io());
	const ioUtil = __importStar$5(require_io_util());
	const timers_1 = __require("timers");
	const IS_WINDOWS = process.platform === "win32";
	var ToolRunner = class extends events.EventEmitter {
		constructor(toolPath, args, options) {
			super();
			if (!toolPath) throw new Error("Parameter 'toolPath' cannot be null or empty.");
			this.toolPath = toolPath;
			this.args = args || [];
			this.options = options || {};
		}
		_debug(message) {
			if (this.options.listeners && this.options.listeners.debug) this.options.listeners.debug(message);
		}
		_getCommandString(options, noPrefix) {
			const toolPath = this._getSpawnFileName();
			const args = this._getSpawnArgs(options);
			let cmd = noPrefix ? "" : "[command]";
			if (IS_WINDOWS) if (this._isCmdFile()) {
				cmd += toolPath;
				for (const a$5 of args) cmd += ` ${a$5}`;
			} else if (options.windowsVerbatimArguments) {
				cmd += `"${toolPath}"`;
				for (const a$5 of args) cmd += ` ${a$5}`;
			} else {
				cmd += this._windowsQuoteCmdArg(toolPath);
				for (const a$5 of args) cmd += ` ${this._windowsQuoteCmdArg(a$5)}`;
			}
			else {
				cmd += toolPath;
				for (const a$5 of args) cmd += ` ${a$5}`;
			}
			return cmd;
		}
		_processLineBuffer(data$1, strBuffer, onLine) {
			try {
				let s$5 = strBuffer + data$1.toString();
				let n$5 = s$5.indexOf(os$2.EOL);
				while (n$5 > -1) {
					onLine(s$5.substring(0, n$5));
					s$5 = s$5.substring(n$5 + os$2.EOL.length);
					n$5 = s$5.indexOf(os$2.EOL);
				}
				return s$5;
			} catch (err) {
				this._debug(`error processing line. Failed with error ${err}`);
				return "";
			}
		}
		_getSpawnFileName() {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) return process.env["COMSPEC"] || "cmd.exe";
			}
			return this.toolPath;
		}
		_getSpawnArgs(options) {
			if (IS_WINDOWS) {
				if (this._isCmdFile()) {
					let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
					for (const a$5 of this.args) {
						argline += " ";
						argline += options.windowsVerbatimArguments ? a$5 : this._windowsQuoteCmdArg(a$5);
					}
					argline += "\"";
					return [argline];
				}
			}
			return this.args;
		}
		_endsWith(str, end) {
			return str.endsWith(end);
		}
		_isCmdFile() {
			const upperToolPath = this.toolPath.toUpperCase();
			return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
		}
		_windowsQuoteCmdArg(arg) {
			if (!this._isCmdFile()) return this._uvQuoteCmdArg(arg);
			if (!arg) return "\"\"";
			const cmdSpecialChars = [
				" ",
				"	",
				"&",
				"(",
				")",
				"[",
				"]",
				"{",
				"}",
				"^",
				"=",
				";",
				"!",
				"'",
				"+",
				",",
				"`",
				"~",
				"|",
				"<",
				">",
				"\""
			];
			let needsQuotes = false;
			for (const char of arg) if (cmdSpecialChars.some((x$5) => x$5 === char)) {
				needsQuotes = true;
				break;
			}
			if (!needsQuotes) return arg;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$5 = arg.length; i$5 > 0; i$5--) {
				reverse += arg[i$5 - 1];
				if (quoteHit && arg[i$5 - 1] === "\\") reverse += "\\";
				else if (arg[i$5 - 1] === "\"") {
					quoteHit = true;
					reverse += "\"";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_uvQuoteCmdArg(arg) {
			if (!arg) return "\"\"";
			if (!arg.includes(" ") && !arg.includes("	") && !arg.includes("\"")) return arg;
			if (!arg.includes("\"") && !arg.includes("\\")) return `"${arg}"`;
			let reverse = "\"";
			let quoteHit = true;
			for (let i$5 = arg.length; i$5 > 0; i$5--) {
				reverse += arg[i$5 - 1];
				if (quoteHit && arg[i$5 - 1] === "\\") reverse += "\\";
				else if (arg[i$5 - 1] === "\"") {
					quoteHit = true;
					reverse += "\\";
				} else quoteHit = false;
			}
			reverse += "\"";
			return reverse.split("").reverse().join("");
		}
		_cloneExecOptions(options) {
			options = options || {};
			const result = {
				cwd: options.cwd || process.cwd(),
				env: options.env || process.env,
				silent: options.silent || false,
				windowsVerbatimArguments: options.windowsVerbatimArguments || false,
				failOnStdErr: options.failOnStdErr || false,
				ignoreReturnCode: options.ignoreReturnCode || false,
				delay: options.delay || 1e4
			};
			result.outStream = options.outStream || process.stdout;
			result.errStream = options.errStream || process.stderr;
			return result;
		}
		_getSpawnOptions(options, toolPath) {
			options = options || {};
			const result = {};
			result.cwd = options.cwd;
			result.env = options.env;
			result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
			if (options.windowsVerbatimArguments) result.argv0 = `"${toolPath}"`;
			return result;
		}
		/**
		* Exec a tool.
		* Output will be streamed to the live console.
		* Returns promise with return code
		*
		* @param     tool     path to tool to exec
		* @param     options  optional exec options.  See ExecOptions
		* @returns   number
		*/
		exec() {
			return __awaiter$4(this, void 0, void 0, function* () {
				if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) this.toolPath = path$2.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
				this.toolPath = yield io.which(this.toolPath, true);
				return new Promise((resolve, reject) => __awaiter$4(this, void 0, void 0, function* () {
					this._debug(`exec tool: ${this.toolPath}`);
					this._debug("arguments:");
					for (const arg of this.args) this._debug(`   ${arg}`);
					const optionsNonNull = this._cloneExecOptions(this.options);
					if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os$2.EOL);
					const state$1 = new ExecState(optionsNonNull, this.toolPath);
					state$1.on("debug", (message) => {
						this._debug(message);
					});
					if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) return reject(/* @__PURE__ */ new Error(`The cwd: ${this.options.cwd} does not exist!`));
					const fileName = this._getSpawnFileName();
					const cp$1 = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
					let stdbuffer = "";
					if (cp$1.stdout) cp$1.stdout.on("data", (data$1) => {
						if (this.options.listeners && this.options.listeners.stdout) this.options.listeners.stdout(data$1);
						if (!optionsNonNull.silent && optionsNonNull.outStream) optionsNonNull.outStream.write(data$1);
						stdbuffer = this._processLineBuffer(data$1, stdbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.stdline) this.options.listeners.stdline(line);
						});
					});
					let errbuffer = "";
					if (cp$1.stderr) cp$1.stderr.on("data", (data$1) => {
						state$1.processStderr = true;
						if (this.options.listeners && this.options.listeners.stderr) this.options.listeners.stderr(data$1);
						if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) (optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream).write(data$1);
						errbuffer = this._processLineBuffer(data$1, errbuffer, (line) => {
							if (this.options.listeners && this.options.listeners.errline) this.options.listeners.errline(line);
						});
					});
					cp$1.on("error", (err) => {
						state$1.processError = err.message;
						state$1.processExited = true;
						state$1.processClosed = true;
						state$1.CheckComplete();
					});
					cp$1.on("exit", (code) => {
						state$1.processExitCode = code;
						state$1.processExited = true;
						this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
						state$1.CheckComplete();
					});
					cp$1.on("close", (code) => {
						state$1.processExitCode = code;
						state$1.processExited = true;
						state$1.processClosed = true;
						this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
						state$1.CheckComplete();
					});
					state$1.on("done", (error$2, exitCode) => {
						if (stdbuffer.length > 0) this.emit("stdline", stdbuffer);
						if (errbuffer.length > 0) this.emit("errline", errbuffer);
						cp$1.removeAllListeners();
						if (error$2) reject(error$2);
						else resolve(exitCode);
					});
					if (this.options.input) {
						if (!cp$1.stdin) throw new Error("child process missing stdin");
						cp$1.stdin.end(this.options.input);
					}
				}));
			});
		}
	};
	exports.ToolRunner = ToolRunner;
	/**
	* Convert an arg string to an array of args. Handles escaping
	*
	* @param    argString   string of arguments
	* @returns  string[]    array of arguments
	*/
	function argStringToArray(argString) {
		const args = [];
		let inQuotes = false;
		let escaped = false;
		let arg = "";
		function append(c$5) {
			if (escaped && c$5 !== "\"") arg += "\\";
			arg += c$5;
			escaped = false;
		}
		for (let i$5 = 0; i$5 < argString.length; i$5++) {
			const c$5 = argString.charAt(i$5);
			if (c$5 === "\"") {
				if (!escaped) inQuotes = !inQuotes;
				else append(c$5);
				continue;
			}
			if (c$5 === "\\" && escaped) {
				append(c$5);
				continue;
			}
			if (c$5 === "\\" && inQuotes) {
				escaped = true;
				continue;
			}
			if (c$5 === " " && !inQuotes) {
				if (arg.length > 0) {
					args.push(arg);
					arg = "";
				}
				continue;
			}
			append(c$5);
		}
		if (arg.length > 0) args.push(arg.trim());
		return args;
	}
	exports.argStringToArray = argStringToArray;
	var ExecState = class ExecState extends events.EventEmitter {
		constructor(options, toolPath) {
			super();
			this.processClosed = false;
			this.processError = "";
			this.processExitCode = 0;
			this.processExited = false;
			this.processStderr = false;
			this.delay = 1e4;
			this.done = false;
			this.timeout = null;
			if (!toolPath) throw new Error("toolPath must not be empty");
			this.options = options;
			this.toolPath = toolPath;
			if (options.delay) this.delay = options.delay;
		}
		CheckComplete() {
			if (this.done) return;
			if (this.processClosed) this._setResult();
			else if (this.processExited) this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);
		}
		_debug(message) {
			this.emit("debug", message);
		}
		_setResult() {
			let error$2;
			if (this.processExited) {
				if (this.processError) error$2 = /* @__PURE__ */ new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
				else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) error$2 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
				else if (this.processStderr && this.options.failOnStdErr) error$2 = /* @__PURE__ */ new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
			}
			if (this.timeout) {
				clearTimeout(this.timeout);
				this.timeout = null;
			}
			this.done = true;
			this.emit("done", error$2, this.processExitCode);
		}
		static HandleTimeout(state$1) {
			if (state$1.done) return;
			if (!state$1.processClosed && state$1.processExited) {
				const message = `The STDIO streams did not close within ${state$1.delay / 1e3} seconds of the exit event from process '${state$1.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
				state$1._debug(message);
			}
			state$1._setResult();
		}
	};
}));

//#endregion
//#region node_modules/@actions/exec/lib/exec.js
var require_exec = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$4 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		Object.defineProperty(o$5, k2, {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		});
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$4 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$4 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.hasOwnProperty.call(mod, k$5)) __createBinding$4(result, mod, k$5);
		}
		__setModuleDefault$4(result, mod);
		return result;
	};
	var __awaiter$3 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getExecOutput = exports.exec = void 0;
	const string_decoder_1 = __require("string_decoder");
	const tr = __importStar$4(require_toolrunner());
	/**
	* Exec a command.
	* Output will be streamed to the live console.
	* Returns promise with return code
	*
	* @param     commandLine        command to execute (can include additional args). Must be correctly escaped.
	* @param     args               optional arguments for tool. Escaping is handled by the lib.
	* @param     options            optional exec options.  See ExecOptions
	* @returns   Promise<number>    exit code
	*/
	function exec$1(commandLine, args, options) {
		return __awaiter$3(this, void 0, void 0, function* () {
			const commandArgs = tr.argStringToArray(commandLine);
			if (commandArgs.length === 0) throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
			const toolPath = commandArgs[0];
			args = commandArgs.slice(1).concat(args || []);
			return new tr.ToolRunner(toolPath, args, options).exec();
		});
	}
	exports.exec = exec$1;
	/**
	* Exec a command and get the output.
	* Output will be streamed to the live console.
	* Returns promise with the exit code and collected stdout and stderr
	*
	* @param     commandLine           command to execute (can include additional args). Must be correctly escaped.
	* @param     args                  optional arguments for tool. Escaping is handled by the lib.
	* @param     options               optional exec options.  See ExecOptions
	* @returns   Promise<ExecOutput>   exit code, stdout, and stderr
	*/
	function getExecOutput(commandLine, args, options) {
		var _a$2, _b;
		return __awaiter$3(this, void 0, void 0, function* () {
			let stdout = "";
			let stderr = "";
			const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
			const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
			const originalStdoutListener = (_a$2 = options === null || options === void 0 ? void 0 : options.listeners) === null || _a$2 === void 0 ? void 0 : _a$2.stdout;
			const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
			const stdErrListener = (data$1) => {
				stderr += stderrDecoder.write(data$1);
				if (originalStdErrListener) originalStdErrListener(data$1);
			};
			const stdOutListener = (data$1) => {
				stdout += stdoutDecoder.write(data$1);
				if (originalStdoutListener) originalStdoutListener(data$1);
			};
			const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), {
				stdout: stdOutListener,
				stderr: stdErrListener
			});
			const exitCode = yield exec$1(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
			stdout += stdoutDecoder.end();
			stderr += stderrDecoder.end();
			return {
				exitCode,
				stdout,
				stderr
			};
		});
	}
	exports.getExecOutput = getExecOutput;
}));

//#endregion
//#region node_modules/@actions/core/lib/platform.js
var require_platform = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$3 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$3 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$3 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$3(result, mod, k$5);
		}
		__setModuleDefault$3(result, mod);
		return result;
	};
	var __awaiter$2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	var __importDefault$1 = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
	const os_1$1 = __importDefault$1(__require("os"));
	const exec = __importStar$3(require_exec());
	const getWindowsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout: version$1 } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Version\"", void 0, { silent: true });
		const { stdout: name } = yield exec.getExecOutput("powershell -command \"(Get-CimInstance -ClassName Win32_OperatingSystem).Caption\"", void 0, { silent: true });
		return {
			name: name.trim(),
			version: version$1.trim()
		};
	});
	const getMacOsInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		var _a$2, _b, _c$5, _d;
		const { stdout } = yield exec.getExecOutput("sw_vers", void 0, { silent: true });
		const version$1 = (_b = (_a$2 = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a$2 === void 0 ? void 0 : _a$2[1]) !== null && _b !== void 0 ? _b : "";
		return {
			name: (_d = (_c$5 = stdout.match(/ProductName:\s*(.+)/)) === null || _c$5 === void 0 ? void 0 : _c$5[1]) !== null && _d !== void 0 ? _d : "",
			version: version$1
		};
	});
	const getLinuxInfo = () => __awaiter$2(void 0, void 0, void 0, function* () {
		const { stdout } = yield exec.getExecOutput("lsb_release", [
			"-i",
			"-r",
			"-s"
		], { silent: true });
		const [name, version$1] = stdout.trim().split("\n");
		return {
			name,
			version: version$1
		};
	});
	exports.platform = os_1$1.default.platform();
	exports.arch = os_1$1.default.arch();
	exports.isWindows = exports.platform === "win32";
	exports.isMacOS = exports.platform === "darwin";
	exports.isLinux = exports.platform === "linux";
	function getDetails() {
		return __awaiter$2(this, void 0, void 0, function* () {
			return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
				platform: exports.platform,
				arch: exports.arch,
				isWindows: exports.isWindows,
				isMacOS: exports.isMacOS,
				isLinux: exports.isLinux
			});
		});
	}
	exports.getDetails = getDetails;
}));

//#endregion
//#region node_modules/@actions/core/lib/core.js
var require_core = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding$2 = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault$2 = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar$2 = exports && exports.__importStar || function(mod) {
		if (mod && mod.__esModule) return mod;
		var result = {};
		if (mod != null) {
			for (var k$5 in mod) if (k$5 !== "default" && Object.prototype.hasOwnProperty.call(mod, k$5)) __createBinding$2(result, mod, k$5);
		}
		__setModuleDefault$2(result, mod);
		return result;
	};
	var __awaiter$1 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P ? value : new P(function(resolve) {
				resolve(value);
			});
		}
		return new (P || (P = Promise))(function(resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e$5) {
					reject(e$5);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, _arguments || [])).next());
		});
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
	const command_1 = require_command();
	const file_command_1 = require_file_command();
	const utils_1 = require_utils$1();
	const os$1 = __importStar$2(__require("os"));
	const path$1 = __importStar$2(__require("path"));
	const oidc_utils_1 = require_oidc_utils();
	/**
	* The code to exit an action
	*/
	var ExitCode;
	(function(ExitCode$1) {
		/**
		* A code indicating that the action was successful
		*/
		ExitCode$1[ExitCode$1["Success"] = 0] = "Success";
		/**
		* A code indicating that the action was a failure
		*/
		ExitCode$1[ExitCode$1["Failure"] = 1] = "Failure";
	})(ExitCode || (exports.ExitCode = ExitCode = {}));
	/**
	* Sets env variable for this action and future actions in the job
	* @param name the name of the variable to set
	* @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
	*/
	function exportVariable(name, val) {
		const convertedVal = (0, utils_1.toCommandValue)(val);
		process.env[name] = convertedVal;
		if (process.env["GITHUB_ENV"] || "") return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
		(0, command_1.issueCommand)("set-env", { name }, convertedVal);
	}
	exports.exportVariable = exportVariable;
	/**
	* Registers a secret which will get masked from logs
	* @param secret value of the secret
	*/
	function setSecret(secret) {
		(0, command_1.issueCommand)("add-mask", {}, secret);
	}
	exports.setSecret = setSecret;
	/**
	* Prepends inputPath to the PATH (for this action and future actions)
	* @param inputPath
	*/
	function addPath(inputPath) {
		if (process.env["GITHUB_PATH"] || "") (0, file_command_1.issueFileCommand)("PATH", inputPath);
		else (0, command_1.issueCommand)("add-path", {}, inputPath);
		process.env["PATH"] = `${inputPath}${path$1.delimiter}${process.env["PATH"]}`;
	}
	exports.addPath = addPath;
	/**
	* Gets the value of an input.
	* Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
	* Returns an empty string if the value is not defined.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string
	*/
	function getInput(name, options) {
		const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
		if (options && options.required && !val) throw new Error(`Input required and not supplied: ${name}`);
		if (options && options.trimWhitespace === false) return val;
		return val.trim();
	}
	exports.getInput = getInput;
	/**
	* Gets the values of an multiline input.  Each value is also trimmed.
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   string[]
	*
	*/
	function getMultilineInput(name, options) {
		const inputs = getInput(name, options).split("\n").filter((x$5) => x$5 !== "");
		if (options && options.trimWhitespace === false) return inputs;
		return inputs.map((input) => input.trim());
	}
	exports.getMultilineInput = getMultilineInput;
	/**
	* Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
	* Support boolean input list: `true | True | TRUE | false | False | FALSE` .
	* The return value is also in boolean type.
	* ref: https://yaml.org/spec/1.2/spec.html#id2804923
	*
	* @param     name     name of the input to get
	* @param     options  optional. See InputOptions.
	* @returns   boolean
	*/
	function getBooleanInput(name, options) {
		const trueValue = [
			"true",
			"True",
			"TRUE"
		];
		const falseValue = [
			"false",
			"False",
			"FALSE"
		];
		const val = getInput(name, options);
		if (trueValue.includes(val)) return true;
		if (falseValue.includes(val)) return false;
		throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\nSupport boolean input list: \`true | True | TRUE | false | False | FALSE\``);
	}
	exports.getBooleanInput = getBooleanInput;
	/**
	* Sets the value of an output.
	*
	* @param     name     name of the output to set
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function setOutput(name, value) {
		if (process.env["GITHUB_OUTPUT"] || "") return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
		process.stdout.write(os$1.EOL);
		(0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
	}
	exports.setOutput = setOutput;
	/**
	* Enables or disables the echoing of commands into stdout for the rest of the step.
	* Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
	*
	*/
	function setCommandEcho(enabled) {
		(0, command_1.issue)("echo", enabled ? "on" : "off");
	}
	exports.setCommandEcho = setCommandEcho;
	/**
	* Sets the action status to failed.
	* When the action exits it will be with an exit code of 1
	* @param message add error issue message
	*/
	function setFailed(message) {
		process.exitCode = ExitCode.Failure;
		error$1(message);
	}
	exports.setFailed = setFailed;
	/**
	* Gets whether Actions Step Debug is on or not
	*/
	function isDebug() {
		return process.env["RUNNER_DEBUG"] === "1";
	}
	exports.isDebug = isDebug;
	/**
	* Writes debug message to user log
	* @param message debug message
	*/
	function debug(message) {
		(0, command_1.issueCommand)("debug", {}, message);
	}
	exports.debug = debug;
	/**
	* Adds an error issue
	* @param message error issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function error$1(message, properties = {}) {
		(0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.error = error$1;
	/**
	* Adds a warning issue
	* @param message warning issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function warning(message, properties = {}) {
		(0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.warning = warning;
	/**
	* Adds a notice issue
	* @param message notice issue message. Errors will be converted to string via toString()
	* @param properties optional properties to add to the annotation.
	*/
	function notice(message, properties = {}) {
		(0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
	}
	exports.notice = notice;
	/**
	* Writes info to log with console.log.
	* @param message info message
	*/
	function info(message) {
		process.stdout.write(message + os$1.EOL);
	}
	exports.info = info;
	/**
	* Begin an output group.
	*
	* Output until the next `groupEnd` will be foldable in this group
	*
	* @param name The name of the output group
	*/
	function startGroup(name) {
		(0, command_1.issue)("group", name);
	}
	exports.startGroup = startGroup;
	/**
	* End an output group.
	*/
	function endGroup() {
		(0, command_1.issue)("endgroup");
	}
	exports.endGroup = endGroup;
	/**
	* Wrap an asynchronous function call in a group.
	*
	* Returns the same type as the function itself.
	*
	* @param name The name of the group
	* @param fn The function to wrap in the group
	*/
	function group$3(name, fn) {
		return __awaiter$1(this, void 0, void 0, function* () {
			startGroup(name);
			let result;
			try {
				result = yield fn();
			} finally {
				endGroup();
			}
			return result;
		});
	}
	exports.group = group$3;
	/**
	* Saves state for current action, the state can only be retrieved by this action's post job execution.
	*
	* @param     name     name of the state to store
	* @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
	*/
	function saveState(name, value) {
		if (process.env["GITHUB_STATE"] || "") return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
		(0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
	}
	exports.saveState = saveState;
	/**
	* Gets the value of an state set by this action's main execution.
	*
	* @param     name     name of the state to get
	* @returns   string
	*/
	function getState(name) {
		return process.env[`STATE_${name}`] || "";
	}
	exports.getState = getState;
	function getIDToken(aud) {
		return __awaiter$1(this, void 0, void 0, function* () {
			return yield oidc_utils_1.OidcClient.getIDToken(aud);
		});
	}
	exports.getIDToken = getIDToken;
	/**
	* Summary exports
	*/
	var summary_1 = require_summary();
	Object.defineProperty(exports, "summary", {
		enumerable: true,
		get: function() {
			return summary_1.summary;
		}
	});
	/**
	* @deprecated use core.summary
	*/
	var summary_2 = require_summary();
	Object.defineProperty(exports, "markdownSummary", {
		enumerable: true,
		get: function() {
			return summary_2.markdownSummary;
		}
	});
	/**
	* Path exports
	*/
	var path_utils_1 = require_path_utils();
	Object.defineProperty(exports, "toPosixPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPosixPath;
		}
	});
	Object.defineProperty(exports, "toWin32Path", {
		enumerable: true,
		get: function() {
			return path_utils_1.toWin32Path;
		}
	});
	Object.defineProperty(exports, "toPlatformPath", {
		enumerable: true,
		get: function() {
			return path_utils_1.toPlatformPath;
		}
	});
	/**
	* Platform utilities exports
	*/
	exports.platform = __importStar$2(require_platform());
}));

//#endregion
//#region node_modules/@smithy/types/dist-cjs/index.js
var require_dist_cjs$53 = /* @__PURE__ */ __commonJSMin(((exports) => {
	exports.HttpAuthLocation = void 0;
	(function(HttpAuthLocation) {
		HttpAuthLocation["HEADER"] = "header";
		HttpAuthLocation["QUERY"] = "query";
	})(exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));
	exports.HttpApiKeyAuthLocation = void 0;
	(function(HttpApiKeyAuthLocation$1) {
		HttpApiKeyAuthLocation$1["HEADER"] = "header";
		HttpApiKeyAuthLocation$1["QUERY"] = "query";
	})(exports.HttpApiKeyAuthLocation || (exports.HttpApiKeyAuthLocation = {}));
	exports.EndpointURLScheme = void 0;
	(function(EndpointURLScheme) {
		EndpointURLScheme["HTTP"] = "http";
		EndpointURLScheme["HTTPS"] = "https";
	})(exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));
	exports.AlgorithmId = void 0;
	(function(AlgorithmId) {
		AlgorithmId["MD5"] = "md5";
		AlgorithmId["CRC32"] = "crc32";
		AlgorithmId["CRC32C"] = "crc32c";
		AlgorithmId["SHA1"] = "sha1";
		AlgorithmId["SHA256"] = "sha256";
	})(exports.AlgorithmId || (exports.AlgorithmId = {}));
	const getChecksumConfiguration$1 = (runtimeConfig$2) => {
		const checksumAlgorithms = [];
		if (runtimeConfig$2.sha256 !== void 0) checksumAlgorithms.push({
			algorithmId: () => exports.AlgorithmId.SHA256,
			checksumConstructor: () => runtimeConfig$2.sha256
		});
		if (runtimeConfig$2.md5 != void 0) checksumAlgorithms.push({
			algorithmId: () => exports.AlgorithmId.MD5,
			checksumConstructor: () => runtimeConfig$2.md5
		});
		return {
			addChecksumAlgorithm(algo) {
				checksumAlgorithms.push(algo);
			},
			checksumAlgorithms() {
				return checksumAlgorithms;
			}
		};
	};
	const resolveChecksumRuntimeConfig$1 = (clientConfig) => {
		const runtimeConfig$2 = {};
		clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
			runtimeConfig$2[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
		});
		return runtimeConfig$2;
	};
	const getDefaultClientConfiguration$1 = (runtimeConfig$2) => {
		return getChecksumConfiguration$1(runtimeConfig$2);
	};
	const resolveDefaultRuntimeConfig$4 = (config) => {
		return resolveChecksumRuntimeConfig$1(config);
	};
	exports.FieldPosition = void 0;
	(function(FieldPosition) {
		FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
		FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
	})(exports.FieldPosition || (exports.FieldPosition = {}));
	const SMITHY_CONTEXT_KEY$1 = "__smithy_context";
	exports.IniSectionType = void 0;
	(function(IniSectionType) {
		IniSectionType["PROFILE"] = "profile";
		IniSectionType["SSO_SESSION"] = "sso-session";
		IniSectionType["SERVICES"] = "services";
	})(exports.IniSectionType || (exports.IniSectionType = {}));
	exports.RequestHandlerProtocol = void 0;
	(function(RequestHandlerProtocol) {
		RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
		RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
		RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
	})(exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));
	exports.SMITHY_CONTEXT_KEY = SMITHY_CONTEXT_KEY$1;
	exports.getDefaultClientConfiguration = getDefaultClientConfiguration$1;
	exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig$4;
}));

//#endregion
//#region node_modules/@smithy/protocol-http/dist-cjs/index.js
var require_dist_cjs$52 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var types$4 = require_dist_cjs$53();
	const getHttpHandlerExtensionConfiguration$3 = (runtimeConfig$2) => {
		return {
			setHttpHandler(handler) {
				runtimeConfig$2.httpHandler = handler;
			},
			httpHandler() {
				return runtimeConfig$2.httpHandler;
			},
			updateHttpClientConfig(key, value) {
				runtimeConfig$2.httpHandler?.updateHttpClientConfig(key, value);
			},
			httpHandlerConfigs() {
				return runtimeConfig$2.httpHandler.httpHandlerConfigs();
			}
		};
	};
	const resolveHttpHandlerRuntimeConfig$3 = (httpHandlerExtensionConfiguration) => {
		return { httpHandler: httpHandlerExtensionConfiguration.httpHandler() };
	};
	var Field = class {
		name;
		kind;
		values;
		constructor({ name, kind = types$4.FieldPosition.HEADER, values = [] }) {
			this.name = name;
			this.kind = kind;
			this.values = values;
		}
		add(value) {
			this.values.push(value);
		}
		set(values) {
			this.values = values;
		}
		remove(value) {
			this.values = this.values.filter((v$5) => v$5 !== value);
		}
		toString() {
			return this.values.map((v$5) => v$5.includes(",") || v$5.includes(" ") ? `"${v$5}"` : v$5).join(", ");
		}
		get() {
			return this.values;
		}
	};
	var Fields = class {
		entries = {};
		encoding;
		constructor({ fields = [], encoding = "utf-8" }) {
			fields.forEach(this.setField.bind(this));
			this.encoding = encoding;
		}
		setField(field) {
			this.entries[field.name.toLowerCase()] = field;
		}
		getField(name) {
			return this.entries[name.toLowerCase()];
		}
		removeField(name) {
			delete this.entries[name.toLowerCase()];
		}
		getByType(kind) {
			return Object.values(this.entries).filter((field) => field.kind === kind);
		}
	};
	var HttpRequest$9 = class HttpRequest$9 {
		method;
		protocol;
		hostname;
		port;
		path;
		query;
		headers;
		username;
		password;
		fragment;
		body;
		constructor(options) {
			this.method = options.method || "GET";
			this.hostname = options.hostname || "localhost";
			this.port = options.port;
			this.query = options.query || {};
			this.headers = options.headers || {};
			this.body = options.body;
			this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
			this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
			this.username = options.username;
			this.password = options.password;
			this.fragment = options.fragment;
		}
		static clone(request$1) {
			const cloned = new HttpRequest$9({
				...request$1,
				headers: { ...request$1.headers }
			});
			if (cloned.query) cloned.query = cloneQuery(cloned.query);
			return cloned;
		}
		static isInstance(request$1) {
			if (!request$1) return false;
			const req = request$1;
			return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
		}
		clone() {
			return HttpRequest$9.clone(this);
		}
	};
	function cloneQuery(query) {
		return Object.keys(query).reduce((carry, paramName) => {
			const param = query[paramName];
			return {
				...carry,
				[paramName]: Array.isArray(param) ? [...param] : param
			};
		}, {});
	}
	var HttpResponse$3 = class {
		statusCode;
		reason;
		headers;
		body;
		constructor(options) {
			this.statusCode = options.statusCode;
			this.reason = options.reason;
			this.headers = options.headers || {};
			this.body = options.body;
		}
		static isInstance(response) {
			if (!response) return false;
			const resp = response;
			return typeof resp.statusCode === "number" && typeof resp.headers === "object";
		}
	};
	function isValidHostname(hostname) {
		return /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/.test(hostname);
	}
	exports.Field = Field;
	exports.Fields = Fields;
	exports.HttpRequest = HttpRequest$9;
	exports.HttpResponse = HttpResponse$3;
	exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration$3;
	exports.isValidHostname = isValidHostname;
	exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig$3;
}));

//#endregion
//#region node_modules/@aws-sdk/middleware-host-header/dist-cjs/index.js
var require_dist_cjs$51 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var protocolHttp$10 = require_dist_cjs$52();
	function resolveHostHeaderConfig$3(input) {
		return input;
	}
	const hostHeaderMiddleware = (options) => (next) => async (args) => {
		if (!protocolHttp$10.HttpRequest.isInstance(args.request)) return next(args);
		const { request: request$1 } = args;
		const { handlerProtocol = "" } = options.requestHandler.metadata || {};
		if (handlerProtocol.indexOf("h2") >= 0 && !request$1.headers[":authority"]) {
			delete request$1.headers["host"];
			request$1.headers[":authority"] = request$1.hostname + (request$1.port ? ":" + request$1.port : "");
		} else if (!request$1.headers["host"]) {
			let host = request$1.hostname;
			if (request$1.port != null) host += `:${request$1.port}`;
			request$1.headers["host"] = host;
		}
		return next(args);
	};
	const hostHeaderMiddlewareOptions = {
		name: "hostHeaderMiddleware",
		step: "build",
		priority: "low",
		tags: ["HOST"],
		override: true
	};
	const getHostHeaderPlugin$3 = (options) => ({ applyToStack: (clientStack) => {
		clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
	} });
	exports.getHostHeaderPlugin = getHostHeaderPlugin$3;
	exports.hostHeaderMiddleware = hostHeaderMiddleware;
	exports.hostHeaderMiddlewareOptions = hostHeaderMiddlewareOptions;
	exports.resolveHostHeaderConfig = resolveHostHeaderConfig$3;
}));

//#endregion
//#region node_modules/@aws-sdk/middleware-logger/dist-cjs/index.js
var require_dist_cjs$50 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const loggerMiddleware = () => (next, context) => async (args) => {
		try {
			const response = await next(args);
			const { clientName, commandName, logger: logger$1, dynamoDbDocumentClientOptions = {} } = context;
			const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
			const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
			const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
			const { $metadata, ...outputWithoutMetadata } = response.output;
			logger$1?.info?.({
				clientName,
				commandName,
				input: inputFilterSensitiveLog(args.input),
				output: outputFilterSensitiveLog(outputWithoutMetadata),
				metadata: $metadata
			});
			return response;
		} catch (error$2) {
			const { clientName, commandName, logger: logger$1, dynamoDbDocumentClientOptions = {} } = context;
			const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
			const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
			logger$1?.error?.({
				clientName,
				commandName,
				input: inputFilterSensitiveLog(args.input),
				error: error$2,
				metadata: error$2.$metadata
			});
			throw error$2;
		}
	};
	const loggerMiddlewareOptions = {
		name: "loggerMiddleware",
		tags: ["LOGGER"],
		step: "initialize",
		override: true
	};
	const getLoggerPlugin$3 = (options) => ({ applyToStack: (clientStack) => {
		clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
	} });
	exports.getLoggerPlugin = getLoggerPlugin$3;
	exports.loggerMiddleware = loggerMiddleware;
	exports.loggerMiddlewareOptions = loggerMiddlewareOptions;
}));

//#endregion
//#region node_modules/@aws/lambda-invoke-store/dist-es/invoke-store.js
var invoke_store_exports = /* @__PURE__ */ __export({
	InvokeStore: () => InvokeStore,
	InvokeStoreBase: () => InvokeStoreBase
});
var PROTECTED_KEYS, NO_GLOBAL_AWS_LAMBDA, InvokeStoreBase, InvokeStoreSingle, InvokeStoreMulti, InvokeStore;
var init_invoke_store = __esmMin((() => {
	PROTECTED_KEYS = {
		REQUEST_ID: Symbol.for("_AWS_LAMBDA_REQUEST_ID"),
		X_RAY_TRACE_ID: Symbol.for("_AWS_LAMBDA_X_RAY_TRACE_ID"),
		TENANT_ID: Symbol.for("_AWS_LAMBDA_TENANT_ID")
	};
	NO_GLOBAL_AWS_LAMBDA = ["true", "1"].includes(process.env?.AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA ?? "");
	if (!NO_GLOBAL_AWS_LAMBDA) globalThis.awslambda = globalThis.awslambda || {};
	InvokeStoreBase = class {
		static PROTECTED_KEYS = PROTECTED_KEYS;
		isProtectedKey(key) {
			return Object.values(PROTECTED_KEYS).includes(key);
		}
		getRequestId() {
			return this.get(PROTECTED_KEYS.REQUEST_ID) ?? "-";
		}
		getXRayTraceId() {
			return this.get(PROTECTED_KEYS.X_RAY_TRACE_ID);
		}
		getTenantId() {
			return this.get(PROTECTED_KEYS.TENANT_ID);
		}
	};
	InvokeStoreSingle = class extends InvokeStoreBase {
		currentContext;
		getContext() {
			return this.currentContext;
		}
		hasContext() {
			return this.currentContext !== void 0;
		}
		get(key) {
			return this.currentContext?.[key];
		}
		set(key, value) {
			if (this.isProtectedKey(key)) throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
			this.currentContext = this.currentContext || {};
			this.currentContext[key] = value;
		}
		run(context, fn) {
			this.currentContext = context;
			try {
				return fn();
			} finally {
				this.currentContext = void 0;
			}
		}
	};
	InvokeStoreMulti = class InvokeStoreMulti extends InvokeStoreBase {
		als;
		static async create() {
			const instance = new InvokeStoreMulti();
			instance.als = new (await (import("node:async_hooks"))).AsyncLocalStorage();
			return instance;
		}
		getContext() {
			return this.als.getStore();
		}
		hasContext() {
			return this.als.getStore() !== void 0;
		}
		get(key) {
			return this.als.getStore()?.[key];
		}
		set(key, value) {
			if (this.isProtectedKey(key)) throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
			const store = this.als.getStore();
			if (!store) throw new Error("No context available");
			store[key] = value;
		}
		run(context, fn) {
			return this.als.run(context, fn);
		}
	};
	;
	(function(InvokeStore$1) {
		let instance = null;
		async function getInstanceAsync() {
			if (!instance) instance = (async () => {
				const newInstance = "AWS_LAMBDA_MAX_CONCURRENCY" in process.env ? await InvokeStoreMulti.create() : new InvokeStoreSingle();
				if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda?.InvokeStore) return globalThis.awslambda.InvokeStore;
				else if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda) {
					globalThis.awslambda.InvokeStore = newInstance;
					return newInstance;
				} else return newInstance;
			})();
			return instance;
		}
		InvokeStore$1.getInstanceAsync = getInstanceAsync;
		InvokeStore$1._testing = process.env.AWS_LAMBDA_BENCHMARK_MODE === "1" ? { reset: () => {
			instance = null;
			if (globalThis.awslambda?.InvokeStore) delete globalThis.awslambda.InvokeStore;
			globalThis.awslambda = {};
		} } : void 0;
	})(InvokeStore || (InvokeStore = {}));
}));

//#endregion
//#region node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/recursionDetectionMiddleware.js
var require_recursionDetectionMiddleware = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.recursionDetectionMiddleware = void 0;
	const lambda_invoke_store_1 = (init_invoke_store(), __toCommonJS(invoke_store_exports));
	const protocol_http_1$1 = require_dist_cjs$52();
	const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
	const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
	const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
	const recursionDetectionMiddleware$1 = () => (next) => async (args) => {
		const { request: request$1 } = args;
		if (!protocol_http_1$1.HttpRequest.isInstance(request$1)) return next(args);
		const traceIdHeader = Object.keys(request$1.headers ?? {}).find((h$5) => h$5.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
		if (request$1.headers.hasOwnProperty(traceIdHeader)) return next(args);
		const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
		const traceIdFromEnv = process.env[ENV_TRACE_ID];
		const traceId = (await lambda_invoke_store_1.InvokeStore.getInstanceAsync())?.getXRayTraceId() ?? traceIdFromEnv;
		const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
		if (nonEmptyString(functionName) && nonEmptyString(traceId)) request$1.headers[TRACE_ID_HEADER_NAME] = traceId;
		return next({
			...args,
			request: request$1
		});
	};
	exports.recursionDetectionMiddleware = recursionDetectionMiddleware$1;
}));

//#endregion
//#region node_modules/@aws-sdk/middleware-recursion-detection/dist-cjs/index.js
var require_dist_cjs$49 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var recursionDetectionMiddleware = require_recursionDetectionMiddleware();
	const recursionDetectionMiddlewareOptions = {
		step: "build",
		tags: ["RECURSION_DETECTION"],
		name: "recursionDetectionMiddleware",
		override: true,
		priority: "low"
	};
	const getRecursionDetectionPlugin$3 = (options) => ({ applyToStack: (clientStack) => {
		clientStack.add(recursionDetectionMiddleware.recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
	} });
	exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin$3;
	Object.keys(recursionDetectionMiddleware).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return recursionDetectionMiddleware[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/getSmithyContext.js
var import_dist_cjs$152, getSmithyContext$9;
var init_getSmithyContext = __esmMin((() => {
	import_dist_cjs$152 = require_dist_cjs$53();
	getSmithyContext$9 = (context) => context[import_dist_cjs$152.SMITHY_CONTEXT_KEY] || (context[import_dist_cjs$152.SMITHY_CONTEXT_KEY] = {});
}));

//#endregion
//#region node_modules/@smithy/util-middleware/dist-cjs/index.js
var require_dist_cjs$48 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var types$3 = require_dist_cjs$53();
	const getSmithyContext$8 = (context) => context[types$3.SMITHY_CONTEXT_KEY] || (context[types$3.SMITHY_CONTEXT_KEY] = {});
	const normalizeProvider$4 = (input) => {
		if (typeof input === "function") return input;
		const promisified = Promise.resolve(input);
		return () => promisified;
	};
	exports.getSmithyContext = getSmithyContext$8;
	exports.normalizeProvider = normalizeProvider$4;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/resolveAuthOptions.js
var resolveAuthOptions;
var init_resolveAuthOptions = __esmMin((() => {
	resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
		if (!authSchemePreference || authSchemePreference.length === 0) return candidateAuthOptions;
		const preferredAuthOptions = [];
		for (const preferredSchemeName of authSchemePreference) for (const candidateAuthOption of candidateAuthOptions) if (candidateAuthOption.schemeId.split("#")[1] === preferredSchemeName) preferredAuthOptions.push(candidateAuthOption);
		for (const candidateAuthOption of candidateAuthOptions) if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) preferredAuthOptions.push(candidateAuthOption);
		return preferredAuthOptions;
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/httpAuthSchemeMiddleware.js
function convertHttpAuthSchemesToMap(httpAuthSchemes$1) {
	const map$2 = /* @__PURE__ */ new Map();
	for (const scheme of httpAuthSchemes$1) map$2.set(scheme.schemeId, scheme);
	return map$2;
}
var import_dist_cjs$151, httpAuthSchemeMiddleware;
var init_httpAuthSchemeMiddleware = __esmMin((() => {
	import_dist_cjs$151 = require_dist_cjs$48();
	init_resolveAuthOptions();
	httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
		const resolvedOptions = resolveAuthOptions(config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input)), config.authSchemePreference ? await config.authSchemePreference() : []);
		const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
		const smithyContext = (0, import_dist_cjs$151.getSmithyContext)(context);
		const failureReasons = [];
		for (const option of resolvedOptions) {
			const scheme = authSchemes.get(option.schemeId);
			if (!scheme) {
				failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
				continue;
			}
			const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
			if (!identityProvider) {
				failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
				continue;
			}
			const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
			option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
			option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
			smithyContext.selectedHttpAuthScheme = {
				httpAuthOption: option,
				identity: await identityProvider(option.identityProperties),
				signer: scheme.signer
			};
			break;
		}
		if (!smithyContext.selectedHttpAuthScheme) throw new Error(failureReasons.join("\n"));
		return next(args);
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemeEndpointRuleSetPlugin.js
var httpAuthSchemeEndpointRuleSetMiddlewareOptions, getHttpAuthSchemeEndpointRuleSetPlugin;
var init_getHttpAuthSchemeEndpointRuleSetPlugin = __esmMin((() => {
	init_httpAuthSchemeMiddleware();
	httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
		step: "serialize",
		tags: ["HTTP_AUTH_SCHEME"],
		name: "httpAuthSchemeMiddleware",
		override: true,
		relation: "before",
		toMiddleware: "endpointV2Middleware"
	};
	getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({ applyToStack: (clientStack) => {
		clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
			httpAuthSchemeParametersProvider,
			identityProviderConfigProvider
		}), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
	} });
}));

//#endregion
//#region node_modules/@smithy/middleware-serde/dist-cjs/index.js
var require_dist_cjs$47 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var protocolHttp$9 = require_dist_cjs$52();
	const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
		const { response } = await next(args);
		try {
			return {
				response,
				output: await deserializer(response, options)
			};
		} catch (error$2) {
			Object.defineProperty(error$2, "$response", {
				value: response,
				enumerable: false,
				writable: false,
				configurable: false
			});
			if (!("$metadata" in error$2)) {
				const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
				try {
					error$2.message += "\n  " + hint;
				} catch (e$5) {
					if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") console.warn(hint);
					else context.logger?.warn?.(hint);
				}
				if (typeof error$2.$responseBodyText !== "undefined") {
					if (error$2.$response) error$2.$response.body = error$2.$responseBodyText;
				}
				try {
					if (protocolHttp$9.HttpResponse.isInstance(response)) {
						const { headers = {} } = response;
						const headerEntries = Object.entries(headers);
						error$2.$metadata = {
							httpStatusCode: response.statusCode,
							requestId: findHeader$1(/^x-[\w-]+-request-?id$/, headerEntries),
							extendedRequestId: findHeader$1(/^x-[\w-]+-id-2$/, headerEntries),
							cfId: findHeader$1(/^x-[\w-]+-cf-id$/, headerEntries)
						};
					}
				} catch (e$5) {}
			}
			throw error$2;
		}
	};
	const findHeader$1 = (pattern, headers) => {
		return (headers.find(([k$5]) => {
			return k$5.match(pattern);
		}) || [void 0, void 0])[1];
	};
	const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
		const endpointConfig = options;
		const endpoint = context.endpointV2?.url && endpointConfig.urlParser ? async () => endpointConfig.urlParser(context.endpointV2.url) : endpointConfig.endpoint;
		if (!endpoint) throw new Error("No valid endpoint provider available.");
		const request$1 = await serializer(args.input, {
			...options,
			endpoint
		});
		return next({
			...args,
			request: request$1
		});
	};
	const deserializerMiddlewareOption$1 = {
		name: "deserializerMiddleware",
		step: "deserialize",
		tags: ["DESERIALIZER"],
		override: true
	};
	const serializerMiddlewareOption$2 = {
		name: "serializerMiddleware",
		step: "serialize",
		tags: ["SERIALIZER"],
		override: true
	};
	function getSerdePlugin(config, serializer, deserializer) {
		return { applyToStack: (commandStack) => {
			commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption$1);
			commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption$2);
		} };
	}
	exports.deserializerMiddleware = deserializerMiddleware;
	exports.deserializerMiddlewareOption = deserializerMiddlewareOption$1;
	exports.getSerdePlugin = getSerdePlugin;
	exports.serializerMiddleware = serializerMiddleware;
	exports.serializerMiddlewareOption = serializerMiddlewareOption$2;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/getHttpAuthSchemePlugin.js
var import_dist_cjs$150, httpAuthSchemeMiddlewareOptions, getHttpAuthSchemePlugin;
var init_getHttpAuthSchemePlugin = __esmMin((() => {
	import_dist_cjs$150 = require_dist_cjs$47();
	init_httpAuthSchemeMiddleware();
	httpAuthSchemeMiddlewareOptions = {
		step: "serialize",
		tags: ["HTTP_AUTH_SCHEME"],
		name: "httpAuthSchemeMiddleware",
		override: true,
		relation: "before",
		toMiddleware: import_dist_cjs$150.serializerMiddlewareOption.name
	};
	getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider }) => ({ applyToStack: (clientStack) => {
		clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
			httpAuthSchemeParametersProvider,
			identityProviderConfigProvider
		}), httpAuthSchemeMiddlewareOptions);
	} });
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-auth-scheme/index.js
var init_middleware_http_auth_scheme = __esmMin((() => {
	init_httpAuthSchemeMiddleware();
	init_getHttpAuthSchemeEndpointRuleSetPlugin();
	init_getHttpAuthSchemePlugin();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-signing/httpSigningMiddleware.js
var import_dist_cjs$148, import_dist_cjs$149, defaultErrorHandler, defaultSuccessHandler, httpSigningMiddleware;
var init_httpSigningMiddleware = __esmMin((() => {
	import_dist_cjs$148 = require_dist_cjs$52();
	import_dist_cjs$149 = require_dist_cjs$48();
	defaultErrorHandler = (signingProperties) => (error$2) => {
		throw error$2;
	};
	defaultSuccessHandler = (httpResponse, signingProperties) => {};
	httpSigningMiddleware = (config) => (next, context) => async (args) => {
		if (!import_dist_cjs$148.HttpRequest.isInstance(args.request)) return next(args);
		const scheme = (0, import_dist_cjs$149.getSmithyContext)(context).selectedHttpAuthScheme;
		if (!scheme) throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
		const { httpAuthOption: { signingProperties = {} }, identity, signer } = scheme;
		const output = await next({
			...args,
			request: await signer.sign(args.request, identity, signingProperties)
		}).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
		(signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
		return output;
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-signing/getHttpSigningMiddleware.js
var httpSigningMiddlewareOptions, getHttpSigningPlugin;
var init_getHttpSigningMiddleware = __esmMin((() => {
	init_httpSigningMiddleware();
	httpSigningMiddlewareOptions = {
		step: "finalizeRequest",
		tags: ["HTTP_SIGNING"],
		name: "httpSigningMiddleware",
		aliases: [
			"apiKeyMiddleware",
			"tokenMiddleware",
			"awsAuthMiddleware"
		],
		override: true,
		relation: "after",
		toMiddleware: "retryMiddleware"
	};
	getHttpSigningPlugin = (config) => ({ applyToStack: (clientStack) => {
		clientStack.addRelativeTo(httpSigningMiddleware(config), httpSigningMiddlewareOptions);
	} });
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/middleware-http-signing/index.js
var init_middleware_http_signing = __esmMin((() => {
	init_httpSigningMiddleware();
	init_getHttpSigningMiddleware();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/normalizeProvider.js
var normalizeProvider$3;
var init_normalizeProvider = __esmMin((() => {
	normalizeProvider$3 = (input) => {
		if (typeof input === "function") return input;
		const promisified = Promise.resolve(input);
		return () => promisified;
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/pagination/createPaginator.js
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
	return async function* paginateOperation(config, input, ...additionalArguments) {
		const _input = input;
		let token = config.startingToken ?? _input[inputTokenName];
		let hasNext = true;
		let page;
		while (hasNext) {
			_input[inputTokenName] = token;
			if (pageSizeTokenName) _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
			if (config.client instanceof ClientCtor) page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
			else throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
			yield page;
			const prevToken = token;
			token = get(page, outputTokenName);
			hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
		}
		return void 0;
	};
}
var makePagedClientRequest, get;
var init_createPaginator = __esmMin((() => {
	makePagedClientRequest = async (CommandCtor, client$6, input, withCommand = (_) => _, ...args) => {
		let command = new CommandCtor(input);
		command = withCommand(command) ?? command;
		return await client$6.send(command, ...args);
	};
	get = (fromObject, path$6) => {
		let cursor$1 = fromObject;
		const pathComponents = path$6.split(".");
		for (const step of pathComponents) {
			if (!cursor$1 || typeof cursor$1 !== "object") return;
			cursor$1 = cursor$1[step];
		}
		return cursor$1;
	};
}));

//#endregion
//#region node_modules/@smithy/is-array-buffer/dist-cjs/index.js
var require_dist_cjs$46 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const isArrayBuffer$2 = (arg) => typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
	exports.isArrayBuffer = isArrayBuffer$2;
}));

//#endregion
//#region node_modules/@smithy/util-buffer-from/dist-cjs/index.js
var require_dist_cjs$45 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var isArrayBuffer$1 = require_dist_cjs$46();
	var buffer$2 = __require("buffer");
	const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
		if (!isArrayBuffer$1.isArrayBuffer(input)) throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
		return buffer$2.Buffer.from(input, offset, length);
	};
	const fromString = (input, encoding) => {
		if (typeof input !== "string") throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
		return encoding ? buffer$2.Buffer.from(input, encoding) : buffer$2.Buffer.from(input);
	};
	exports.fromArrayBuffer = fromArrayBuffer;
	exports.fromString = fromString;
}));

//#endregion
//#region node_modules/@smithy/util-base64/dist-cjs/fromBase64.js
var require_fromBase64 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromBase64 = void 0;
	const util_buffer_from_1$2 = require_dist_cjs$45();
	const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
	const fromBase64$8 = (input) => {
		if (input.length * 3 % 4 !== 0) throw new TypeError(`Incorrect padding on base64 string.`);
		if (!BASE64_REGEX.exec(input)) throw new TypeError(`Invalid base64 string.`);
		const buffer$3 = (0, util_buffer_from_1$2.fromString)(input, "base64");
		return new Uint8Array(buffer$3.buffer, buffer$3.byteOffset, buffer$3.byteLength);
	};
	exports.fromBase64 = fromBase64$8;
}));

//#endregion
//#region node_modules/@smithy/util-utf8/dist-cjs/index.js
var require_dist_cjs$44 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilBufferFrom$1 = require_dist_cjs$45();
	const fromUtf8$6 = (input) => {
		const buf = utilBufferFrom$1.fromString(input, "utf8");
		return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
	};
	const toUint8Array$1 = (data$1) => {
		if (typeof data$1 === "string") return fromUtf8$6(data$1);
		if (ArrayBuffer.isView(data$1)) return new Uint8Array(data$1.buffer, data$1.byteOffset, data$1.byteLength / Uint8Array.BYTES_PER_ELEMENT);
		return new Uint8Array(data$1);
	};
	const toUtf8$9 = (input) => {
		if (typeof input === "string") return input;
		if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
		return utilBufferFrom$1.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
	};
	exports.fromUtf8 = fromUtf8$6;
	exports.toUint8Array = toUint8Array$1;
	exports.toUtf8 = toUtf8$9;
}));

//#endregion
//#region node_modules/@smithy/util-base64/dist-cjs/toBase64.js
var require_toBase64 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.toBase64 = void 0;
	const util_buffer_from_1$1 = require_dist_cjs$45();
	const util_utf8_1$3 = require_dist_cjs$44();
	const toBase64$8 = (_input) => {
		let input;
		if (typeof _input === "string") input = (0, util_utf8_1$3.fromUtf8)(_input);
		else input = _input;
		if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
		return (0, util_buffer_from_1$1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
	};
	exports.toBase64 = toBase64$8;
}));

//#endregion
//#region node_modules/@smithy/util-base64/dist-cjs/index.js
var require_dist_cjs$43 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var fromBase64$7 = require_fromBase64();
	var toBase64$7 = require_toBase64();
	Object.keys(fromBase64$7).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return fromBase64$7[k$5];
			}
		});
	});
	Object.keys(toBase64$7).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return toBase64$7[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.js
var require_ChecksumStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ChecksumStream = void 0;
	const util_base64_1$4 = require_dist_cjs$43();
	const stream_1$5 = __require("stream");
	var ChecksumStream$2 = class extends stream_1$5.Duplex {
		expectedChecksum;
		checksumSourceLocation;
		checksum;
		source;
		base64Encoder;
		constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) {
			super();
			if (typeof source.pipe === "function") this.source = source;
			else throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
			this.base64Encoder = base64Encoder ?? util_base64_1$4.toBase64;
			this.expectedChecksum = expectedChecksum;
			this.checksum = checksum;
			this.checksumSourceLocation = checksumSourceLocation;
			this.source.pipe(this);
		}
		_read(size) {}
		_write(chunk, encoding, callback) {
			try {
				this.checksum.update(chunk);
				this.push(chunk);
			} catch (e$5) {
				return callback(e$5);
			}
			return callback();
		}
		async _final(callback) {
			try {
				const digest = await this.checksum.digest();
				const received = this.base64Encoder(digest);
				if (this.expectedChecksum !== received) return callback(/* @__PURE__ */ new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}" in response header "${this.checksumSourceLocation}".`));
			} catch (e$5) {
				return callback(e$5);
			}
			this.push(null);
			return callback();
		}
	};
	exports.ChecksumStream = ChecksumStream$2;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/stream-type-check.js
var require_stream_type_check = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isBlob = exports.isReadableStream = void 0;
	const isReadableStream = (stream$3) => typeof ReadableStream === "function" && (stream$3?.constructor?.name === ReadableStream.name || stream$3 instanceof ReadableStream);
	exports.isReadableStream = isReadableStream;
	const isBlob = (blob) => {
		return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
	};
	exports.isBlob = isBlob;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/checksum/ChecksumStream.browser.js
var require_ChecksumStream_browser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ChecksumStream = void 0;
	const ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function() {};
	var ChecksumStream$1 = class extends ReadableStreamRef {};
	exports.ChecksumStream = ChecksumStream$1;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.browser.js
var require_createChecksumStream_browser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createChecksumStream = void 0;
	const util_base64_1$3 = require_dist_cjs$43();
	const stream_type_check_1$5 = require_stream_type_check();
	const ChecksumStream_browser_1 = require_ChecksumStream_browser();
	const createChecksumStream$2 = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder }) => {
		if (!(0, stream_type_check_1$5.isReadableStream)(source)) throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
		const encoder$2 = base64Encoder ?? util_base64_1$3.toBase64;
		if (typeof TransformStream !== "function") throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
		const transform = new TransformStream({
			start() {},
			async transform(chunk, controller) {
				checksum.update(chunk);
				controller.enqueue(chunk);
			},
			async flush(controller) {
				const received = encoder$2(await checksum.digest());
				if (expectedChecksum !== received) {
					const error$2 = /* @__PURE__ */ new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}" in response header "${checksumSourceLocation}".`);
					controller.error(error$2);
				} else controller.terminate();
			}
		});
		source.pipeThrough(transform);
		const readable = transform.readable;
		Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
		return readable;
	};
	exports.createChecksumStream = createChecksumStream$2;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/checksum/createChecksumStream.js
var require_createChecksumStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createChecksumStream = createChecksumStream$1;
	const stream_type_check_1$4 = require_stream_type_check();
	const ChecksumStream_1 = require_ChecksumStream();
	const createChecksumStream_browser_1 = require_createChecksumStream_browser();
	function createChecksumStream$1(init) {
		if (typeof ReadableStream === "function" && (0, stream_type_check_1$4.isReadableStream)(init.source)) return (0, createChecksumStream_browser_1.createChecksumStream)(init);
		return new ChecksumStream_1.ChecksumStream(init);
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/ByteArrayCollector.js
var require_ByteArrayCollector = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ByteArrayCollector = void 0;
	var ByteArrayCollector = class {
		allocByteArray;
		byteLength = 0;
		byteArrays = [];
		constructor(allocByteArray) {
			this.allocByteArray = allocByteArray;
		}
		push(byteArray) {
			this.byteArrays.push(byteArray);
			this.byteLength += byteArray.byteLength;
		}
		flush() {
			if (this.byteArrays.length === 1) {
				const bytes = this.byteArrays[0];
				this.reset();
				return bytes;
			}
			const aggregation = this.allocByteArray(this.byteLength);
			let cursor$1 = 0;
			for (let i$5 = 0; i$5 < this.byteArrays.length; ++i$5) {
				const bytes = this.byteArrays[i$5];
				aggregation.set(bytes, cursor$1);
				cursor$1 += bytes.byteLength;
			}
			this.reset();
			return aggregation;
		}
		reset() {
			this.byteArrays = [];
			this.byteLength = 0;
		}
	};
	exports.ByteArrayCollector = ByteArrayCollector;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/createBufferedReadableStream.js
var require_createBufferedReadableStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createBufferedReadable = void 0;
	exports.createBufferedReadableStream = createBufferedReadableStream;
	exports.merge = merge;
	exports.flush = flush;
	exports.sizeOf = sizeOf;
	exports.modeOf = modeOf;
	const ByteArrayCollector_1$1 = require_ByteArrayCollector();
	function createBufferedReadableStream(upstream, size, logger$1) {
		const reader = upstream.getReader();
		let streamBufferingLoggedWarning = false;
		let bytesSeen = 0;
		const buffers = ["", new ByteArrayCollector_1$1.ByteArrayCollector((size$1) => new Uint8Array(size$1))];
		let mode = -1;
		const pull = async (controller) => {
			const { value, done } = await reader.read();
			const chunk = value;
			if (done) {
				if (mode !== -1) {
					const remainder = flush(buffers, mode);
					if (sizeOf(remainder) > 0) controller.enqueue(remainder);
				}
				controller.close();
			} else {
				const chunkMode = modeOf(chunk, false);
				if (mode !== chunkMode) {
					if (mode >= 0) controller.enqueue(flush(buffers, mode));
					mode = chunkMode;
				}
				if (mode === -1) {
					controller.enqueue(chunk);
					return;
				}
				const chunkSize = sizeOf(chunk);
				bytesSeen += chunkSize;
				const bufferSize = sizeOf(buffers[mode]);
				if (chunkSize >= size && bufferSize === 0) controller.enqueue(chunk);
				else {
					const newSize = merge(buffers, mode, chunk);
					if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
						streamBufferingLoggedWarning = true;
						logger$1?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
					}
					if (newSize >= size) controller.enqueue(flush(buffers, mode));
					else await pull(controller);
				}
			}
		};
		return new ReadableStream({ pull });
	}
	exports.createBufferedReadable = createBufferedReadableStream;
	function merge(buffers, mode, chunk) {
		switch (mode) {
			case 0:
				buffers[0] += chunk;
				return sizeOf(buffers[0]);
			case 1:
			case 2:
				buffers[mode].push(chunk);
				return sizeOf(buffers[mode]);
		}
	}
	function flush(buffers, mode) {
		switch (mode) {
			case 0:
				const s$5 = buffers[0];
				buffers[0] = "";
				return s$5;
			case 1:
			case 2: return buffers[mode].flush();
		}
		throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
	}
	function sizeOf(chunk) {
		return chunk?.byteLength ?? chunk?.length ?? 0;
	}
	function modeOf(chunk, allowBuffer = true) {
		if (allowBuffer && typeof Buffer !== "undefined" && chunk instanceof Buffer) return 2;
		if (chunk instanceof Uint8Array) return 1;
		if (typeof chunk === "string") return 0;
		return -1;
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/createBufferedReadable.js
var require_createBufferedReadable = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createBufferedReadable = createBufferedReadable$1;
	const node_stream_1 = __require("node:stream");
	const ByteArrayCollector_1 = require_ByteArrayCollector();
	const createBufferedReadableStream_1 = require_createBufferedReadableStream();
	const stream_type_check_1$3 = require_stream_type_check();
	function createBufferedReadable$1(upstream, size, logger$1) {
		if ((0, stream_type_check_1$3.isReadableStream)(upstream)) return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger$1);
		const downstream = new node_stream_1.Readable({ read() {} });
		let streamBufferingLoggedWarning = false;
		let bytesSeen = 0;
		const buffers = [
			"",
			new ByteArrayCollector_1.ByteArrayCollector((size$1) => new Uint8Array(size$1)),
			new ByteArrayCollector_1.ByteArrayCollector((size$1) => Buffer.from(new Uint8Array(size$1)))
		];
		let mode = -1;
		upstream.on("data", (chunk) => {
			const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk, true);
			if (mode !== chunkMode) {
				if (mode >= 0) downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
				mode = chunkMode;
			}
			if (mode === -1) {
				downstream.push(chunk);
				return;
			}
			const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk);
			bytesSeen += chunkSize;
			const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
			if (chunkSize >= size && bufferSize === 0) downstream.push(chunk);
			else {
				const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk);
				if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
					streamBufferingLoggedWarning = true;
					logger$1?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
				}
				if (newSize >= size) downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
			}
		});
		upstream.on("end", () => {
			if (mode !== -1) {
				const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
				if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) downstream.push(remainder);
			}
			downstream.push(null);
		});
		return downstream;
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/getAwsChunkedEncodingStream.js
var require_getAwsChunkedEncodingStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getAwsChunkedEncodingStream = void 0;
	const stream_1$4 = __require("stream");
	const getAwsChunkedEncodingStream$1 = (readableStream, options) => {
		const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
		const checksumRequired = base64Encoder !== void 0 && checksumAlgorithmFn !== void 0 && checksumLocationName !== void 0 && streamHasher !== void 0;
		const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : void 0;
		const awsChunkedEncodingStream = new stream_1$4.Readable({ read: () => {} });
		readableStream.on("data", (data$1) => {
			const length = bodyLengthChecker(data$1) || 0;
			awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
			awsChunkedEncodingStream.push(data$1);
			awsChunkedEncodingStream.push("\r\n");
		});
		readableStream.on("end", async () => {
			awsChunkedEncodingStream.push(`0\r\n`);
			if (checksumRequired) {
				const checksum = base64Encoder(await digest);
				awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
				awsChunkedEncodingStream.push(`\r\n`);
			}
			awsChunkedEncodingStream.push(null);
		});
		return awsChunkedEncodingStream;
	};
	exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream$1;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/headStream.browser.js
var require_headStream_browser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.headStream = headStream$2;
	async function headStream$2(stream$3, bytes) {
		let byteLengthCounter = 0;
		const chunks = [];
		const reader = stream$3.getReader();
		let isDone = false;
		while (!isDone) {
			const { done, value } = await reader.read();
			if (value) {
				chunks.push(value);
				byteLengthCounter += value?.byteLength ?? 0;
			}
			if (byteLengthCounter >= bytes) break;
			isDone = done;
		}
		reader.releaseLock();
		const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
		let offset = 0;
		for (const chunk of chunks) {
			if (chunk.byteLength > collected.byteLength - offset) {
				collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
				break;
			} else collected.set(chunk, offset);
			offset += chunk.length;
		}
		return collected;
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/headStream.js
var require_headStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.headStream = void 0;
	const stream_1$3 = __require("stream");
	const headStream_browser_1 = require_headStream_browser();
	const stream_type_check_1$2 = require_stream_type_check();
	const headStream$1 = (stream$3, bytes) => {
		if ((0, stream_type_check_1$2.isReadableStream)(stream$3)) return (0, headStream_browser_1.headStream)(stream$3, bytes);
		return new Promise((resolve, reject) => {
			const collector = new Collector$1();
			collector.limit = bytes;
			stream$3.pipe(collector);
			stream$3.on("error", (err) => {
				collector.end();
				reject(err);
			});
			collector.on("error", reject);
			collector.on("finish", function() {
				resolve(new Uint8Array(Buffer.concat(this.buffers)));
			});
		});
	};
	exports.headStream = headStream$1;
	var Collector$1 = class extends stream_1$3.Writable {
		buffers = [];
		limit = Infinity;
		bytesBuffered = 0;
		_write(chunk, encoding, callback) {
			this.buffers.push(chunk);
			this.bytesBuffered += chunk.byteLength ?? 0;
			if (this.bytesBuffered >= this.limit) {
				const excess = this.bytesBuffered - this.limit;
				const tailBuffer = this.buffers[this.buffers.length - 1];
				this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
				this.emit("finish");
			}
			callback();
		}
	};
}));

//#endregion
//#region node_modules/@smithy/util-uri-escape/dist-cjs/index.js
var require_dist_cjs$42 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
	const hexEncode = (c$5) => `%${c$5.charCodeAt(0).toString(16).toUpperCase()}`;
	const escapeUriPath = (uri) => uri.split("/").map(escapeUri).join("/");
	exports.escapeUri = escapeUri;
	exports.escapeUriPath = escapeUriPath;
}));

//#endregion
//#region node_modules/@smithy/querystring-builder/dist-cjs/index.js
var require_dist_cjs$41 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilUriEscape$1 = require_dist_cjs$42();
	function buildQueryString(query) {
		const parts = [];
		for (let key of Object.keys(query).sort()) {
			const value = query[key];
			key = utilUriEscape$1.escapeUri(key);
			if (Array.isArray(value)) for (let i$5 = 0, iLen = value.length; i$5 < iLen; i$5++) parts.push(`${key}=${utilUriEscape$1.escapeUri(value[i$5])}`);
			else {
				let qsEntry = key;
				if (value || typeof value === "string") qsEntry += `=${utilUriEscape$1.escapeUri(value)}`;
				parts.push(qsEntry);
			}
		}
		return parts.join("&");
	}
	exports.buildQueryString = buildQueryString;
}));

//#endregion
//#region node_modules/@smithy/node-http-handler/dist-cjs/index.js
var require_dist_cjs$40 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var protocolHttp$8 = require_dist_cjs$52();
	var querystringBuilder$1 = require_dist_cjs$41();
	var http$1 = __require("http");
	var https = __require("https");
	var stream = __require("stream");
	var http2 = __require("http2");
	const NODEJS_TIMEOUT_ERROR_CODES$1 = [
		"ECONNRESET",
		"EPIPE",
		"ETIMEDOUT"
	];
	const getTransformedHeaders = (headers) => {
		const transformedHeaders = {};
		for (const name of Object.keys(headers)) {
			const headerValues = headers[name];
			transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
		}
		return transformedHeaders;
	};
	const timing = {
		setTimeout: (cb, ms) => setTimeout(cb, ms),
		clearTimeout: (timeoutId) => clearTimeout(timeoutId)
	};
	const DEFER_EVENT_LISTENER_TIME$2 = 1e3;
	const setConnectionTimeout = (request$1, reject, timeoutInMs = 0) => {
		if (!timeoutInMs) return -1;
		const registerTimeout = (offset) => {
			const timeoutId = timing.setTimeout(() => {
				request$1.destroy();
				reject(Object.assign(/* @__PURE__ */ new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), { name: "TimeoutError" }));
			}, timeoutInMs - offset);
			const doWithSocket = (socket) => {
				if (socket?.connecting) socket.on("connect", () => {
					timing.clearTimeout(timeoutId);
				});
				else timing.clearTimeout(timeoutId);
			};
			if (request$1.socket) doWithSocket(request$1.socket);
			else request$1.on("socket", doWithSocket);
		};
		if (timeoutInMs < 2e3) {
			registerTimeout(0);
			return 0;
		}
		return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
	};
	const setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger$1) => {
		if (timeoutInMs) return timing.setTimeout(() => {
			let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? "ERROR" : "WARN"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;
			if (throwOnRequestTimeout) {
				const error$2 = Object.assign(new Error(msg), {
					name: "TimeoutError",
					code: "ETIMEDOUT"
				});
				req.destroy(error$2);
				reject(error$2);
			} else {
				msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;
				logger$1?.warn?.(msg);
			}
		}, timeoutInMs);
		return -1;
	};
	const DEFER_EVENT_LISTENER_TIME$1 = 3e3;
	const setSocketKeepAlive = (request$1, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
		if (keepAlive !== true) return -1;
		const registerListener = () => {
			if (request$1.socket) request$1.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
			else request$1.on("socket", (socket) => {
				socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
			});
		};
		if (deferTimeMs === 0) {
			registerListener();
			return 0;
		}
		return timing.setTimeout(registerListener, deferTimeMs);
	};
	const DEFER_EVENT_LISTENER_TIME = 3e3;
	const setSocketTimeout = (request$1, reject, timeoutInMs = 0) => {
		const registerTimeout = (offset) => {
			const timeout = timeoutInMs - offset;
			const onTimeout$1 = () => {
				request$1.destroy();
				reject(Object.assign(/* @__PURE__ */ new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" }));
			};
			if (request$1.socket) {
				request$1.socket.setTimeout(timeout, onTimeout$1);
				request$1.on("close", () => request$1.socket?.removeListener("timeout", onTimeout$1));
			} else request$1.setTimeout(timeout, onTimeout$1);
		};
		if (0 < timeoutInMs && timeoutInMs < 6e3) {
			registerTimeout(0);
			return 0;
		}
		return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
	};
	const MIN_WAIT_TIME = 6e3;
	async function writeRequestBody(httpRequest$1, request$1, maxContinueTimeoutMs = MIN_WAIT_TIME, externalAgent = false) {
		const headers = request$1.headers ?? {};
		const expect = headers.Expect || headers.expect;
		let timeoutId = -1;
		let sendBody = true;
		if (!externalAgent && expect === "100-continue") sendBody = await Promise.race([new Promise((resolve) => {
			timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
		}), new Promise((resolve) => {
			httpRequest$1.on("continue", () => {
				timing.clearTimeout(timeoutId);
				resolve(true);
			});
			httpRequest$1.on("response", () => {
				timing.clearTimeout(timeoutId);
				resolve(false);
			});
			httpRequest$1.on("error", () => {
				timing.clearTimeout(timeoutId);
				resolve(false);
			});
		})]);
		if (sendBody) writeBody(httpRequest$1, request$1.body);
	}
	function writeBody(httpRequest$1, body) {
		if (body instanceof stream.Readable) {
			body.pipe(httpRequest$1);
			return;
		}
		if (body) {
			if (Buffer.isBuffer(body) || typeof body === "string") {
				httpRequest$1.end(body);
				return;
			}
			const uint8 = body;
			if (typeof uint8 === "object" && uint8.buffer && typeof uint8.byteOffset === "number" && typeof uint8.byteLength === "number") {
				httpRequest$1.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
				return;
			}
			httpRequest$1.end(Buffer.from(body));
			return;
		}
		httpRequest$1.end();
	}
	const DEFAULT_REQUEST_TIMEOUT = 0;
	var NodeHttpHandler = class NodeHttpHandler {
		config;
		configProvider;
		socketWarningTimestamp = 0;
		externalAgent = false;
		metadata = { handlerProtocol: "http/1.1" };
		static create(instanceOrOptions) {
			if (typeof instanceOrOptions?.handle === "function") return instanceOrOptions;
			return new NodeHttpHandler(instanceOrOptions);
		}
		static checkSocketUsage(agent, socketWarningTimestamp, logger$1 = console) {
			const { sockets, requests, maxSockets } = agent;
			if (typeof maxSockets !== "number" || maxSockets === Infinity) return socketWarningTimestamp;
			if (Date.now() - 15e3 < socketWarningTimestamp) return socketWarningTimestamp;
			if (sockets && requests) for (const origin in sockets) {
				const socketsInUse = sockets[origin]?.length ?? 0;
				const requestsEnqueued = requests[origin]?.length ?? 0;
				if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
					logger$1?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
					return Date.now();
				}
			}
			return socketWarningTimestamp;
		}
		constructor(options) {
			this.configProvider = new Promise((resolve, reject) => {
				if (typeof options === "function") options().then((_options) => {
					resolve(this.resolveDefaultConfig(_options));
				}).catch(reject);
				else resolve(this.resolveDefaultConfig(options));
			});
		}
		resolveDefaultConfig(options) {
			const { requestTimeout: requestTimeout$1, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout } = options || {};
			const keepAlive = true;
			const maxSockets = 50;
			return {
				connectionTimeout,
				requestTimeout: requestTimeout$1,
				socketTimeout,
				socketAcquisitionWarningTimeout,
				throwOnRequestTimeout,
				httpAgent: (() => {
					if (httpAgent instanceof http$1.Agent || typeof httpAgent?.destroy === "function") {
						this.externalAgent = true;
						return httpAgent;
					}
					return new http$1.Agent({
						keepAlive,
						maxSockets,
						...httpAgent
					});
				})(),
				httpsAgent: (() => {
					if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
						this.externalAgent = true;
						return httpsAgent;
					}
					return new https.Agent({
						keepAlive,
						maxSockets,
						...httpsAgent
					});
				})(),
				logger: console
			};
		}
		destroy() {
			this.config?.httpAgent?.destroy();
			this.config?.httpsAgent?.destroy();
		}
		async handle(request$1, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
			if (!this.config) this.config = await this.configProvider;
			return new Promise((_resolve, _reject) => {
				const config = this.config;
				let writeRequestBodyPromise = void 0;
				const timeouts = [];
				const resolve = async (arg) => {
					await writeRequestBodyPromise;
					timeouts.forEach(timing.clearTimeout);
					_resolve(arg);
				};
				const reject = async (arg) => {
					await writeRequestBodyPromise;
					timeouts.forEach(timing.clearTimeout);
					_reject(arg);
				};
				if (abortSignal?.aborted) {
					const abortError = /* @__PURE__ */ new Error("Request aborted");
					abortError.name = "AbortError";
					reject(abortError);
					return;
				}
				const isSSL = request$1.protocol === "https:";
				const headers = request$1.headers ?? {};
				const expectContinue = (headers.Expect ?? headers.expect) === "100-continue";
				let agent = isSSL ? config.httpsAgent : config.httpAgent;
				if (expectContinue && !this.externalAgent) agent = new (isSSL ? https.Agent : http$1.Agent)({
					keepAlive: false,
					maxSockets: Infinity
				});
				timeouts.push(timing.setTimeout(() => {
					this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, config.logger);
				}, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2e3) + (config.connectionTimeout ?? 1e3)));
				const queryString = querystringBuilder$1.buildQueryString(request$1.query || {});
				let auth = void 0;
				if (request$1.username != null || request$1.password != null) auth = `${request$1.username ?? ""}:${request$1.password ?? ""}`;
				let path$6 = request$1.path;
				if (queryString) path$6 += `?${queryString}`;
				if (request$1.fragment) path$6 += `#${request$1.fragment}`;
				let hostname = request$1.hostname ?? "";
				if (hostname[0] === "[" && hostname.endsWith("]")) hostname = request$1.hostname.slice(1, -1);
				else hostname = request$1.hostname;
				const nodeHttpsOptions = {
					headers: request$1.headers,
					host: hostname,
					method: request$1.method,
					path: path$6,
					port: request$1.port,
					agent,
					auth
				};
				const req = (isSSL ? https.request : http$1.request)(nodeHttpsOptions, (res) => {
					resolve({ response: new protocolHttp$8.HttpResponse({
						statusCode: res.statusCode || -1,
						reason: res.statusMessage,
						headers: getTransformedHeaders(res.headers),
						body: res
					}) });
				});
				req.on("error", (err) => {
					if (NODEJS_TIMEOUT_ERROR_CODES$1.includes(err.code)) reject(Object.assign(err, { name: "TimeoutError" }));
					else reject(err);
				});
				if (abortSignal) {
					const onAbort = () => {
						req.destroy();
						const abortError = /* @__PURE__ */ new Error("Request aborted");
						abortError.name = "AbortError";
						reject(abortError);
					};
					if (typeof abortSignal.addEventListener === "function") {
						const signal = abortSignal;
						signal.addEventListener("abort", onAbort, { once: true });
						req.once("close", () => signal.removeEventListener("abort", onAbort));
					} else abortSignal.onabort = onAbort;
				}
				const effectiveRequestTimeout = requestTimeout$1 ?? config.requestTimeout;
				timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));
				timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));
				timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));
				const httpAgent = nodeHttpsOptions.agent;
				if (typeof httpAgent === "object" && "keepAlive" in httpAgent) timeouts.push(setSocketKeepAlive(req, {
					keepAlive: httpAgent.keepAlive,
					keepAliveMsecs: httpAgent.keepAliveMsecs
				}));
				writeRequestBodyPromise = writeRequestBody(req, request$1, effectiveRequestTimeout, this.externalAgent).catch((e$5) => {
					timeouts.forEach(timing.clearTimeout);
					return _reject(e$5);
				});
			});
		}
		updateHttpClientConfig(key, value) {
			this.config = void 0;
			this.configProvider = this.configProvider.then((config) => {
				return {
					...config,
					[key]: value
				};
			});
		}
		httpHandlerConfigs() {
			return this.config ?? {};
		}
	};
	var NodeHttp2ConnectionPool = class {
		sessions = [];
		constructor(sessions) {
			this.sessions = sessions ?? [];
		}
		poll() {
			if (this.sessions.length > 0) return this.sessions.shift();
		}
		offerLast(session) {
			this.sessions.push(session);
		}
		contains(session) {
			return this.sessions.includes(session);
		}
		remove(session) {
			this.sessions = this.sessions.filter((s$5) => s$5 !== session);
		}
		[Symbol.iterator]() {
			return this.sessions[Symbol.iterator]();
		}
		destroy(connection) {
			for (const session of this.sessions) if (session === connection) {
				if (!session.destroyed) session.destroy();
			}
		}
	};
	var NodeHttp2ConnectionManager = class {
		constructor(config) {
			this.config = config;
			if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) throw new RangeError("maxConcurrency must be greater than zero.");
		}
		config;
		sessionCache = /* @__PURE__ */ new Map();
		lease(requestContext, connectionConfiguration) {
			const url$1 = this.getUrlString(requestContext);
			const existingPool = this.sessionCache.get(url$1);
			if (existingPool) {
				const existingSession = existingPool.poll();
				if (existingSession && !this.config.disableConcurrency) return existingSession;
			}
			const session = http2.connect(url$1);
			if (this.config.maxConcurrency) session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
				if (err) throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
			});
			session.unref();
			const destroySessionCb = () => {
				session.destroy();
				this.deleteSession(url$1, session);
			};
			session.on("goaway", destroySessionCb);
			session.on("error", destroySessionCb);
			session.on("frameError", destroySessionCb);
			session.on("close", () => this.deleteSession(url$1, session));
			if (connectionConfiguration.requestTimeout) session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
			const connectionPool = this.sessionCache.get(url$1) || new NodeHttp2ConnectionPool();
			connectionPool.offerLast(session);
			this.sessionCache.set(url$1, connectionPool);
			return session;
		}
		deleteSession(authority, session) {
			const existingConnectionPool = this.sessionCache.get(authority);
			if (!existingConnectionPool) return;
			if (!existingConnectionPool.contains(session)) return;
			existingConnectionPool.remove(session);
			this.sessionCache.set(authority, existingConnectionPool);
		}
		release(requestContext, session) {
			const cacheKey = this.getUrlString(requestContext);
			this.sessionCache.get(cacheKey)?.offerLast(session);
		}
		destroy() {
			for (const [key, connectionPool] of this.sessionCache) {
				for (const session of connectionPool) {
					if (!session.destroyed) session.destroy();
					connectionPool.remove(session);
				}
				this.sessionCache.delete(key);
			}
		}
		setMaxConcurrentStreams(maxConcurrentStreams) {
			if (maxConcurrentStreams && maxConcurrentStreams <= 0) throw new RangeError("maxConcurrentStreams must be greater than zero.");
			this.config.maxConcurrency = maxConcurrentStreams;
		}
		setDisableConcurrentStreams(disableConcurrentStreams) {
			this.config.disableConcurrency = disableConcurrentStreams;
		}
		getUrlString(request$1) {
			return request$1.destination.toString();
		}
	};
	var NodeHttp2Handler = class NodeHttp2Handler {
		config;
		configProvider;
		metadata = { handlerProtocol: "h2" };
		connectionManager = new NodeHttp2ConnectionManager({});
		static create(instanceOrOptions) {
			if (typeof instanceOrOptions?.handle === "function") return instanceOrOptions;
			return new NodeHttp2Handler(instanceOrOptions);
		}
		constructor(options) {
			this.configProvider = new Promise((resolve, reject) => {
				if (typeof options === "function") options().then((opts) => {
					resolve(opts || {});
				}).catch(reject);
				else resolve(options || {});
			});
		}
		destroy() {
			this.connectionManager.destroy();
		}
		async handle(request$1, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
			if (!this.config) {
				this.config = await this.configProvider;
				this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
				if (this.config.maxConcurrentStreams) this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
			}
			const { requestTimeout: configRequestTimeout, disableConcurrentStreams } = this.config;
			const effectiveRequestTimeout = requestTimeout$1 ?? configRequestTimeout;
			return new Promise((_resolve, _reject) => {
				let fulfilled = false;
				let writeRequestBodyPromise = void 0;
				const resolve = async (arg) => {
					await writeRequestBodyPromise;
					_resolve(arg);
				};
				const reject = async (arg) => {
					await writeRequestBodyPromise;
					_reject(arg);
				};
				if (abortSignal?.aborted) {
					fulfilled = true;
					const abortError = /* @__PURE__ */ new Error("Request aborted");
					abortError.name = "AbortError";
					reject(abortError);
					return;
				}
				const { hostname, method, port, protocol, query } = request$1;
				let auth = "";
				if (request$1.username != null || request$1.password != null) auth = `${request$1.username ?? ""}:${request$1.password ?? ""}@`;
				const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
				const requestContext = { destination: new URL(authority) };
				const session = this.connectionManager.lease(requestContext, {
					requestTimeout: this.config?.sessionTimeout,
					disableConcurrentStreams: disableConcurrentStreams || false
				});
				const rejectWithDestroy = (err) => {
					if (disableConcurrentStreams) this.destroySession(session);
					fulfilled = true;
					reject(err);
				};
				const queryString = querystringBuilder$1.buildQueryString(query || {});
				let path$6 = request$1.path;
				if (queryString) path$6 += `?${queryString}`;
				if (request$1.fragment) path$6 += `#${request$1.fragment}`;
				const req = session.request({
					...request$1.headers,
					[http2.constants.HTTP2_HEADER_PATH]: path$6,
					[http2.constants.HTTP2_HEADER_METHOD]: method
				});
				session.ref();
				req.on("response", (headers) => {
					const httpResponse = new protocolHttp$8.HttpResponse({
						statusCode: headers[":status"] || -1,
						headers: getTransformedHeaders(headers),
						body: req
					});
					fulfilled = true;
					resolve({ response: httpResponse });
					if (disableConcurrentStreams) {
						session.close();
						this.connectionManager.deleteSession(authority, session);
					}
				});
				if (effectiveRequestTimeout) req.setTimeout(effectiveRequestTimeout, () => {
					req.close();
					const timeoutError = /* @__PURE__ */ new Error(`Stream timed out because of no activity for ${effectiveRequestTimeout} ms`);
					timeoutError.name = "TimeoutError";
					rejectWithDestroy(timeoutError);
				});
				if (abortSignal) {
					const onAbort = () => {
						req.close();
						const abortError = /* @__PURE__ */ new Error("Request aborted");
						abortError.name = "AbortError";
						rejectWithDestroy(abortError);
					};
					if (typeof abortSignal.addEventListener === "function") {
						const signal = abortSignal;
						signal.addEventListener("abort", onAbort, { once: true });
						req.once("close", () => signal.removeEventListener("abort", onAbort));
					} else abortSignal.onabort = onAbort;
				}
				req.on("frameError", (type, code, id) => {
					rejectWithDestroy(/* @__PURE__ */ new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
				});
				req.on("error", rejectWithDestroy);
				req.on("aborted", () => {
					rejectWithDestroy(/* @__PURE__ */ new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
				});
				req.on("close", () => {
					session.unref();
					if (disableConcurrentStreams) session.destroy();
					if (!fulfilled) rejectWithDestroy(/* @__PURE__ */ new Error("Unexpected error: http2 request did not get a response"));
				});
				writeRequestBodyPromise = writeRequestBody(req, request$1, effectiveRequestTimeout);
			});
		}
		updateHttpClientConfig(key, value) {
			this.config = void 0;
			this.configProvider = this.configProvider.then((config) => {
				return {
					...config,
					[key]: value
				};
			});
		}
		httpHandlerConfigs() {
			return this.config ?? {};
		}
		destroySession(session) {
			if (!session.destroyed) session.destroy();
		}
	};
	var Collector = class extends stream.Writable {
		bufferedBytes = [];
		_write(chunk, encoding, callback) {
			this.bufferedBytes.push(chunk);
			callback();
		}
	};
	const streamCollector$4 = (stream$3) => {
		if (isReadableStreamInstance(stream$3)) return collectReadableStream(stream$3);
		return new Promise((resolve, reject) => {
			const collector = new Collector();
			stream$3.pipe(collector);
			stream$3.on("error", (err) => {
				collector.end();
				reject(err);
			});
			collector.on("error", reject);
			collector.on("finish", function() {
				resolve(new Uint8Array(Buffer.concat(this.bufferedBytes)));
			});
		});
	};
	const isReadableStreamInstance = (stream$3) => typeof ReadableStream === "function" && stream$3 instanceof ReadableStream;
	async function collectReadableStream(stream$3) {
		const chunks = [];
		const reader = stream$3.getReader();
		let isDone = false;
		let length = 0;
		while (!isDone) {
			const { done, value } = await reader.read();
			if (value) {
				chunks.push(value);
				length += value.length;
			}
			isDone = done;
		}
		const collected = new Uint8Array(length);
		let offset = 0;
		for (const chunk of chunks) {
			collected.set(chunk, offset);
			offset += chunk.length;
		}
		return collected;
	}
	exports.DEFAULT_REQUEST_TIMEOUT = DEFAULT_REQUEST_TIMEOUT;
	exports.NodeHttp2Handler = NodeHttp2Handler;
	exports.NodeHttpHandler = NodeHttpHandler;
	exports.streamCollector = streamCollector$4;
}));

//#endregion
//#region node_modules/@smithy/fetch-http-handler/dist-cjs/index.js
var require_dist_cjs$39 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var protocolHttp$7 = require_dist_cjs$52();
	var querystringBuilder = require_dist_cjs$41();
	var utilBase64$1 = require_dist_cjs$43();
	function createRequest(url$1, requestOptions) {
		return new Request(url$1, requestOptions);
	}
	function requestTimeout(timeoutInMs = 0) {
		return new Promise((resolve, reject) => {
			if (timeoutInMs) setTimeout(() => {
				const timeoutError = /* @__PURE__ */ new Error(`Request did not complete within ${timeoutInMs} ms`);
				timeoutError.name = "TimeoutError";
				reject(timeoutError);
			}, timeoutInMs);
		});
	}
	const keepAliveSupport = { supported: void 0 };
	var FetchHttpHandler = class FetchHttpHandler {
		config;
		configProvider;
		static create(instanceOrOptions) {
			if (typeof instanceOrOptions?.handle === "function") return instanceOrOptions;
			return new FetchHttpHandler(instanceOrOptions);
		}
		constructor(options) {
			if (typeof options === "function") this.configProvider = options().then((opts) => opts || {});
			else {
				this.config = options ?? {};
				this.configProvider = Promise.resolve(this.config);
			}
			if (keepAliveSupport.supported === void 0) keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
		}
		destroy() {}
		async handle(request$1, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
			if (!this.config) this.config = await this.configProvider;
			const requestTimeoutInMs = requestTimeout$1 ?? this.config.requestTimeout;
			const keepAlive = this.config.keepAlive === true;
			const credentials = this.config.credentials;
			if (abortSignal?.aborted) {
				const abortError = /* @__PURE__ */ new Error("Request aborted");
				abortError.name = "AbortError";
				return Promise.reject(abortError);
			}
			let path$6 = request$1.path;
			const queryString = querystringBuilder.buildQueryString(request$1.query || {});
			if (queryString) path$6 += `?${queryString}`;
			if (request$1.fragment) path$6 += `#${request$1.fragment}`;
			let auth = "";
			if (request$1.username != null || request$1.password != null) auth = `${request$1.username ?? ""}:${request$1.password ?? ""}@`;
			const { port, method } = request$1;
			const url$1 = `${request$1.protocol}//${auth}${request$1.hostname}${port ? `:${port}` : ""}${path$6}`;
			const body = method === "GET" || method === "HEAD" ? void 0 : request$1.body;
			const requestOptions = {
				body,
				headers: new Headers(request$1.headers),
				method,
				credentials
			};
			if (this.config?.cache) requestOptions.cache = this.config.cache;
			if (body) requestOptions.duplex = "half";
			if (typeof AbortController !== "undefined") requestOptions.signal = abortSignal;
			if (keepAliveSupport.supported) requestOptions.keepalive = keepAlive;
			if (typeof this.config.requestInit === "function") Object.assign(requestOptions, this.config.requestInit(request$1));
			let removeSignalEventListener = () => {};
			const fetchRequest = createRequest(url$1, requestOptions);
			const raceOfPromises = [fetch(fetchRequest).then((response) => {
				const fetchHeaders = response.headers;
				const transformedHeaders = {};
				for (const pair of fetchHeaders.entries()) transformedHeaders[pair[0]] = pair[1];
				if (!(response.body != void 0)) return response.blob().then((body$1) => ({ response: new protocolHttp$7.HttpResponse({
					headers: transformedHeaders,
					reason: response.statusText,
					statusCode: response.status,
					body: body$1
				}) }));
				return { response: new protocolHttp$7.HttpResponse({
					headers: transformedHeaders,
					reason: response.statusText,
					statusCode: response.status,
					body: response.body
				}) };
			}), requestTimeout(requestTimeoutInMs)];
			if (abortSignal) raceOfPromises.push(new Promise((resolve, reject) => {
				const onAbort = () => {
					const abortError = /* @__PURE__ */ new Error("Request aborted");
					abortError.name = "AbortError";
					reject(abortError);
				};
				if (typeof abortSignal.addEventListener === "function") {
					const signal = abortSignal;
					signal.addEventListener("abort", onAbort, { once: true });
					removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
				} else abortSignal.onabort = onAbort;
			}));
			return Promise.race(raceOfPromises).finally(removeSignalEventListener);
		}
		updateHttpClientConfig(key, value) {
			this.config = void 0;
			this.configProvider = this.configProvider.then((config) => {
				config[key] = value;
				return config;
			});
		}
		httpHandlerConfigs() {
			return this.config ?? {};
		}
	};
	const streamCollector$3 = async (stream$3) => {
		if (typeof Blob === "function" && stream$3 instanceof Blob || stream$3.constructor?.name === "Blob") {
			if (Blob.prototype.arrayBuffer !== void 0) return new Uint8Array(await stream$3.arrayBuffer());
			return collectBlob(stream$3);
		}
		return collectStream(stream$3);
	};
	async function collectBlob(blob) {
		const base64 = await readToBase64(blob);
		const arrayBuffer = utilBase64$1.fromBase64(base64);
		return new Uint8Array(arrayBuffer);
	}
	async function collectStream(stream$3) {
		const chunks = [];
		const reader = stream$3.getReader();
		let isDone = false;
		let length = 0;
		while (!isDone) {
			const { done, value } = await reader.read();
			if (value) {
				chunks.push(value);
				length += value.length;
			}
			isDone = done;
		}
		const collected = new Uint8Array(length);
		let offset = 0;
		for (const chunk of chunks) {
			collected.set(chunk, offset);
			offset += chunk.length;
		}
		return collected;
	}
	function readToBase64(blob) {
		return new Promise((resolve, reject) => {
			const reader = new FileReader();
			reader.onloadend = () => {
				if (reader.readyState !== 2) return reject(/* @__PURE__ */ new Error("Reader aborted too early"));
				const result = reader.result ?? "";
				const commaIndex = result.indexOf(",");
				const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
				resolve(result.substring(dataOffset));
			};
			reader.onabort = () => reject(/* @__PURE__ */ new Error("Read aborted"));
			reader.onerror = () => reject(reader.error);
			reader.readAsDataURL(blob);
		});
	}
	exports.FetchHttpHandler = FetchHttpHandler;
	exports.keepAliveSupport = keepAliveSupport;
	exports.streamCollector = streamCollector$3;
}));

//#endregion
//#region node_modules/@smithy/util-hex-encoding/dist-cjs/index.js
var require_dist_cjs$38 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const SHORT_TO_HEX = {};
	const HEX_TO_SHORT = {};
	for (let i$5 = 0; i$5 < 256; i$5++) {
		let encodedByte = i$5.toString(16).toLowerCase();
		if (encodedByte.length === 1) encodedByte = `0${encodedByte}`;
		SHORT_TO_HEX[i$5] = encodedByte;
		HEX_TO_SHORT[encodedByte] = i$5;
	}
	function fromHex(encoded) {
		if (encoded.length % 2 !== 0) throw new Error("Hex encoded strings must have an even number length");
		const out = new Uint8Array(encoded.length / 2);
		for (let i$5 = 0; i$5 < encoded.length; i$5 += 2) {
			const encodedByte = encoded.slice(i$5, i$5 + 2).toLowerCase();
			if (encodedByte in HEX_TO_SHORT) out[i$5 / 2] = HEX_TO_SHORT[encodedByte];
			else throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
		}
		return out;
	}
	function toHex(bytes) {
		let out = "";
		for (let i$5 = 0; i$5 < bytes.byteLength; i$5++) out += SHORT_TO_HEX[bytes[i$5]];
		return out;
	}
	exports.fromHex = fromHex;
	exports.toHex = toHex;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.browser.js
var require_sdk_stream_mixin_browser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sdkStreamMixin = void 0;
	const fetch_http_handler_1 = require_dist_cjs$39();
	const util_base64_1$2 = require_dist_cjs$43();
	const util_hex_encoding_1 = require_dist_cjs$38();
	const util_utf8_1$2 = require_dist_cjs$44();
	const stream_type_check_1$1 = require_stream_type_check();
	const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1 = "The stream has already been transformed.";
	const sdkStreamMixin$3 = (stream$3) => {
		if (!isBlobInstance(stream$3) && !(0, stream_type_check_1$1.isReadableStream)(stream$3)) {
			const name = stream$3?.__proto__?.constructor?.name || stream$3;
			throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
		}
		let transformed = false;
		const transformToByteArray = async () => {
			if (transformed) throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1);
			transformed = true;
			return await (0, fetch_http_handler_1.streamCollector)(stream$3);
		};
		const blobToWebStream = (blob) => {
			if (typeof blob.stream !== "function") throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\nIf you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
			return blob.stream();
		};
		return Object.assign(stream$3, {
			transformToByteArray,
			transformToString: async (encoding) => {
				const buf = await transformToByteArray();
				if (encoding === "base64") return (0, util_base64_1$2.toBase64)(buf);
				else if (encoding === "hex") return (0, util_hex_encoding_1.toHex)(buf);
				else if (encoding === void 0 || encoding === "utf8" || encoding === "utf-8") return (0, util_utf8_1$2.toUtf8)(buf);
				else if (typeof TextDecoder === "function") return new TextDecoder(encoding).decode(buf);
				else throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
			},
			transformToWebStream: () => {
				if (transformed) throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED$1);
				transformed = true;
				if (isBlobInstance(stream$3)) return blobToWebStream(stream$3);
				else if ((0, stream_type_check_1$1.isReadableStream)(stream$3)) return stream$3;
				else throw new Error(`Cannot transform payload to web stream, got ${stream$3}`);
			}
		});
	};
	exports.sdkStreamMixin = sdkStreamMixin$3;
	const isBlobInstance = (stream$3) => typeof Blob === "function" && stream$3 instanceof Blob;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/sdk-stream-mixin.js
var require_sdk_stream_mixin = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.sdkStreamMixin = void 0;
	const node_http_handler_1$3 = require_dist_cjs$40();
	const util_buffer_from_1 = require_dist_cjs$45();
	const stream_1$2 = __require("stream");
	const sdk_stream_mixin_browser_1 = require_sdk_stream_mixin_browser();
	const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
	const sdkStreamMixin$2 = (stream$3) => {
		if (!(stream$3 instanceof stream_1$2.Readable)) try {
			return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream$3);
		} catch (e$5) {
			const name = stream$3?.__proto__?.constructor?.name || stream$3;
			throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
		}
		let transformed = false;
		const transformToByteArray = async () => {
			if (transformed) throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
			transformed = true;
			return await (0, node_http_handler_1$3.streamCollector)(stream$3);
		};
		return Object.assign(stream$3, {
			transformToByteArray,
			transformToString: async (encoding) => {
				const buf = await transformToByteArray();
				if (encoding === void 0 || Buffer.isEncoding(encoding)) return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
				else return new TextDecoder(encoding).decode(buf);
			},
			transformToWebStream: () => {
				if (transformed) throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
				if (stream$3.readableFlowing !== null) throw new Error("The stream has been consumed by other callbacks.");
				if (typeof stream_1$2.Readable.toWeb !== "function") throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
				transformed = true;
				return stream_1$2.Readable.toWeb(stream$3);
			}
		});
	};
	exports.sdkStreamMixin = sdkStreamMixin$2;
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/splitStream.browser.js
var require_splitStream_browser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.splitStream = splitStream$2;
	async function splitStream$2(stream$3) {
		if (typeof stream$3.stream === "function") stream$3 = stream$3.stream();
		return stream$3.tee();
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/splitStream.js
var require_splitStream = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.splitStream = splitStream$1;
	const stream_1$1 = __require("stream");
	const splitStream_browser_1 = require_splitStream_browser();
	const stream_type_check_1 = require_stream_type_check();
	async function splitStream$1(stream$3) {
		if ((0, stream_type_check_1.isReadableStream)(stream$3) || (0, stream_type_check_1.isBlob)(stream$3)) return (0, splitStream_browser_1.splitStream)(stream$3);
		const stream1 = new stream_1$1.PassThrough();
		const stream2 = new stream_1$1.PassThrough();
		stream$3.pipe(stream1);
		stream$3.pipe(stream2);
		return [stream1, stream2];
	}
}));

//#endregion
//#region node_modules/@smithy/util-stream/dist-cjs/index.js
var require_dist_cjs$37 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilBase64 = require_dist_cjs$43();
	var utilUtf8$2 = require_dist_cjs$44();
	var ChecksumStream = require_ChecksumStream();
	var createChecksumStream = require_createChecksumStream();
	var createBufferedReadable = require_createBufferedReadable();
	var getAwsChunkedEncodingStream = require_getAwsChunkedEncodingStream();
	var headStream = require_headStream();
	var sdkStreamMixin$1 = require_sdk_stream_mixin();
	var splitStream = require_splitStream();
	var streamTypeCheck = require_stream_type_check();
	var Uint8ArrayBlobAdapter$1 = class Uint8ArrayBlobAdapter$1 extends Uint8Array {
		static fromString(source, encoding = "utf-8") {
			if (typeof source === "string") {
				if (encoding === "base64") return Uint8ArrayBlobAdapter$1.mutate(utilBase64.fromBase64(source));
				return Uint8ArrayBlobAdapter$1.mutate(utilUtf8$2.fromUtf8(source));
			}
			throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
		}
		static mutate(source) {
			Object.setPrototypeOf(source, Uint8ArrayBlobAdapter$1.prototype);
			return source;
		}
		transformToString(encoding = "utf-8") {
			if (encoding === "base64") return utilBase64.toBase64(this);
			return utilUtf8$2.toUtf8(this);
		}
	};
	exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter$1;
	Object.keys(ChecksumStream).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return ChecksumStream[k$5];
			}
		});
	});
	Object.keys(createChecksumStream).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return createChecksumStream[k$5];
			}
		});
	});
	Object.keys(createBufferedReadable).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return createBufferedReadable[k$5];
			}
		});
	});
	Object.keys(getAwsChunkedEncodingStream).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return getAwsChunkedEncodingStream[k$5];
			}
		});
	});
	Object.keys(headStream).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return headStream[k$5];
			}
		});
	});
	Object.keys(sdkStreamMixin$1).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return sdkStreamMixin$1[k$5];
			}
		});
	});
	Object.keys(splitStream).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return splitStream[k$5];
			}
		});
	});
	Object.keys(streamTypeCheck).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return streamTypeCheck[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/collect-stream-body.js
var import_dist_cjs$147, collectBody;
var init_collect_stream_body = __esmMin((() => {
	import_dist_cjs$147 = require_dist_cjs$37();
	collectBody = async (streamBody = new Uint8Array(), context) => {
		if (streamBody instanceof Uint8Array) return import_dist_cjs$147.Uint8ArrayBlobAdapter.mutate(streamBody);
		if (!streamBody) return import_dist_cjs$147.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
		const fromContext = context.streamCollector(streamBody);
		return import_dist_cjs$147.Uint8ArrayBlobAdapter.mutate(await fromContext);
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/extended-encode-uri-component.js
function extendedEncodeURIComponent(str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function(c$5) {
		return "%" + c$5.charCodeAt(0).toString(16).toUpperCase();
	});
}
var init_extended_encode_uri_component = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/deref.js
var deref;
var init_deref = __esmMin((() => {
	deref = (schemaRef) => {
		if (typeof schemaRef === "function") return schemaRef();
		return schemaRef;
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/operation.js
var operation;
var init_operation = __esmMin((() => {
	operation = (namespace, name, traits, input, output) => ({
		name,
		namespace,
		traits,
		input,
		output
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaDeserializationMiddleware.js
var import_dist_cjs$145, import_dist_cjs$146, schemaDeserializationMiddleware, findHeader;
var init_schemaDeserializationMiddleware = __esmMin((() => {
	import_dist_cjs$145 = require_dist_cjs$52();
	import_dist_cjs$146 = require_dist_cjs$48();
	init_operation();
	schemaDeserializationMiddleware = (config) => (next, context) => async (args) => {
		const { response } = await next(args);
		const { operationSchema } = (0, import_dist_cjs$146.getSmithyContext)(context);
		const [, ns, n$5, t$5, i$5, o$5] = operationSchema ?? [];
		try {
			return {
				response,
				output: await config.protocol.deserializeResponse(operation(ns, n$5, t$5, i$5, o$5), {
					...config,
					...context
				}, response)
			};
		} catch (error$2) {
			Object.defineProperty(error$2, "$response", {
				value: response,
				enumerable: false,
				writable: false,
				configurable: false
			});
			if (!("$metadata" in error$2)) {
				const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
				try {
					error$2.message += "\n  " + hint;
				} catch (e$5) {
					if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") console.warn(hint);
					else context.logger?.warn?.(hint);
				}
				if (typeof error$2.$responseBodyText !== "undefined") {
					if (error$2.$response) error$2.$response.body = error$2.$responseBodyText;
				}
				try {
					if (import_dist_cjs$145.HttpResponse.isInstance(response)) {
						const { headers = {} } = response;
						const headerEntries = Object.entries(headers);
						error$2.$metadata = {
							httpStatusCode: response.statusCode,
							requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
							extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
							cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries)
						};
					}
				} catch (e$5) {}
			}
			throw error$2;
		}
	};
	findHeader = (pattern, headers) => {
		return (headers.find(([k$5]) => {
			return k$5.match(pattern);
		}) || [void 0, void 0])[1];
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/middleware/schemaSerializationMiddleware.js
var import_dist_cjs$144, schemaSerializationMiddleware;
var init_schemaSerializationMiddleware = __esmMin((() => {
	import_dist_cjs$144 = require_dist_cjs$48();
	init_operation();
	schemaSerializationMiddleware = (config) => (next, context) => async (args) => {
		const { operationSchema } = (0, import_dist_cjs$144.getSmithyContext)(context);
		const [, ns, n$5, t$5, i$5, o$5] = operationSchema ?? [];
		const endpoint = context.endpointV2?.url && config.urlParser ? async () => config.urlParser(context.endpointV2.url) : config.endpoint;
		const request$1 = await config.protocol.serializeRequest(operation(ns, n$5, t$5, i$5, o$5), args.input, {
			...config,
			...context,
			endpoint
		});
		return next({
			...args,
			request: request$1
		});
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/middleware/getSchemaSerdePlugin.js
function getSchemaSerdePlugin(config) {
	return { applyToStack: (commandStack) => {
		commandStack.add(schemaSerializationMiddleware(config), serializerMiddlewareOption);
		commandStack.add(schemaDeserializationMiddleware(config), deserializerMiddlewareOption);
		config.protocol.setSerdeContext(config);
	} };
}
var deserializerMiddlewareOption, serializerMiddlewareOption;
var init_getSchemaSerdePlugin = __esmMin((() => {
	init_schemaDeserializationMiddleware();
	init_schemaSerializationMiddleware();
	deserializerMiddlewareOption = {
		name: "deserializerMiddleware",
		step: "deserialize",
		tags: ["DESERIALIZER"],
		override: true
	};
	serializerMiddlewareOption = {
		name: "serializerMiddleware",
		step: "serialize",
		tags: ["SERIALIZER"],
		override: true
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/Schema.js
var Schema;
var init_Schema = __esmMin((() => {
	Schema = class {
		name;
		namespace;
		traits;
		static assign(instance, values) {
			return Object.assign(instance, values);
		}
		static [Symbol.hasInstance](lhs) {
			const isPrototype = this.prototype.isPrototypeOf(lhs);
			if (!isPrototype && typeof lhs === "object" && lhs !== null) return lhs.symbol === this.symbol;
			return isPrototype;
		}
		getName() {
			return this.namespace + "#" + this.name;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/ListSchema.js
var ListSchema, list;
var init_ListSchema = __esmMin((() => {
	init_Schema();
	ListSchema = class ListSchema extends Schema {
		static symbol = Symbol.for("@smithy/lis");
		name;
		traits;
		valueSchema;
		symbol = ListSchema.symbol;
	};
	list = (namespace, name, traits, valueSchema) => Schema.assign(new ListSchema(), {
		name,
		namespace,
		traits,
		valueSchema
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/MapSchema.js
var MapSchema, map$1;
var init_MapSchema = __esmMin((() => {
	init_Schema();
	MapSchema = class MapSchema extends Schema {
		static symbol = Symbol.for("@smithy/map");
		name;
		traits;
		keySchema;
		valueSchema;
		symbol = MapSchema.symbol;
	};
	map$1 = (namespace, name, traits, keySchema, valueSchema) => Schema.assign(new MapSchema(), {
		name,
		namespace,
		traits,
		keySchema,
		valueSchema
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/OperationSchema.js
var OperationSchema, op;
var init_OperationSchema = __esmMin((() => {
	init_Schema();
	OperationSchema = class OperationSchema extends Schema {
		static symbol = Symbol.for("@smithy/ope");
		name;
		traits;
		input;
		output;
		symbol = OperationSchema.symbol;
	};
	op = (namespace, name, traits, input, output) => Schema.assign(new OperationSchema(), {
		name,
		namespace,
		traits,
		input,
		output
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/StructureSchema.js
var StructureSchema, struct;
var init_StructureSchema = __esmMin((() => {
	init_Schema();
	StructureSchema = class StructureSchema extends Schema {
		static symbol = Symbol.for("@smithy/str");
		name;
		traits;
		memberNames;
		memberList;
		symbol = StructureSchema.symbol;
	};
	struct = (namespace, name, traits, memberNames, memberList) => Schema.assign(new StructureSchema(), {
		name,
		namespace,
		traits,
		memberNames,
		memberList
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/ErrorSchema.js
var ErrorSchema, error;
var init_ErrorSchema = __esmMin((() => {
	init_Schema();
	init_StructureSchema();
	ErrorSchema = class ErrorSchema extends StructureSchema {
		static symbol = Symbol.for("@smithy/err");
		ctor;
		symbol = ErrorSchema.symbol;
	};
	error = (namespace, name, traits, memberNames, memberList, ctor) => Schema.assign(new ErrorSchema(), {
		name,
		namespace,
		traits,
		memberNames,
		memberList,
		ctor: null
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/translateTraits.js
function translateTraits(indicator) {
	if (typeof indicator === "object") return indicator;
	indicator = indicator | 0;
	const traits = {};
	let i$5 = 0;
	for (const trait of [
		"httpLabel",
		"idempotent",
		"idempotencyToken",
		"sensitive",
		"httpPayload",
		"httpResponseCode",
		"httpQueryParams"
	]) if ((indicator >> i$5++ & 1) === 1) traits[trait] = 1;
	return traits;
}
var init_translateTraits = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/NormalizedSchema.js
function member(memberSchema, memberName) {
	if (memberSchema instanceof NormalizedSchema) return Object.assign(memberSchema, {
		memberName,
		_isMemberSchema: true
	});
	return new NormalizedSchema(memberSchema, memberName);
}
var NormalizedSchema, isMemberSchema, isStaticSchema;
var init_NormalizedSchema = __esmMin((() => {
	init_deref();
	init_translateTraits();
	NormalizedSchema = class NormalizedSchema {
		ref;
		memberName;
		static symbol = Symbol.for("@smithy/nor");
		symbol = NormalizedSchema.symbol;
		name;
		schema;
		_isMemberSchema;
		traits;
		memberTraits;
		normalizedTraits;
		constructor(ref, memberName) {
			this.ref = ref;
			this.memberName = memberName;
			const traitStack = [];
			let _ref = ref;
			let schema$3 = ref;
			this._isMemberSchema = false;
			while (isMemberSchema(_ref)) {
				traitStack.push(_ref[1]);
				_ref = _ref[0];
				schema$3 = deref(_ref);
				this._isMemberSchema = true;
			}
			if (traitStack.length > 0) {
				this.memberTraits = {};
				for (let i$5 = traitStack.length - 1; i$5 >= 0; --i$5) {
					const traitSet = traitStack[i$5];
					Object.assign(this.memberTraits, translateTraits(traitSet));
				}
			} else this.memberTraits = 0;
			if (schema$3 instanceof NormalizedSchema) {
				const computedMemberTraits = this.memberTraits;
				Object.assign(this, schema$3);
				this.memberTraits = Object.assign({}, computedMemberTraits, schema$3.getMemberTraits(), this.getMemberTraits());
				this.normalizedTraits = void 0;
				this.memberName = memberName ?? schema$3.memberName;
				return;
			}
			this.schema = deref(schema$3);
			if (isStaticSchema(this.schema)) {
				this.name = `${this.schema[1]}#${this.schema[2]}`;
				this.traits = this.schema[3];
			} else {
				this.name = this.memberName ?? String(schema$3);
				this.traits = 0;
			}
			if (this._isMemberSchema && !memberName) throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
		}
		static [Symbol.hasInstance](lhs) {
			const isPrototype = this.prototype.isPrototypeOf(lhs);
			if (!isPrototype && typeof lhs === "object" && lhs !== null) return lhs.symbol === this.symbol;
			return isPrototype;
		}
		static of(ref) {
			const sc = deref(ref);
			if (sc instanceof NormalizedSchema) return sc;
			if (isMemberSchema(sc)) {
				const [ns, traits] = sc;
				if (ns instanceof NormalizedSchema) {
					Object.assign(ns.getMergedTraits(), translateTraits(traits));
					return ns;
				}
				throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
			}
			return new NormalizedSchema(sc);
		}
		getSchema() {
			const sc = this.schema;
			if (sc[0] === 0) return sc[4];
			return sc;
		}
		getName(withNamespace = false) {
			const { name } = this;
			return !withNamespace && name && name.includes("#") ? name.split("#")[1] : name || void 0;
		}
		getMemberName() {
			return this.memberName;
		}
		isMemberSchema() {
			return this._isMemberSchema;
		}
		isListSchema() {
			const sc = this.getSchema();
			return typeof sc === "number" ? sc >= 64 && sc < 128 : sc[0] === 1;
		}
		isMapSchema() {
			const sc = this.getSchema();
			return typeof sc === "number" ? sc >= 128 && sc <= 255 : sc[0] === 2;
		}
		isStructSchema() {
			const sc = this.getSchema();
			return sc[0] === 3 || sc[0] === -3;
		}
		isBlobSchema() {
			const sc = this.getSchema();
			return sc === 21 || sc === 42;
		}
		isTimestampSchema() {
			const sc = this.getSchema();
			return typeof sc === "number" && sc >= 4 && sc <= 7;
		}
		isUnitSchema() {
			return this.getSchema() === "unit";
		}
		isDocumentSchema() {
			return this.getSchema() === 15;
		}
		isStringSchema() {
			return this.getSchema() === 0;
		}
		isBooleanSchema() {
			return this.getSchema() === 2;
		}
		isNumericSchema() {
			return this.getSchema() === 1;
		}
		isBigIntegerSchema() {
			return this.getSchema() === 17;
		}
		isBigDecimalSchema() {
			return this.getSchema() === 19;
		}
		isStreaming() {
			const { streaming } = this.getMergedTraits();
			return !!streaming || this.getSchema() === 42;
		}
		isIdempotencyToken() {
			const match = (traits$1) => (traits$1 & 4) === 4 || !!traits$1?.idempotencyToken;
			const { normalizedTraits, traits, memberTraits } = this;
			return match(normalizedTraits) || match(traits) || match(memberTraits);
		}
		getMergedTraits() {
			return this.normalizedTraits ?? (this.normalizedTraits = {
				...this.getOwnTraits(),
				...this.getMemberTraits()
			});
		}
		getMemberTraits() {
			return translateTraits(this.memberTraits);
		}
		getOwnTraits() {
			return translateTraits(this.traits);
		}
		getKeySchema() {
			const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];
			if (!isDoc && !isMap) throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
			const schema$3 = this.getSchema();
			return member([isDoc ? 15 : schema$3[4] ?? 0, 0], "key");
		}
		getValueSchema() {
			const sc = this.getSchema();
			const [isDoc, isMap, isList] = [
				this.isDocumentSchema(),
				this.isMapSchema(),
				this.isListSchema()
			];
			const memberSchema = typeof sc === "number" ? 63 & sc : sc && typeof sc === "object" && (isMap || isList) ? sc[3 + sc[0]] : isDoc ? 15 : void 0;
			if (memberSchema != null) return member([memberSchema, 0], isMap ? "value" : "member");
			throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
		}
		getMemberSchema(memberName) {
			const struct$1 = this.getSchema();
			if (this.isStructSchema() && struct$1[4].includes(memberName)) {
				const i$5 = struct$1[4].indexOf(memberName);
				const memberSchema = struct$1[5][i$5];
				return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
			}
			if (this.isDocumentSchema()) return member([15, 0], memberName);
			throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
		}
		getMemberSchemas() {
			const buffer$3 = {};
			try {
				for (const [k$5, v$5] of this.structIterator()) buffer$3[k$5] = v$5;
			} catch (ignored) {}
			return buffer$3;
		}
		getEventStreamMember() {
			if (this.isStructSchema()) {
				for (const [memberName, memberSchema] of this.structIterator()) if (memberSchema.isStreaming() && memberSchema.isStructSchema()) return memberName;
			}
			return "";
		}
		*structIterator() {
			if (this.isUnitSchema()) return;
			if (!this.isStructSchema()) throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
			const struct$1 = this.getSchema();
			for (let i$5 = 0; i$5 < struct$1[4].length; ++i$5) yield [struct$1[4][i$5], member([struct$1[5][i$5], 0], struct$1[4][i$5])];
		}
	};
	isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
	isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/SimpleSchema.js
var SimpleSchema, sim, simAdapter;
var init_SimpleSchema = __esmMin((() => {
	init_Schema();
	SimpleSchema = class SimpleSchema extends Schema {
		static symbol = Symbol.for("@smithy/sim");
		name;
		schemaRef;
		traits;
		symbol = SimpleSchema.symbol;
	};
	sim = (namespace, name, schemaRef, traits) => Schema.assign(new SimpleSchema(), {
		name,
		namespace,
		traits,
		schemaRef
	});
	simAdapter = (namespace, name, traits, schemaRef) => Schema.assign(new SimpleSchema(), {
		name,
		namespace,
		traits,
		schemaRef
	});
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/schemas/sentinels.js
var SCHEMA;
var init_sentinels = __esmMin((() => {
	SCHEMA = {
		BLOB: 21,
		STREAMING_BLOB: 42,
		BOOLEAN: 2,
		STRING: 0,
		NUMERIC: 1,
		BIG_INTEGER: 17,
		BIG_DECIMAL: 19,
		DOCUMENT: 15,
		TIMESTAMP_DEFAULT: 4,
		TIMESTAMP_DATE_TIME: 5,
		TIMESTAMP_HTTP_DATE: 6,
		TIMESTAMP_EPOCH_SECONDS: 7,
		LIST_MODIFIER: 64,
		MAP_MODIFIER: 128
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/TypeRegistry.js
var TypeRegistry;
var init_TypeRegistry = __esmMin((() => {
	TypeRegistry = class TypeRegistry {
		namespace;
		schemas;
		exceptions;
		static registries = /* @__PURE__ */ new Map();
		constructor(namespace, schemas = /* @__PURE__ */ new Map(), exceptions = /* @__PURE__ */ new Map()) {
			this.namespace = namespace;
			this.schemas = schemas;
			this.exceptions = exceptions;
		}
		static for(namespace) {
			if (!TypeRegistry.registries.has(namespace)) TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));
			return TypeRegistry.registries.get(namespace);
		}
		register(shapeId, schema$3) {
			const qualifiedName = this.normalizeShapeId(shapeId);
			TypeRegistry.for(qualifiedName.split("#")[0]).schemas.set(qualifiedName, schema$3);
		}
		getSchema(shapeId) {
			const id = this.normalizeShapeId(shapeId);
			if (!this.schemas.has(id)) throw new Error(`@smithy/core/schema - schema not found for ${id}`);
			return this.schemas.get(id);
		}
		registerError(es, ctor) {
			const $error = es;
			const registry = TypeRegistry.for($error[1]);
			registry.schemas.set($error[1] + "#" + $error[2], $error);
			registry.exceptions.set($error, ctor);
		}
		getErrorCtor(es) {
			const $error = es;
			return TypeRegistry.for($error[1]).exceptions.get($error);
		}
		getBaseException() {
			for (const exceptionKey of this.exceptions.keys()) if (Array.isArray(exceptionKey)) {
				const [, ns, name] = exceptionKey;
				const id = ns + "#" + name;
				if (id.startsWith("smithy.ts.sdk.synthetic.") && id.endsWith("ServiceException")) return exceptionKey;
			}
		}
		find(predicate) {
			return [...this.schemas.values()].find(predicate);
		}
		clear() {
			this.schemas.clear();
			this.exceptions.clear();
		}
		normalizeShapeId(shapeId) {
			if (shapeId.includes("#")) return shapeId;
			return this.namespace + "#" + shapeId;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/schema/index.js
var schema_exports = /* @__PURE__ */ __export({
	ErrorSchema: () => ErrorSchema,
	ListSchema: () => ListSchema,
	MapSchema: () => MapSchema,
	NormalizedSchema: () => NormalizedSchema,
	OperationSchema: () => OperationSchema,
	SCHEMA: () => SCHEMA,
	Schema: () => Schema,
	SimpleSchema: () => SimpleSchema,
	StructureSchema: () => StructureSchema,
	TypeRegistry: () => TypeRegistry,
	deref: () => deref,
	deserializerMiddlewareOption: () => deserializerMiddlewareOption,
	error: () => error,
	getSchemaSerdePlugin: () => getSchemaSerdePlugin,
	isStaticSchema: () => isStaticSchema,
	list: () => list,
	map: () => map$1,
	op: () => op,
	operation: () => operation,
	serializerMiddlewareOption: () => serializerMiddlewareOption,
	sim: () => sim,
	simAdapter: () => simAdapter,
	struct: () => struct,
	translateTraits: () => translateTraits
});
var init_schema = __esmMin((() => {
	init_deref();
	init_getSchemaSerdePlugin();
	init_ListSchema();
	init_MapSchema();
	init_OperationSchema();
	init_operation();
	init_ErrorSchema();
	init_NormalizedSchema();
	init_Schema();
	init_SimpleSchema();
	init_StructureSchema();
	init_sentinels();
	init_translateTraits();
	init_TypeRegistry();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/copyDocumentWithTransform.js
var copyDocumentWithTransform;
var init_copyDocumentWithTransform = __esmMin((() => {
	copyDocumentWithTransform = (source, schemaRef, transform = (_) => _) => source;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/parse-utils.js
var parseBoolean, expectBoolean, expectNumber, MAX_FLOAT, expectFloat32, expectLong, expectInt, expectInt32, expectShort, expectByte, expectSizedInt, castInt, expectNonNull, expectObject, expectString, expectUnion$1, strictParseDouble, strictParseFloat, strictParseFloat32, NUMBER_REGEX, parseNumber, limitedParseDouble, handleFloat, limitedParseFloat, limitedParseFloat32, parseFloatString, strictParseLong, strictParseInt, strictParseInt32, strictParseShort, strictParseByte, stackTraceWarning, logger;
var init_parse_utils = __esmMin((() => {
	parseBoolean = (value) => {
		switch (value) {
			case "true": return true;
			case "false": return false;
			default: throw new Error(`Unable to parse boolean value "${value}"`);
		}
	};
	expectBoolean = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value === "number") {
			if (value === 0 || value === 1) logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
			if (value === 0) return false;
			if (value === 1) return true;
		}
		if (typeof value === "string") {
			const lower = value.toLowerCase();
			if (lower === "false" || lower === "true") logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
			if (lower === "false") return false;
			if (lower === "true") return true;
		}
		if (typeof value === "boolean") return value;
		throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
	};
	expectNumber = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value === "string") {
			const parsed = parseFloat(value);
			if (!Number.isNaN(parsed)) {
				if (String(parsed) !== String(value)) logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
				return parsed;
			}
		}
		if (typeof value === "number") return value;
		throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
	};
	MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
	expectFloat32 = (value) => {
		const expected = expectNumber(value);
		if (expected !== void 0 && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
			if (Math.abs(expected) > MAX_FLOAT) throw new TypeError(`Expected 32-bit float, got ${value}`);
		}
		return expected;
	};
	expectLong = (value) => {
		if (value === null || value === void 0) return;
		if (Number.isInteger(value) && !Number.isNaN(value)) return value;
		throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
	};
	expectInt = expectLong;
	expectInt32 = (value) => expectSizedInt(value, 32);
	expectShort = (value) => expectSizedInt(value, 16);
	expectByte = (value) => expectSizedInt(value, 8);
	expectSizedInt = (value, size) => {
		const expected = expectLong(value);
		if (expected !== void 0 && castInt(expected, size) !== expected) throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
		return expected;
	};
	castInt = (value, size) => {
		switch (size) {
			case 32: return Int32Array.of(value)[0];
			case 16: return Int16Array.of(value)[0];
			case 8: return Int8Array.of(value)[0];
		}
	};
	expectNonNull = (value, location) => {
		if (value === null || value === void 0) {
			if (location) throw new TypeError(`Expected a non-null value for ${location}`);
			throw new TypeError("Expected a non-null value");
		}
		return value;
	};
	expectObject = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value === "object" && !Array.isArray(value)) return value;
		const receivedType = Array.isArray(value) ? "array" : typeof value;
		throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
	};
	expectString = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value === "string") return value;
		if ([
			"boolean",
			"number",
			"bigint"
		].includes(typeof value)) {
			logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
			return String(value);
		}
		throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
	};
	expectUnion$1 = (value) => {
		if (value === null || value === void 0) return;
		const asObject = expectObject(value);
		const setKeys = Object.entries(asObject).filter(([, v$5]) => v$5 != null).map(([k$5]) => k$5);
		if (setKeys.length === 0) throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
		if (setKeys.length > 1) throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
		return asObject;
	};
	strictParseDouble = (value) => {
		if (typeof value == "string") return expectNumber(parseNumber(value));
		return expectNumber(value);
	};
	strictParseFloat = strictParseDouble;
	strictParseFloat32 = (value) => {
		if (typeof value == "string") return expectFloat32(parseNumber(value));
		return expectFloat32(value);
	};
	NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
	parseNumber = (value) => {
		const matches = value.match(NUMBER_REGEX);
		if (matches === null || matches[0].length !== value.length) throw new TypeError(`Expected real number, got implicit NaN`);
		return parseFloat(value);
	};
	limitedParseDouble = (value) => {
		if (typeof value == "string") return parseFloatString(value);
		return expectNumber(value);
	};
	handleFloat = limitedParseDouble;
	limitedParseFloat = limitedParseDouble;
	limitedParseFloat32 = (value) => {
		if (typeof value == "string") return parseFloatString(value);
		return expectFloat32(value);
	};
	parseFloatString = (value) => {
		switch (value) {
			case "NaN": return NaN;
			case "Infinity": return Infinity;
			case "-Infinity": return -Infinity;
			default: throw new Error(`Unable to parse float value: ${value}`);
		}
	};
	strictParseLong = (value) => {
		if (typeof value === "string") return expectLong(parseNumber(value));
		return expectLong(value);
	};
	strictParseInt = strictParseLong;
	strictParseInt32 = (value) => {
		if (typeof value === "string") return expectInt32(parseNumber(value));
		return expectInt32(value);
	};
	strictParseShort = (value) => {
		if (typeof value === "string") return expectShort(parseNumber(value));
		return expectShort(value);
	};
	strictParseByte = (value) => {
		if (typeof value === "string") return expectByte(parseNumber(value));
		return expectByte(value);
	};
	stackTraceWarning = (message) => {
		return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s$5) => !s$5.includes("stackTraceWarning")).join("\n");
	};
	logger = { warn: console.warn };
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/date-utils.js
function dateToUtcString$2(date$1) {
	const year$1 = date$1.getUTCFullYear();
	const month = date$1.getUTCMonth();
	const dayOfWeek = date$1.getUTCDay();
	const dayOfMonthInt = date$1.getUTCDate();
	const hoursInt = date$1.getUTCHours();
	const minutesInt = date$1.getUTCMinutes();
	const secondsInt = date$1.getUTCSeconds();
	const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
	const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
	const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
	const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
	return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year$1} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
var DAYS, MONTHS, RFC3339, parseRfc3339DateTime, RFC3339_WITH_OFFSET$1, parseRfc3339DateTimeWithOffset, IMF_FIXDATE$1, RFC_850_DATE$1, ASC_TIME$1, parseRfc7231DateTime, parseEpochTimestamp, buildDate, parseTwoDigitYear, FIFTY_YEARS_IN_MILLIS, adjustRfc850Year, parseMonthByShortName, DAYS_IN_MONTH, validateDayOfMonth, isLeapYear, parseDateValue, parseMilliseconds, parseOffsetToMilliseconds, stripLeadingZeroes;
var init_date_utils = __esmMin((() => {
	init_parse_utils();
	DAYS = [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	];
	MONTHS = [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	];
	RFC3339 = /* @__PURE__ */ new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
	parseRfc3339DateTime = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value !== "string") throw new TypeError("RFC-3339 date-times must be expressed as strings");
		const match = RFC3339.exec(value);
		if (!match) throw new TypeError("Invalid RFC-3339 date-time value");
		const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
		return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseDateValue(monthStr, "month", 1, 12), parseDateValue(dayStr, "day", 1, 31), {
			hours,
			minutes,
			seconds,
			fractionalMilliseconds
		});
	};
	RFC3339_WITH_OFFSET$1 = /* @__PURE__ */ new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
	parseRfc3339DateTimeWithOffset = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value !== "string") throw new TypeError("RFC-3339 date-times must be expressed as strings");
		const match = RFC3339_WITH_OFFSET$1.exec(value);
		if (!match) throw new TypeError("Invalid RFC-3339 date-time value");
		const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
		const date$1 = buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseDateValue(monthStr, "month", 1, 12), parseDateValue(dayStr, "day", 1, 31), {
			hours,
			minutes,
			seconds,
			fractionalMilliseconds
		});
		if (offsetStr.toUpperCase() != "Z") date$1.setTime(date$1.getTime() - parseOffsetToMilliseconds(offsetStr));
		return date$1;
	};
	IMF_FIXDATE$1 = /* @__PURE__ */ new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
	RFC_850_DATE$1 = /* @__PURE__ */ new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
	ASC_TIME$1 = /* @__PURE__ */ new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
	parseRfc7231DateTime = (value) => {
		if (value === null || value === void 0) return;
		if (typeof value !== "string") throw new TypeError("RFC-7231 date-times must be expressed as strings");
		let match = IMF_FIXDATE$1.exec(value);
		if (match) {
			const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
			return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
				hours,
				minutes,
				seconds,
				fractionalMilliseconds
			});
		}
		match = RFC_850_DATE$1.exec(value);
		if (match) {
			const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
			return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
				hours,
				minutes,
				seconds,
				fractionalMilliseconds
			}));
		}
		match = ASC_TIME$1.exec(value);
		if (match) {
			const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
			return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), {
				hours,
				minutes,
				seconds,
				fractionalMilliseconds
			});
		}
		throw new TypeError("Invalid RFC-7231 date-time value");
	};
	parseEpochTimestamp = (value) => {
		if (value === null || value === void 0) return;
		let valueAsDouble;
		if (typeof value === "number") valueAsDouble = value;
		else if (typeof value === "string") valueAsDouble = strictParseDouble(value);
		else if (typeof value === "object" && value.tag === 1) valueAsDouble = value.value;
		else throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
		if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
		return new Date(Math.round(valueAsDouble * 1e3));
	};
	buildDate = (year$1, month, day, time$1) => {
		const adjustedMonth = month - 1;
		validateDayOfMonth(year$1, adjustedMonth, day);
		return new Date(Date.UTC(year$1, adjustedMonth, day, parseDateValue(time$1.hours, "hour", 0, 23), parseDateValue(time$1.minutes, "minute", 0, 59), parseDateValue(time$1.seconds, "seconds", 0, 60), parseMilliseconds(time$1.fractionalMilliseconds)));
	};
	parseTwoDigitYear = (value) => {
		const thisYear = (/* @__PURE__ */ new Date()).getUTCFullYear();
		const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
		if (valueInThisCentury < thisYear) return valueInThisCentury + 100;
		return valueInThisCentury;
	};
	FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1e3;
	adjustRfc850Year = (input) => {
		if (input.getTime() - (/* @__PURE__ */ new Date()).getTime() > FIFTY_YEARS_IN_MILLIS) return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
		return input;
	};
	parseMonthByShortName = (value) => {
		const monthIdx = MONTHS.indexOf(value);
		if (monthIdx < 0) throw new TypeError(`Invalid month: ${value}`);
		return monthIdx + 1;
	};
	DAYS_IN_MONTH = [
		31,
		28,
		31,
		30,
		31,
		30,
		31,
		31,
		30,
		31,
		30,
		31
	];
	validateDayOfMonth = (year$1, month, day) => {
		let maxDays = DAYS_IN_MONTH[month];
		if (month === 1 && isLeapYear(year$1)) maxDays = 29;
		if (day > maxDays) throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year$1}: ${day}`);
	};
	isLeapYear = (year$1) => {
		return year$1 % 4 === 0 && (year$1 % 100 !== 0 || year$1 % 400 === 0);
	};
	parseDateValue = (value, type, lower, upper) => {
		const dateVal = strictParseByte(stripLeadingZeroes(value));
		if (dateVal < lower || dateVal > upper) throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
		return dateVal;
	};
	parseMilliseconds = (value) => {
		if (value === null || value === void 0) return 0;
		return strictParseFloat32("0." + value) * 1e3;
	};
	parseOffsetToMilliseconds = (value) => {
		const directionStr = value[0];
		let direction = 1;
		if (directionStr == "+") direction = 1;
		else if (directionStr == "-") direction = -1;
		else throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
		const hour = Number(value.substring(1, 3));
		const minute = Number(value.substring(4, 6));
		return direction * (hour * 60 + minute) * 60 * 1e3;
	};
	stripLeadingZeroes = (value) => {
		let idx = 0;
		while (idx < value.length - 1 && value.charAt(idx) === "0") idx++;
		if (idx === 0) return value;
		return value.slice(idx);
	};
}));

//#endregion
//#region node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = /* @__PURE__ */ __export({
	__addDisposableResource: () => __addDisposableResource,
	__assign: () => __assign,
	__asyncDelegator: () => __asyncDelegator,
	__asyncGenerator: () => __asyncGenerator,
	__asyncValues: () => __asyncValues,
	__await: () => __await,
	__awaiter: () => __awaiter,
	__classPrivateFieldGet: () => __classPrivateFieldGet,
	__classPrivateFieldIn: () => __classPrivateFieldIn,
	__classPrivateFieldSet: () => __classPrivateFieldSet,
	__createBinding: () => __createBinding$1,
	__decorate: () => __decorate,
	__disposeResources: () => __disposeResources,
	__esDecorate: () => __esDecorate,
	__exportStar: () => __exportStar,
	__extends: () => __extends,
	__generator: () => __generator,
	__importDefault: () => __importDefault,
	__importStar: () => __importStar$1,
	__makeTemplateObject: () => __makeTemplateObject,
	__metadata: () => __metadata,
	__param: () => __param,
	__propKey: () => __propKey,
	__read: () => __read,
	__rest: () => __rest,
	__rewriteRelativeImportExtension: () => __rewriteRelativeImportExtension,
	__runInitializers: () => __runInitializers,
	__setFunctionName: () => __setFunctionName,
	__spread: () => __spread,
	__spreadArray: () => __spreadArray,
	__spreadArrays: () => __spreadArrays,
	__values: () => __values,
	default: () => tslib_es6_default
});
function __extends(d$5, b$5) {
	if (typeof b$5 !== "function" && b$5 !== null) throw new TypeError("Class extends value " + String(b$5) + " is not a constructor or null");
	extendStatics(d$5, b$5);
	function __() {
		this.constructor = d$5;
	}
	d$5.prototype = b$5 === null ? Object.create(b$5) : (__.prototype = b$5.prototype, new __());
}
function __rest(s$5, e$5) {
	var t$5 = {};
	for (var p$5 in s$5) if (Object.prototype.hasOwnProperty.call(s$5, p$5) && e$5.indexOf(p$5) < 0) t$5[p$5] = s$5[p$5];
	if (s$5 != null && typeof Object.getOwnPropertySymbols === "function") {
		for (var i$5 = 0, p$5 = Object.getOwnPropertySymbols(s$5); i$5 < p$5.length; i$5++) if (e$5.indexOf(p$5[i$5]) < 0 && Object.prototype.propertyIsEnumerable.call(s$5, p$5[i$5])) t$5[p$5[i$5]] = s$5[p$5[i$5]];
	}
	return t$5;
}
function __decorate(decorators, target, key, desc) {
	var c$5 = arguments.length, r$5 = c$5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d$5;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r$5 = Reflect.decorate(decorators, target, key, desc);
	else for (var i$5 = decorators.length - 1; i$5 >= 0; i$5--) if (d$5 = decorators[i$5]) r$5 = (c$5 < 3 ? d$5(r$5) : c$5 > 3 ? d$5(target, key, r$5) : d$5(target, key)) || r$5;
	return c$5 > 3 && r$5 && Object.defineProperty(target, key, r$5), r$5;
}
function __param(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
	function accept(f$5) {
		if (f$5 !== void 0 && typeof f$5 !== "function") throw new TypeError("Function expected");
		return f$5;
	}
	var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
	var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
	var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
	var _, done = false;
	for (var i$5 = decorators.length - 1; i$5 >= 0; i$5--) {
		var context = {};
		for (var p$5 in contextIn) context[p$5] = p$5 === "access" ? {} : contextIn[p$5];
		for (var p$5 in contextIn.access) context.access[p$5] = contextIn.access[p$5];
		context.addInitializer = function(f$5) {
			if (done) throw new TypeError("Cannot add initializers after decoration has completed");
			extraInitializers.push(accept(f$5 || null));
		};
		var result = (0, decorators[i$5])(kind === "accessor" ? {
			get: descriptor.get,
			set: descriptor.set
		} : descriptor[key], context);
		if (kind === "accessor") {
			if (result === void 0) continue;
			if (result === null || typeof result !== "object") throw new TypeError("Object expected");
			if (_ = accept(result.get)) descriptor.get = _;
			if (_ = accept(result.set)) descriptor.set = _;
			if (_ = accept(result.init)) initializers.unshift(_);
		} else if (_ = accept(result)) if (kind === "field") initializers.unshift(_);
		else descriptor[key] = _;
	}
	if (target) Object.defineProperty(target, contextIn.name, descriptor);
	done = true;
}
function __runInitializers(thisArg, initializers, value) {
	var useValue = arguments.length > 2;
	for (var i$5 = 0; i$5 < initializers.length; i$5++) value = useValue ? initializers[i$5].call(thisArg, value) : initializers[i$5].call(thisArg);
	return useValue ? value : void 0;
}
function __propKey(x$5) {
	return typeof x$5 === "symbol" ? x$5 : "".concat(x$5);
}
function __setFunctionName(f$5, name, prefix) {
	if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
	return Object.defineProperty(f$5, "name", {
		configurable: true,
		value: prefix ? "".concat(prefix, " ", name) : name
	});
}
function __metadata(metadataKey, metadataValue) {
	if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
	function adopt(value) {
		return value instanceof P ? value : new P(function(resolve) {
			resolve(value);
		});
	}
	return new (P || (P = Promise))(function(resolve, reject) {
		function fulfilled(value) {
			try {
				step(generator.next(value));
			} catch (e$5) {
				reject(e$5);
			}
		}
		function rejected(value) {
			try {
				step(generator["throw"](value));
			} catch (e$5) {
				reject(e$5);
			}
		}
		function step(result) {
			result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
		}
		step((generator = generator.apply(thisArg, _arguments || [])).next());
	});
}
function __generator(thisArg, body) {
	var _ = {
		label: 0,
		sent: function() {
			if (t$5[0] & 1) throw t$5[1];
			return t$5[1];
		},
		trys: [],
		ops: []
	}, f$5, y$2, t$5, g$5 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
	return g$5.next = verb(0), g$5["throw"] = verb(1), g$5["return"] = verb(2), typeof Symbol === "function" && (g$5[Symbol.iterator] = function() {
		return this;
	}), g$5;
	function verb(n$5) {
		return function(v$5) {
			return step([n$5, v$5]);
		};
	}
	function step(op$1) {
		if (f$5) throw new TypeError("Generator is already executing.");
		while (g$5 && (g$5 = 0, op$1[0] && (_ = 0)), _) try {
			if (f$5 = 1, y$2 && (t$5 = op$1[0] & 2 ? y$2["return"] : op$1[0] ? y$2["throw"] || ((t$5 = y$2["return"]) && t$5.call(y$2), 0) : y$2.next) && !(t$5 = t$5.call(y$2, op$1[1])).done) return t$5;
			if (y$2 = 0, t$5) op$1 = [op$1[0] & 2, t$5.value];
			switch (op$1[0]) {
				case 0:
				case 1:
					t$5 = op$1;
					break;
				case 4:
					_.label++;
					return {
						value: op$1[1],
						done: false
					};
				case 5:
					_.label++;
					y$2 = op$1[1];
					op$1 = [0];
					continue;
				case 7:
					op$1 = _.ops.pop();
					_.trys.pop();
					continue;
				default:
					if (!(t$5 = _.trys, t$5 = t$5.length > 0 && t$5[t$5.length - 1]) && (op$1[0] === 6 || op$1[0] === 2)) {
						_ = 0;
						continue;
					}
					if (op$1[0] === 3 && (!t$5 || op$1[1] > t$5[0] && op$1[1] < t$5[3])) {
						_.label = op$1[1];
						break;
					}
					if (op$1[0] === 6 && _.label < t$5[1]) {
						_.label = t$5[1];
						t$5 = op$1;
						break;
					}
					if (t$5 && _.label < t$5[2]) {
						_.label = t$5[2];
						_.ops.push(op$1);
						break;
					}
					if (t$5[2]) _.ops.pop();
					_.trys.pop();
					continue;
			}
			op$1 = body.call(thisArg, _);
		} catch (e$5) {
			op$1 = [6, e$5];
			y$2 = 0;
		} finally {
			f$5 = t$5 = 0;
		}
		if (op$1[0] & 5) throw op$1[1];
		return {
			value: op$1[0] ? op$1[1] : void 0,
			done: true
		};
	}
}
function __exportStar(m$5, o$5) {
	for (var p$5 in m$5) if (p$5 !== "default" && !Object.prototype.hasOwnProperty.call(o$5, p$5)) __createBinding$1(o$5, m$5, p$5);
}
function __values(o$5) {
	var s$5 = typeof Symbol === "function" && Symbol.iterator, m$5 = s$5 && o$5[s$5], i$5 = 0;
	if (m$5) return m$5.call(o$5);
	if (o$5 && typeof o$5.length === "number") return { next: function() {
		if (o$5 && i$5 >= o$5.length) o$5 = void 0;
		return {
			value: o$5 && o$5[i$5++],
			done: !o$5
		};
	} };
	throw new TypeError(s$5 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o$5, n$5) {
	var m$5 = typeof Symbol === "function" && o$5[Symbol.iterator];
	if (!m$5) return o$5;
	var i$5 = m$5.call(o$5), r$5, ar = [], e$5;
	try {
		while ((n$5 === void 0 || n$5-- > 0) && !(r$5 = i$5.next()).done) ar.push(r$5.value);
	} catch (error$2) {
		e$5 = { error: error$2 };
	} finally {
		try {
			if (r$5 && !r$5.done && (m$5 = i$5["return"])) m$5.call(i$5);
		} finally {
			if (e$5) throw e$5.error;
		}
	}
	return ar;
}
/** @deprecated */
function __spread() {
	for (var ar = [], i$5 = 0; i$5 < arguments.length; i$5++) ar = ar.concat(__read(arguments[i$5]));
	return ar;
}
/** @deprecated */
function __spreadArrays() {
	for (var s$5 = 0, i$5 = 0, il = arguments.length; i$5 < il; i$5++) s$5 += arguments[i$5].length;
	for (var r$5 = Array(s$5), k$5 = 0, i$5 = 0; i$5 < il; i$5++) for (var a$5 = arguments[i$5], j$5 = 0, jl = a$5.length; j$5 < jl; j$5++, k$5++) r$5[k$5] = a$5[j$5];
	return r$5;
}
function __spreadArray(to, from, pack) {
	if (pack || arguments.length === 2) {
		for (var i$5 = 0, l$5 = from.length, ar; i$5 < l$5; i$5++) if (ar || !(i$5 in from)) {
			if (!ar) ar = Array.prototype.slice.call(from, 0, i$5);
			ar[i$5] = from[i$5];
		}
	}
	return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v$5) {
	return this instanceof __await ? (this.v = v$5, this) : new __await(v$5);
}
function __asyncGenerator(thisArg, _arguments, generator) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var g$5 = generator.apply(thisArg, _arguments || []), i$5, q$5 = [];
	return i$5 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i$5[Symbol.asyncIterator] = function() {
		return this;
	}, i$5;
	function awaitReturn(f$5) {
		return function(v$5) {
			return Promise.resolve(v$5).then(f$5, reject);
		};
	}
	function verb(n$5, f$5) {
		if (g$5[n$5]) {
			i$5[n$5] = function(v$5) {
				return new Promise(function(a$5, b$5) {
					q$5.push([
						n$5,
						v$5,
						a$5,
						b$5
					]) > 1 || resume$1(n$5, v$5);
				});
			};
			if (f$5) i$5[n$5] = f$5(i$5[n$5]);
		}
	}
	function resume$1(n$5, v$5) {
		try {
			step(g$5[n$5](v$5));
		} catch (e$5) {
			settle(q$5[0][3], e$5);
		}
	}
	function step(r$5) {
		r$5.value instanceof __await ? Promise.resolve(r$5.value.v).then(fulfill, reject) : settle(q$5[0][2], r$5);
	}
	function fulfill(value) {
		resume$1("next", value);
	}
	function reject(value) {
		resume$1("throw", value);
	}
	function settle(f$5, v$5) {
		if (f$5(v$5), q$5.shift(), q$5.length) resume$1(q$5[0][0], q$5[0][1]);
	}
}
function __asyncDelegator(o$5) {
	var i$5, p$5;
	return i$5 = {}, verb("next"), verb("throw", function(e$5) {
		throw e$5;
	}), verb("return"), i$5[Symbol.iterator] = function() {
		return this;
	}, i$5;
	function verb(n$5, f$5) {
		i$5[n$5] = o$5[n$5] ? function(v$5) {
			return (p$5 = !p$5) ? {
				value: __await(o$5[n$5](v$5)),
				done: false
			} : f$5 ? f$5(v$5) : v$5;
		} : f$5;
	}
}
function __asyncValues(o$5) {
	if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	var m$5 = o$5[Symbol.asyncIterator], i$5;
	return m$5 ? m$5.call(o$5) : (o$5 = typeof __values === "function" ? __values(o$5) : o$5[Symbol.iterator](), i$5 = {}, verb("next"), verb("throw"), verb("return"), i$5[Symbol.asyncIterator] = function() {
		return this;
	}, i$5);
	function verb(n$5) {
		i$5[n$5] = o$5[n$5] && function(v$5) {
			return new Promise(function(resolve, reject) {
				v$5 = o$5[n$5](v$5), settle(resolve, reject, v$5.done, v$5.value);
			});
		};
	}
	function settle(resolve, reject, d$5, v$5) {
		Promise.resolve(v$5).then(function(v$6) {
			resolve({
				value: v$6,
				done: d$5
			});
		}, reject);
	}
}
function __makeTemplateObject(cooked, raw) {
	if (Object.defineProperty) Object.defineProperty(cooked, "raw", { value: raw });
	else cooked.raw = raw;
	return cooked;
}
function __importStar$1(mod) {
	if (mod && mod.__esModule) return mod;
	var result = {};
	if (mod != null) {
		for (var k$5 = ownKeys(mod), i$5 = 0; i$5 < k$5.length; i$5++) if (k$5[i$5] !== "default") __createBinding$1(result, mod, k$5[i$5]);
	}
	__setModuleDefault$1(result, mod);
	return result;
}
function __importDefault(mod) {
	return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state$1, kind, f$5) {
	if (kind === "a" && !f$5) throw new TypeError("Private accessor was defined without a getter");
	if (typeof state$1 === "function" ? receiver !== state$1 || !f$5 : !state$1.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
	return kind === "m" ? f$5 : kind === "a" ? f$5.call(receiver) : f$5 ? f$5.value : state$1.get(receiver);
}
function __classPrivateFieldSet(receiver, state$1, value, kind, f$5) {
	if (kind === "m") throw new TypeError("Private method is not writable");
	if (kind === "a" && !f$5) throw new TypeError("Private accessor was defined without a setter");
	if (typeof state$1 === "function" ? receiver !== state$1 || !f$5 : !state$1.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
	return kind === "a" ? f$5.call(receiver, value) : f$5 ? f$5.value = value : state$1.set(receiver, value), value;
}
function __classPrivateFieldIn(state$1, receiver) {
	if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
	return typeof state$1 === "function" ? receiver === state$1 : state$1.has(receiver);
}
function __addDisposableResource(env, value, async) {
	if (value !== null && value !== void 0) {
		if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
		var dispose, inner;
		if (async) {
			if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
			dispose = value[Symbol.asyncDispose];
		}
		if (dispose === void 0) {
			if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
			dispose = value[Symbol.dispose];
			if (async) inner = dispose;
		}
		if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
		if (inner) dispose = function() {
			try {
				inner.call(this);
			} catch (e$5) {
				return Promise.reject(e$5);
			}
		};
		env.stack.push({
			value,
			dispose,
			async
		});
	} else if (async) env.stack.push({ async: true });
	return value;
}
function __disposeResources(env) {
	function fail(e$5) {
		env.error = env.hasError ? new _SuppressedError(e$5, env.error, "An error was suppressed during disposal.") : e$5;
		env.hasError = true;
	}
	var r$5, s$5 = 0;
	function next() {
		while (r$5 = env.stack.pop()) try {
			if (!r$5.async && s$5 === 1) return s$5 = 0, env.stack.push(r$5), Promise.resolve().then(next);
			if (r$5.dispose) {
				var result = r$5.dispose.call(r$5.value);
				if (r$5.async) return s$5 |= 2, Promise.resolve(result).then(next, function(e$5) {
					fail(e$5);
					return next();
				});
			} else s$5 |= 1;
		} catch (e$5) {
			fail(e$5);
		}
		if (s$5 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
		if (env.hasError) throw env.error;
	}
	return next();
}
function __rewriteRelativeImportExtension(path$6, preserveJsx) {
	if (typeof path$6 === "string" && /^\.\.?\//.test(path$6)) return path$6.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m$5, tsx, d$5, ext, cm) {
		return tsx ? preserveJsx ? ".jsx" : ".js" : d$5 && (!ext || !cm) ? m$5 : d$5 + ext + "." + cm.toLowerCase() + "js";
	});
	return path$6;
}
var extendStatics, __assign, __createBinding$1, __setModuleDefault$1, ownKeys, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esmMin((() => {
	extendStatics = function(d$5, b$5) {
		extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d$6, b$6) {
			d$6.__proto__ = b$6;
		} || function(d$6, b$6) {
			for (var p$5 in b$6) if (Object.prototype.hasOwnProperty.call(b$6, p$5)) d$6[p$5] = b$6[p$5];
		};
		return extendStatics(d$5, b$5);
	};
	__assign = function() {
		__assign = Object.assign || function __assign$1(t$5) {
			for (var s$5, i$5 = 1, n$5 = arguments.length; i$5 < n$5; i$5++) {
				s$5 = arguments[i$5];
				for (var p$5 in s$5) if (Object.prototype.hasOwnProperty.call(s$5, p$5)) t$5[p$5] = s$5[p$5];
			}
			return t$5;
		};
		return __assign.apply(this, arguments);
	};
	__createBinding$1 = Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	});
	__setModuleDefault$1 = Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	};
	ownKeys = function(o$5) {
		ownKeys = Object.getOwnPropertyNames || function(o$6) {
			var ar = [];
			for (var k$5 in o$6) if (Object.prototype.hasOwnProperty.call(o$6, k$5)) ar[ar.length] = k$5;
			return ar;
		};
		return ownKeys(o$5);
	};
	_SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error$2, suppressed, message) {
		var e$5 = new Error(message);
		return e$5.name = "SuppressedError", e$5.error = error$2, e$5.suppressed = suppressed, e$5;
	};
	tslib_es6_default = {
		__extends,
		__assign,
		__rest,
		__decorate,
		__param,
		__esDecorate,
		__runInitializers,
		__propKey,
		__setFunctionName,
		__metadata,
		__awaiter,
		__generator,
		__createBinding: __createBinding$1,
		__exportStar,
		__values,
		__read,
		__spread,
		__spreadArrays,
		__spreadArray,
		__await,
		__asyncGenerator,
		__asyncDelegator,
		__asyncValues,
		__makeTemplateObject,
		__importStar: __importStar$1,
		__importDefault,
		__classPrivateFieldGet,
		__classPrivateFieldSet,
		__classPrivateFieldIn,
		__addDisposableResource,
		__disposeResources,
		__rewriteRelativeImportExtension
	};
}));

//#endregion
//#region node_modules/@smithy/uuid/dist-cjs/randomUUID.js
var require_randomUUID = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.randomUUID = void 0;
	const crypto_1$1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault(__require("crypto"));
	exports.randomUUID = crypto_1$1.default.randomUUID.bind(crypto_1$1.default);
}));

//#endregion
//#region node_modules/@smithy/uuid/dist-cjs/index.js
var require_dist_cjs$36 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var randomUUID = require_randomUUID();
	const decimalToHex = Array.from({ length: 256 }, (_, i$5) => i$5.toString(16).padStart(2, "0"));
	const v4 = () => {
		if (randomUUID.randomUUID) return randomUUID.randomUUID();
		const rnds = new Uint8Array(16);
		crypto.getRandomValues(rnds);
		rnds[6] = rnds[6] & 15 | 64;
		rnds[8] = rnds[8] & 63 | 128;
		return decimalToHex[rnds[0]] + decimalToHex[rnds[1]] + decimalToHex[rnds[2]] + decimalToHex[rnds[3]] + "-" + decimalToHex[rnds[4]] + decimalToHex[rnds[5]] + "-" + decimalToHex[rnds[6]] + decimalToHex[rnds[7]] + "-" + decimalToHex[rnds[8]] + decimalToHex[rnds[9]] + "-" + decimalToHex[rnds[10]] + decimalToHex[rnds[11]] + decimalToHex[rnds[12]] + decimalToHex[rnds[13]] + decimalToHex[rnds[14]] + decimalToHex[rnds[15]];
	};
	exports.v4 = v4;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/generateIdempotencyToken.js
var import_dist_cjs$143;
var init_generateIdempotencyToken = __esmMin((() => {
	import_dist_cjs$143 = require_dist_cjs$36();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/lazy-json.js
var LazyJsonString;
var init_lazy_json = __esmMin((() => {
	LazyJsonString = function LazyJsonString$1(val) {
		return Object.assign(new String(val), {
			deserializeJSON() {
				return JSON.parse(String(val));
			},
			toString() {
				return String(val);
			},
			toJSON() {
				return String(val);
			}
		});
	};
	LazyJsonString.from = (object) => {
		if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) return object;
		else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) return LazyJsonString(String(object));
		return LazyJsonString(JSON.stringify(object));
	};
	LazyJsonString.fromObject = LazyJsonString.from;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/quote-header.js
function quoteHeader(part) {
	if (part.includes(",") || part.includes("\"")) part = `"${part.replace(/"/g, "\\\"")}"`;
	return part;
}
var init_quote_header = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/schema-serde-lib/schema-date-utils.js
function range(v$5, min, max) {
	const _v = Number(v$5);
	if (_v < min || _v > max) throw new Error(`Value ${_v} out of range [${min}, ${max}]`);
}
var ddd, mmm, time, date, year, RFC3339_WITH_OFFSET, IMF_FIXDATE, RFC_850_DATE, ASC_TIME, months, _parseEpochTimestamp, _parseRfc3339DateTimeWithOffset, _parseRfc7231DateTime;
var init_schema_date_utils = __esmMin((() => {
	ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
	mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
	time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
	date = `(\\d?\\d)`;
	year = `(\\d{4})`;
	RFC3339_WITH_OFFSET = /* @__PURE__ */ new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
	IMF_FIXDATE = /* @__PURE__ */ new RegExp(`^${ddd}, ${date} ${mmm} ${year} ${time} GMT$`);
	RFC_850_DATE = /* @__PURE__ */ new RegExp(`^${ddd}, ${date}-${mmm}-(\\d\\d) ${time} GMT$`);
	ASC_TIME = /* @__PURE__ */ new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year}$`);
	months = [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	];
	_parseEpochTimestamp = (value) => {
		if (value == null) return;
		let num = NaN;
		if (typeof value === "number") num = value;
		else if (typeof value === "string") {
			if (!/^-?\d*\.?\d+$/.test(value)) throw new TypeError(`parseEpochTimestamp - numeric string invalid.`);
			num = Number.parseFloat(value);
		} else if (typeof value === "object" && value.tag === 1) num = value.value;
		if (isNaN(num) || Math.abs(num) === Infinity) throw new TypeError("Epoch timestamps must be valid finite numbers.");
		return new Date(Math.round(num * 1e3));
	};
	_parseRfc3339DateTimeWithOffset = (value) => {
		if (value == null) return;
		if (typeof value !== "string") throw new TypeError("RFC3339 timestamps must be strings");
		const matches = RFC3339_WITH_OFFSET.exec(value);
		if (!matches) throw new TypeError(`Invalid RFC3339 timestamp format ${value}`);
		const [, yearStr, monthStr, dayStr, hours, minutes, seconds, , ms, offsetStr] = matches;
		range(monthStr, 1, 12);
		range(dayStr, 1, 31);
		range(hours, 0, 23);
		range(minutes, 0, 59);
		range(seconds, 0, 60);
		const date$1 = new Date(Date.UTC(Number(yearStr), Number(monthStr) - 1, Number(dayStr), Number(hours), Number(minutes), Number(seconds), Number(ms) ? Math.round(parseFloat(`0.${ms}`) * 1e3) : 0));
		date$1.setUTCFullYear(Number(yearStr));
		if (offsetStr.toUpperCase() != "Z") {
			const [, sign, offsetH, offsetM] = /([+-])(\d\d):(\d\d)/.exec(offsetStr) || [
				void 0,
				"+",
				0,
				0
			];
			const scalar = sign === "-" ? 1 : -1;
			date$1.setTime(date$1.getTime() + scalar * (Number(offsetH) * 60 * 60 * 1e3 + Number(offsetM) * 60 * 1e3));
		}
		return date$1;
	};
	_parseRfc7231DateTime = (value) => {
		if (value == null) return;
		if (typeof value !== "string") throw new TypeError("RFC7231 timestamps must be strings.");
		let day;
		let month;
		let year$1;
		let hour;
		let minute;
		let second;
		let fraction;
		let matches;
		if (matches = IMF_FIXDATE.exec(value)) [, day, month, year$1, hour, minute, second, fraction] = matches;
		else if (matches = RFC_850_DATE.exec(value)) {
			[, day, month, year$1, hour, minute, second, fraction] = matches;
			year$1 = (Number(year$1) + 1900).toString();
		} else if (matches = ASC_TIME.exec(value)) [, month, day, hour, minute, second, fraction, year$1] = matches;
		if (year$1 && second) {
			const timestamp = Date.UTC(Number(year$1), months.indexOf(month), Number(day), Number(hour), Number(minute), Number(second), fraction ? Math.round(parseFloat(`0.${fraction}`) * 1e3) : 0);
			range(day, 1, 31);
			range(hour, 0, 23);
			range(minute, 0, 59);
			range(second, 0, 60);
			const date$1 = new Date(timestamp);
			date$1.setUTCFullYear(Number(year$1));
			return date$1;
		}
		throw new TypeError(`Invalid RFC7231 date-time value ${value}.`);
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/split-every.js
function splitEvery(value, delimiter, numDelimiters) {
	if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
	const segments = value.split(delimiter);
	if (numDelimiters === 1) return segments;
	const compoundSegments = [];
	let currentSegment = "";
	for (let i$5 = 0; i$5 < segments.length; i$5++) {
		if (currentSegment === "") currentSegment = segments[i$5];
		else currentSegment += delimiter + segments[i$5];
		if ((i$5 + 1) % numDelimiters === 0) {
			compoundSegments.push(currentSegment);
			currentSegment = "";
		}
	}
	if (currentSegment !== "") compoundSegments.push(currentSegment);
	return compoundSegments;
}
var init_split_every = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/split-header.js
var splitHeader;
var init_split_header = __esmMin((() => {
	splitHeader = (value) => {
		const z$2 = value.length;
		const values = [];
		let withinQuotes = false;
		let prevChar = void 0;
		let anchor = 0;
		for (let i$5 = 0; i$5 < z$2; ++i$5) {
			const char = value[i$5];
			switch (char) {
				case `"`:
					if (prevChar !== "\\") withinQuotes = !withinQuotes;
					break;
				case ",":
					if (!withinQuotes) {
						values.push(value.slice(anchor, i$5));
						anchor = i$5 + 1;
					}
					break;
				default:
			}
			prevChar = char;
		}
		values.push(value.slice(anchor));
		return values.map((v$5) => {
			v$5 = v$5.trim();
			const z$3 = v$5.length;
			if (z$3 < 2) return v$5;
			if (v$5[0] === `"` && v$5[z$3 - 1] === `"`) v$5 = v$5.slice(1, z$3 - 1);
			return v$5.replace(/\\"/g, "\"");
		});
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/value/NumericValue.js
function nv(input) {
	return new NumericValue(String(input), "bigDecimal");
}
var format, NumericValue;
var init_NumericValue = __esmMin((() => {
	format = /^-?\d*(\.\d+)?$/;
	NumericValue = class NumericValue {
		string;
		type;
		constructor(string, type) {
			this.string = string;
			this.type = type;
			if (!format.test(string)) throw new Error(`@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".`);
		}
		toString() {
			return this.string;
		}
		static [Symbol.hasInstance](object) {
			if (!object || typeof object !== "object") return false;
			const _nv = object;
			return NumericValue.prototype.isPrototypeOf(object) || _nv.type === "bigDecimal" && format.test(_nv.string);
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/serde/index.js
var serde_exports = /* @__PURE__ */ __export({
	LazyJsonString: () => LazyJsonString,
	NumericValue: () => NumericValue,
	_parseEpochTimestamp: () => _parseEpochTimestamp,
	_parseRfc3339DateTimeWithOffset: () => _parseRfc3339DateTimeWithOffset,
	_parseRfc7231DateTime: () => _parseRfc7231DateTime,
	copyDocumentWithTransform: () => copyDocumentWithTransform,
	dateToUtcString: () => dateToUtcString$2,
	expectBoolean: () => expectBoolean,
	expectByte: () => expectByte,
	expectFloat32: () => expectFloat32,
	expectInt: () => expectInt,
	expectInt32: () => expectInt32,
	expectLong: () => expectLong,
	expectNonNull: () => expectNonNull,
	expectNumber: () => expectNumber,
	expectObject: () => expectObject,
	expectShort: () => expectShort,
	expectString: () => expectString,
	expectUnion: () => expectUnion$1,
	generateIdempotencyToken: () => import_dist_cjs$143.v4,
	handleFloat: () => handleFloat,
	limitedParseDouble: () => limitedParseDouble,
	limitedParseFloat: () => limitedParseFloat,
	limitedParseFloat32: () => limitedParseFloat32,
	logger: () => logger,
	nv: () => nv,
	parseBoolean: () => parseBoolean,
	parseEpochTimestamp: () => parseEpochTimestamp,
	parseRfc3339DateTime: () => parseRfc3339DateTime,
	parseRfc3339DateTimeWithOffset: () => parseRfc3339DateTimeWithOffset,
	parseRfc7231DateTime: () => parseRfc7231DateTime,
	quoteHeader: () => quoteHeader,
	splitEvery: () => splitEvery,
	splitHeader: () => splitHeader,
	strictParseByte: () => strictParseByte,
	strictParseDouble: () => strictParseDouble,
	strictParseFloat: () => strictParseFloat,
	strictParseFloat32: () => strictParseFloat32,
	strictParseInt: () => strictParseInt,
	strictParseInt32: () => strictParseInt32,
	strictParseLong: () => strictParseLong,
	strictParseShort: () => strictParseShort
});
var init_serde = __esmMin((() => {
	init_copyDocumentWithTransform();
	init_date_utils();
	init_generateIdempotencyToken();
	init_lazy_json();
	init_parse_utils();
	init_quote_header();
	init_schema_date_utils();
	init_split_every();
	init_split_header();
	init_NumericValue();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/SerdeContext.js
var SerdeContext;
var init_SerdeContext = __esmMin((() => {
	SerdeContext = class {
		serdeContext;
		setSerdeContext(serdeContext) {
			this.serdeContext = serdeContext;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/HttpProtocol.js
var import_dist_cjs$142, HttpProtocol;
var init_HttpProtocol = __esmMin((() => {
	init_schema();
	import_dist_cjs$142 = require_dist_cjs$52();
	init_SerdeContext();
	HttpProtocol = class extends SerdeContext {
		options;
		constructor(options) {
			super();
			this.options = options;
		}
		getRequestType() {
			return import_dist_cjs$142.HttpRequest;
		}
		getResponseType() {
			return import_dist_cjs$142.HttpResponse;
		}
		setSerdeContext(serdeContext) {
			this.serdeContext = serdeContext;
			this.serializer.setSerdeContext(serdeContext);
			this.deserializer.setSerdeContext(serdeContext);
			if (this.getPayloadCodec()) this.getPayloadCodec().setSerdeContext(serdeContext);
		}
		updateServiceEndpoint(request$1, endpoint) {
			if ("url" in endpoint) {
				request$1.protocol = endpoint.url.protocol;
				request$1.hostname = endpoint.url.hostname;
				request$1.port = endpoint.url.port ? Number(endpoint.url.port) : void 0;
				request$1.path = endpoint.url.pathname;
				request$1.fragment = endpoint.url.hash || void 0;
				request$1.username = endpoint.url.username || void 0;
				request$1.password = endpoint.url.password || void 0;
				if (!request$1.query) request$1.query = {};
				for (const [k$5, v$5] of endpoint.url.searchParams.entries()) request$1.query[k$5] = v$5;
				return request$1;
			} else {
				request$1.protocol = endpoint.protocol;
				request$1.hostname = endpoint.hostname;
				request$1.port = endpoint.port ? Number(endpoint.port) : void 0;
				request$1.path = endpoint.path;
				request$1.query = { ...endpoint.query };
				return request$1;
			}
		}
		setHostPrefix(request$1, operationSchema, input) {
			const inputNs = NormalizedSchema.of(operationSchema.input);
			const opTraits = translateTraits(operationSchema.traits ?? {});
			if (opTraits.endpoint) {
				let hostPrefix = opTraits.endpoint?.[0];
				if (typeof hostPrefix === "string") {
					const hostLabelInputs = [...inputNs.structIterator()].filter(([, member$1]) => member$1.getMergedTraits().hostLabel);
					for (const [name] of hostLabelInputs) {
						const replacement = input[name];
						if (typeof replacement !== "string") throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);
						hostPrefix = hostPrefix.replace(`{${name}}`, replacement);
					}
					request$1.hostname = hostPrefix + request$1.hostname;
				}
			}
		}
		deserializeMetadata(output) {
			return {
				httpStatusCode: output.statusCode,
				requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
				extendedRequestId: output.headers["x-amz-id-2"],
				cfId: output.headers["x-amz-cf-id"]
			};
		}
		async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
			return (await this.loadEventStreamCapability()).serializeEventStream({
				eventStream,
				requestSchema,
				initialRequest
			});
		}
		async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
			return (await this.loadEventStreamCapability()).deserializeEventStream({
				response,
				responseSchema,
				initialResponseContainer
			});
		}
		async loadEventStreamCapability() {
			const { EventStreamSerde: EventStreamSerde$1 } = await import("./event-streams-Dgq4MyhL.js");
			return new EventStreamSerde$1({
				marshaller: this.getEventStreamMarshaller(),
				serializer: this.serializer,
				deserializer: this.deserializer,
				serdeContext: this.serdeContext,
				defaultContentType: this.getDefaultContentType()
			});
		}
		getDefaultContentType() {
			throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`);
		}
		async deserializeHttpMessage(schema$3, context, response, arg4, arg5) {
			return [];
		}
		getEventStreamMarshaller() {
			const context = this.serdeContext;
			if (!context.eventStreamMarshaller) throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
			return context.eventStreamMarshaller;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/HttpBindingProtocol.js
var import_dist_cjs$140, import_dist_cjs$141, HttpBindingProtocol;
var init_HttpBindingProtocol = __esmMin((() => {
	init_schema();
	init_serde();
	import_dist_cjs$140 = require_dist_cjs$52();
	import_dist_cjs$141 = require_dist_cjs$37();
	init_collect_stream_body();
	init_extended_encode_uri_component();
	init_HttpProtocol();
	HttpBindingProtocol = class extends HttpProtocol {
		async serializeRequest(operationSchema, _input, context) {
			const input = { ..._input ?? {} };
			const serializer = this.serializer;
			const query = {};
			const headers = {};
			const endpoint = await context.endpoint();
			const ns = NormalizedSchema.of(operationSchema?.input);
			const schema$3 = ns.getSchema();
			let hasNonHttpBindingMember = false;
			let payload$1;
			const request$1 = new import_dist_cjs$140.HttpRequest({
				protocol: "",
				hostname: "",
				port: void 0,
				path: "",
				fragment: void 0,
				query,
				headers,
				body: void 0
			});
			if (endpoint) {
				this.updateServiceEndpoint(request$1, endpoint);
				this.setHostPrefix(request$1, operationSchema, input);
				const opTraits = translateTraits(operationSchema.traits);
				if (opTraits.http) {
					request$1.method = opTraits.http[0];
					const [path$6, search] = opTraits.http[1].split("?");
					if (request$1.path == "/") request$1.path = path$6;
					else request$1.path += path$6;
					const traitSearchParams = new URLSearchParams(search ?? "");
					Object.assign(query, Object.fromEntries(traitSearchParams));
				}
			}
			for (const [memberName, memberNs] of ns.structIterator()) {
				const memberTraits = memberNs.getMergedTraits() ?? {};
				const inputMemberValue = input[memberName];
				if (inputMemberValue == null && !memberNs.isIdempotencyToken()) continue;
				if (memberTraits.httpPayload) {
					if (memberNs.isStreaming()) if (memberNs.isStructSchema()) {
						if (input[memberName]) payload$1 = await this.serializeEventStream({
							eventStream: input[memberName],
							requestSchema: ns
						});
					} else payload$1 = inputMemberValue;
					else {
						serializer.write(memberNs, inputMemberValue);
						payload$1 = serializer.flush();
					}
					delete input[memberName];
				} else if (memberTraits.httpLabel) {
					serializer.write(memberNs, inputMemberValue);
					const replacement = serializer.flush();
					if (request$1.path.includes(`{${memberName}+}`)) request$1.path = request$1.path.replace(`{${memberName}+}`, replacement.split("/").map(extendedEncodeURIComponent).join("/"));
					else if (request$1.path.includes(`{${memberName}}`)) request$1.path = request$1.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));
					delete input[memberName];
				} else if (memberTraits.httpHeader) {
					serializer.write(memberNs, inputMemberValue);
					headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());
					delete input[memberName];
				} else if (typeof memberTraits.httpPrefixHeaders === "string") {
					for (const [key, val] of Object.entries(inputMemberValue)) {
						const amalgam = memberTraits.httpPrefixHeaders + key;
						serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);
						headers[amalgam.toLowerCase()] = serializer.flush();
					}
					delete input[memberName];
				} else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {
					this.serializeQuery(memberNs, inputMemberValue, query);
					delete input[memberName];
				} else hasNonHttpBindingMember = true;
			}
			if (hasNonHttpBindingMember && input) {
				serializer.write(schema$3, input);
				payload$1 = serializer.flush();
			}
			request$1.headers = headers;
			request$1.query = query;
			request$1.body = payload$1;
			return request$1;
		}
		serializeQuery(ns, data$1, query) {
			const serializer = this.serializer;
			const traits = ns.getMergedTraits();
			if (traits.httpQueryParams) {
				for (const [key, val] of Object.entries(data$1)) if (!(key in query)) {
					const valueSchema = ns.getValueSchema();
					Object.assign(valueSchema.getMergedTraits(), {
						...traits,
						httpQuery: key,
						httpQueryParams: void 0
					});
					this.serializeQuery(valueSchema, val, query);
				}
				return;
			}
			if (ns.isListSchema()) {
				const sparse = !!ns.getMergedTraits().sparse;
				const buffer$3 = [];
				for (const item of data$1) {
					serializer.write([ns.getValueSchema(), traits], item);
					const serializable = serializer.flush();
					if (sparse || serializable !== void 0) buffer$3.push(serializable);
				}
				query[traits.httpQuery] = buffer$3;
			} else {
				serializer.write([ns, traits], data$1);
				query[traits.httpQuery] = serializer.flush();
			}
		}
		async deserializeResponse(operationSchema, context, response) {
			const deserializer = this.deserializer;
			const ns = NormalizedSchema.of(operationSchema.output);
			const dataObject = {};
			if (response.statusCode >= 300) {
				const bytes = await collectBody(response.body, context);
				if (bytes.byteLength > 0) Object.assign(dataObject, await deserializer.read(15, bytes));
				await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
				throw new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.");
			}
			for (const header in response.headers) {
				const value = response.headers[header];
				delete response.headers[header];
				response.headers[header.toLowerCase()] = value;
			}
			const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);
			if (nonHttpBindingMembers.length) {
				const bytes = await collectBody(response.body, context);
				if (bytes.byteLength > 0) {
					const dataFromBody = await deserializer.read(ns, bytes);
					for (const member$1 of nonHttpBindingMembers) dataObject[member$1] = dataFromBody[member$1];
				}
			} else if (nonHttpBindingMembers.discardResponseBody) await collectBody(response.body, context);
			dataObject.$metadata = this.deserializeMetadata(response);
			return dataObject;
		}
		async deserializeHttpMessage(schema$3, context, response, arg4, arg5) {
			let dataObject;
			if (arg4 instanceof Set) dataObject = arg5;
			else dataObject = arg4;
			let discardResponseBody = true;
			const deserializer = this.deserializer;
			const ns = NormalizedSchema.of(schema$3);
			const nonHttpBindingMembers = [];
			for (const [memberName, memberSchema] of ns.structIterator()) {
				const memberTraits = memberSchema.getMemberTraits();
				if (memberTraits.httpPayload) {
					discardResponseBody = false;
					if (memberSchema.isStreaming()) if (memberSchema.isStructSchema()) dataObject[memberName] = await this.deserializeEventStream({
						response,
						responseSchema: ns
					});
					else dataObject[memberName] = (0, import_dist_cjs$141.sdkStreamMixin)(response.body);
					else if (response.body) {
						const bytes = await collectBody(response.body, context);
						if (bytes.byteLength > 0) dataObject[memberName] = await deserializer.read(memberSchema, bytes);
					}
				} else if (memberTraits.httpHeader) {
					const key = String(memberTraits.httpHeader).toLowerCase();
					const value = response.headers[key];
					if (null != value) if (memberSchema.isListSchema()) {
						const headerListValueSchema = memberSchema.getValueSchema();
						headerListValueSchema.getMergedTraits().httpHeader = key;
						let sections;
						if (headerListValueSchema.isTimestampSchema() && headerListValueSchema.getSchema() === 4) sections = splitEvery(value, ",", 2);
						else sections = splitHeader(value);
						const list$1 = [];
						for (const section of sections) list$1.push(await deserializer.read(headerListValueSchema, section.trim()));
						dataObject[memberName] = list$1;
					} else dataObject[memberName] = await deserializer.read(memberSchema, value);
				} else if (memberTraits.httpPrefixHeaders !== void 0) {
					dataObject[memberName] = {};
					for (const [header, value] of Object.entries(response.headers)) if (header.startsWith(memberTraits.httpPrefixHeaders)) {
						const valueSchema = memberSchema.getValueSchema();
						valueSchema.getMergedTraits().httpHeader = header;
						dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);
					}
				} else if (memberTraits.httpResponseCode) dataObject[memberName] = response.statusCode;
				else nonHttpBindingMembers.push(memberName);
			}
			nonHttpBindingMembers.discardResponseBody = discardResponseBody;
			return nonHttpBindingMembers;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/RpcProtocol.js
var import_dist_cjs$139, RpcProtocol;
var init_RpcProtocol = __esmMin((() => {
	init_schema();
	import_dist_cjs$139 = require_dist_cjs$52();
	init_collect_stream_body();
	init_HttpProtocol();
	RpcProtocol = class extends HttpProtocol {
		async serializeRequest(operationSchema, input, context) {
			const serializer = this.serializer;
			const query = {};
			const headers = {};
			const endpoint = await context.endpoint();
			const ns = NormalizedSchema.of(operationSchema?.input);
			const schema$3 = ns.getSchema();
			let payload$1;
			const request$1 = new import_dist_cjs$139.HttpRequest({
				protocol: "",
				hostname: "",
				port: void 0,
				path: "/",
				fragment: void 0,
				query,
				headers,
				body: void 0
			});
			if (endpoint) {
				this.updateServiceEndpoint(request$1, endpoint);
				this.setHostPrefix(request$1, operationSchema, input);
			}
			const _input = { ...input };
			if (input) {
				const eventStreamMember = ns.getEventStreamMember();
				if (eventStreamMember) {
					if (_input[eventStreamMember]) {
						const initialRequest = {};
						for (const [memberName, memberSchema] of ns.structIterator()) if (memberName !== eventStreamMember && _input[memberName]) {
							serializer.write(memberSchema, _input[memberName]);
							initialRequest[memberName] = serializer.flush();
						}
						payload$1 = await this.serializeEventStream({
							eventStream: _input[eventStreamMember],
							requestSchema: ns,
							initialRequest
						});
					}
				} else {
					serializer.write(schema$3, _input);
					payload$1 = serializer.flush();
				}
			}
			request$1.headers = headers;
			request$1.query = query;
			request$1.body = payload$1;
			request$1.method = "POST";
			return request$1;
		}
		async deserializeResponse(operationSchema, context, response) {
			const deserializer = this.deserializer;
			const ns = NormalizedSchema.of(operationSchema.output);
			const dataObject = {};
			if (response.statusCode >= 300) {
				const bytes = await collectBody(response.body, context);
				if (bytes.byteLength > 0) Object.assign(dataObject, await deserializer.read(15, bytes));
				await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
				throw new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.");
			}
			for (const header in response.headers) {
				const value = response.headers[header];
				delete response.headers[header];
				response.headers[header.toLowerCase()] = value;
			}
			const eventStreamMember = ns.getEventStreamMember();
			if (eventStreamMember) dataObject[eventStreamMember] = await this.deserializeEventStream({
				response,
				responseSchema: ns,
				initialResponseContainer: dataObject
			});
			else {
				const bytes = await collectBody(response.body, context);
				if (bytes.byteLength > 0) Object.assign(dataObject, await deserializer.read(ns, bytes));
			}
			dataObject.$metadata = this.deserializeMetadata(response);
			return dataObject;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/resolve-path.js
var resolvedPath;
var init_resolve_path = __esmMin((() => {
	init_extended_encode_uri_component();
	resolvedPath = (resolvedPath$1, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
		if (input != null && input[memberName] !== void 0) {
			const labelValue = labelValueProvider();
			if (labelValue.length <= 0) throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
			resolvedPath$1 = resolvedPath$1.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment) => extendedEncodeURIComponent(segment)).join("/") : extendedEncodeURIComponent(labelValue));
		} else throw new Error("No value provided for input HTTP label: " + memberName + ".");
		return resolvedPath$1;
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/requestBuilder.js
function requestBuilder(input, context) {
	return new RequestBuilder(input, context);
}
var import_dist_cjs$138, RequestBuilder;
var init_requestBuilder$1 = __esmMin((() => {
	import_dist_cjs$138 = require_dist_cjs$52();
	init_resolve_path();
	RequestBuilder = class {
		input;
		context;
		query = {};
		method = "";
		headers = {};
		path = "";
		body = null;
		hostname = "";
		resolvePathStack = [];
		constructor(input, context) {
			this.input = input;
			this.context = context;
		}
		async build() {
			const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
			this.path = basePath;
			for (const resolvePath of this.resolvePathStack) resolvePath(this.path);
			return new import_dist_cjs$138.HttpRequest({
				protocol,
				hostname: this.hostname || hostname,
				port,
				method: this.method,
				path: this.path,
				query: this.query,
				body: this.body,
				headers: this.headers
			});
		}
		hn(hostname) {
			this.hostname = hostname;
			return this;
		}
		bp(uriLabel) {
			this.resolvePathStack.push((basePath) => {
				this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
			});
			return this;
		}
		p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
			this.resolvePathStack.push((path$6) => {
				this.path = resolvedPath(path$6, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
			});
			return this;
		}
		h(headers) {
			this.headers = headers;
			return this;
		}
		q(query) {
			this.query = query;
			return this;
		}
		b(body) {
			this.body = body;
			return this;
		}
		m(method) {
			this.method = method;
			return this;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/serde/determineTimestampFormat.js
function determineTimestampFormat(ns, settings) {
	if (settings.timestampFormat.useTrait) {
		if (ns.isTimestampSchema() && (ns.getSchema() === 5 || ns.getSchema() === 6 || ns.getSchema() === 7)) return ns.getSchema();
	}
	const { httpLabel, httpPrefixHeaders, httpHeader, httpQuery } = ns.getMergedTraits();
	return (settings.httpBindings ? typeof httpPrefixHeaders === "string" || Boolean(httpHeader) ? 6 : Boolean(httpQuery) || Boolean(httpLabel) ? 5 : void 0 : void 0) ?? settings.timestampFormat.default;
}
var init_determineTimestampFormat = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/serde/FromStringShapeDeserializer.js
var import_dist_cjs$136, import_dist_cjs$137, FromStringShapeDeserializer;
var init_FromStringShapeDeserializer = __esmMin((() => {
	init_schema();
	init_serde();
	import_dist_cjs$136 = require_dist_cjs$43();
	import_dist_cjs$137 = require_dist_cjs$44();
	init_SerdeContext();
	init_determineTimestampFormat();
	FromStringShapeDeserializer = class extends SerdeContext {
		settings;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		read(_schema, data$1) {
			const ns = NormalizedSchema.of(_schema);
			if (ns.isListSchema()) return splitHeader(data$1).map((item) => this.read(ns.getValueSchema(), item));
			if (ns.isBlobSchema()) return (this.serdeContext?.base64Decoder ?? import_dist_cjs$136.fromBase64)(data$1);
			if (ns.isTimestampSchema()) switch (determineTimestampFormat(ns, this.settings)) {
				case 5: return _parseRfc3339DateTimeWithOffset(data$1);
				case 6: return _parseRfc7231DateTime(data$1);
				case 7: return _parseEpochTimestamp(data$1);
				default:
					console.warn("Missing timestamp format, parsing value with Date constructor:", data$1);
					return new Date(data$1);
			}
			if (ns.isStringSchema()) {
				const mediaType = ns.getMergedTraits().mediaType;
				let intermediateValue = data$1;
				if (mediaType) {
					if (ns.getMergedTraits().httpHeader) intermediateValue = this.base64ToUtf8(intermediateValue);
					if (mediaType === "application/json" || mediaType.endsWith("+json")) intermediateValue = LazyJsonString.from(intermediateValue);
					return intermediateValue;
				}
			}
			if (ns.isNumericSchema()) return Number(data$1);
			if (ns.isBigIntegerSchema()) return BigInt(data$1);
			if (ns.isBigDecimalSchema()) return new NumericValue(data$1, "bigDecimal");
			if (ns.isBooleanSchema()) return String(data$1).toLowerCase() === "true";
			return data$1;
		}
		base64ToUtf8(base64String) {
			return (this.serdeContext?.utf8Encoder ?? import_dist_cjs$137.toUtf8)((this.serdeContext?.base64Decoder ?? import_dist_cjs$136.fromBase64)(base64String));
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeDeserializer.js
var import_dist_cjs$135, HttpInterceptingShapeDeserializer;
var init_HttpInterceptingShapeDeserializer = __esmMin((() => {
	init_schema();
	import_dist_cjs$135 = require_dist_cjs$44();
	init_SerdeContext();
	init_FromStringShapeDeserializer();
	HttpInterceptingShapeDeserializer = class extends SerdeContext {
		codecDeserializer;
		stringDeserializer;
		constructor(codecDeserializer, codecSettings) {
			super();
			this.codecDeserializer = codecDeserializer;
			this.stringDeserializer = new FromStringShapeDeserializer(codecSettings);
		}
		setSerdeContext(serdeContext) {
			this.stringDeserializer.setSerdeContext(serdeContext);
			this.codecDeserializer.setSerdeContext(serdeContext);
			this.serdeContext = serdeContext;
		}
		read(schema$3, data$1) {
			const ns = NormalizedSchema.of(schema$3);
			const traits = ns.getMergedTraits();
			const toString = this.serdeContext?.utf8Encoder ?? import_dist_cjs$135.toUtf8;
			if (traits.httpHeader || traits.httpResponseCode) return this.stringDeserializer.read(ns, toString(data$1));
			if (traits.httpPayload) {
				if (ns.isBlobSchema()) {
					const toBytes = this.serdeContext?.utf8Decoder ?? import_dist_cjs$135.fromUtf8;
					if (typeof data$1 === "string") return toBytes(data$1);
					return data$1;
				} else if (ns.isStringSchema()) {
					if ("byteLength" in data$1) return toString(data$1);
					return data$1;
				}
			}
			return this.codecDeserializer.read(ns, data$1);
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/serde/ToStringShapeSerializer.js
var import_dist_cjs$134, ToStringShapeSerializer;
var init_ToStringShapeSerializer = __esmMin((() => {
	init_schema();
	init_serde();
	import_dist_cjs$134 = require_dist_cjs$43();
	init_SerdeContext();
	init_determineTimestampFormat();
	ToStringShapeSerializer = class extends SerdeContext {
		settings;
		stringBuffer = "";
		constructor(settings) {
			super();
			this.settings = settings;
		}
		write(schema$3, value) {
			const ns = NormalizedSchema.of(schema$3);
			switch (typeof value) {
				case "object":
					if (value === null) {
						this.stringBuffer = "null";
						return;
					}
					if (ns.isTimestampSchema()) {
						if (!(value instanceof Date)) throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);
						switch (determineTimestampFormat(ns, this.settings)) {
							case 5:
								this.stringBuffer = value.toISOString().replace(".000Z", "Z");
								break;
							case 6:
								this.stringBuffer = dateToUtcString$2(value);
								break;
							case 7:
								this.stringBuffer = String(value.getTime() / 1e3);
								break;
							default:
								console.warn("Missing timestamp format, using epoch seconds", value);
								this.stringBuffer = String(value.getTime() / 1e3);
						}
						return;
					}
					if (ns.isBlobSchema() && "byteLength" in value) {
						this.stringBuffer = (this.serdeContext?.base64Encoder ?? import_dist_cjs$134.toBase64)(value);
						return;
					}
					if (ns.isListSchema() && Array.isArray(value)) {
						let buffer$3 = "";
						for (const item of value) {
							this.write([ns.getValueSchema(), ns.getMergedTraits()], item);
							const headerItem = this.flush();
							const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : quoteHeader(headerItem);
							if (buffer$3 !== "") buffer$3 += ", ";
							buffer$3 += serialized;
						}
						this.stringBuffer = buffer$3;
						return;
					}
					this.stringBuffer = JSON.stringify(value, null, 2);
					break;
				case "string":
					const mediaType = ns.getMergedTraits().mediaType;
					let intermediateValue = value;
					if (mediaType) {
						if (mediaType === "application/json" || mediaType.endsWith("+json")) intermediateValue = LazyJsonString.from(intermediateValue);
						if (ns.getMergedTraits().httpHeader) {
							this.stringBuffer = (this.serdeContext?.base64Encoder ?? import_dist_cjs$134.toBase64)(intermediateValue.toString());
							return;
						}
					}
					this.stringBuffer = value;
					break;
				default: if (ns.isIdempotencyToken()) this.stringBuffer = (0, import_dist_cjs$143.v4)();
				else this.stringBuffer = String(value);
			}
		}
		flush() {
			const buffer$3 = this.stringBuffer;
			this.stringBuffer = "";
			return buffer$3;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/serde/HttpInterceptingShapeSerializer.js
var HttpInterceptingShapeSerializer;
var init_HttpInterceptingShapeSerializer = __esmMin((() => {
	init_schema();
	init_ToStringShapeSerializer();
	HttpInterceptingShapeSerializer = class {
		codecSerializer;
		stringSerializer;
		buffer;
		constructor(codecSerializer, codecSettings, stringSerializer = new ToStringShapeSerializer(codecSettings)) {
			this.codecSerializer = codecSerializer;
			this.stringSerializer = stringSerializer;
		}
		setSerdeContext(serdeContext) {
			this.codecSerializer.setSerdeContext(serdeContext);
			this.stringSerializer.setSerdeContext(serdeContext);
		}
		write(schema$3, value) {
			const ns = NormalizedSchema.of(schema$3);
			const traits = ns.getMergedTraits();
			if (traits.httpHeader || traits.httpLabel || traits.httpQuery) {
				this.stringSerializer.write(ns, value);
				this.buffer = this.stringSerializer.flush();
				return;
			}
			return this.codecSerializer.write(ns, value);
		}
		flush() {
			if (this.buffer !== void 0) {
				const buffer$3 = this.buffer;
				this.buffer = void 0;
				return buffer$3;
			}
			return this.codecSerializer.flush();
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/protocols/index.js
var protocols_exports$1 = /* @__PURE__ */ __export({
	FromStringShapeDeserializer: () => FromStringShapeDeserializer,
	HttpBindingProtocol: () => HttpBindingProtocol,
	HttpInterceptingShapeDeserializer: () => HttpInterceptingShapeDeserializer,
	HttpInterceptingShapeSerializer: () => HttpInterceptingShapeSerializer,
	HttpProtocol: () => HttpProtocol,
	RequestBuilder: () => RequestBuilder,
	RpcProtocol: () => RpcProtocol,
	SerdeContext: () => SerdeContext,
	ToStringShapeSerializer: () => ToStringShapeSerializer,
	collectBody: () => collectBody,
	determineTimestampFormat: () => determineTimestampFormat,
	extendedEncodeURIComponent: () => extendedEncodeURIComponent,
	requestBuilder: () => requestBuilder,
	resolvedPath: () => resolvedPath
});
var init_protocols$1 = __esmMin((() => {
	init_collect_stream_body();
	init_extended_encode_uri_component();
	init_HttpBindingProtocol();
	init_HttpProtocol();
	init_RpcProtocol();
	init_requestBuilder$1();
	init_resolve_path();
	init_FromStringShapeDeserializer();
	init_HttpInterceptingShapeDeserializer();
	init_HttpInterceptingShapeSerializer();
	init_ToStringShapeSerializer();
	init_determineTimestampFormat();
	init_SerdeContext();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/request-builder/requestBuilder.js
var init_requestBuilder = __esmMin((() => {
	init_protocols$1();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/setFeature.js
function setFeature$1(context, feature, value) {
	if (!context.__smithy_context) context.__smithy_context = { features: {} };
	else if (!context.__smithy_context.features) context.__smithy_context.features = {};
	context.__smithy_context.features[feature] = value;
}
var init_setFeature$1 = __esmMin((() => {}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/DefaultIdentityProviderConfig.js
var DefaultIdentityProviderConfig;
var init_DefaultIdentityProviderConfig = __esmMin((() => {
	DefaultIdentityProviderConfig = class {
		authSchemes = /* @__PURE__ */ new Map();
		constructor(config) {
			for (const [key, value] of Object.entries(config)) if (value !== void 0) this.authSchemes.set(key, value);
		}
		getIdentityProvider(schemeId) {
			return this.authSchemes.get(schemeId);
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpApiKeyAuth.js
var import_dist_cjs$132, import_dist_cjs$133, HttpApiKeyAuthSigner;
var init_httpApiKeyAuth = __esmMin((() => {
	import_dist_cjs$132 = require_dist_cjs$52();
	import_dist_cjs$133 = require_dist_cjs$53();
	HttpApiKeyAuthSigner = class {
		async sign(httpRequest$1, identity, signingProperties) {
			if (!signingProperties) throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
			if (!signingProperties.name) throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
			if (!signingProperties.in) throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
			if (!identity.apiKey) throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
			const clonedRequest = import_dist_cjs$132.HttpRequest.clone(httpRequest$1);
			if (signingProperties.in === import_dist_cjs$133.HttpApiKeyAuthLocation.QUERY) clonedRequest.query[signingProperties.name] = identity.apiKey;
			else if (signingProperties.in === import_dist_cjs$133.HttpApiKeyAuthLocation.HEADER) clonedRequest.headers[signingProperties.name] = signingProperties.scheme ? `${signingProperties.scheme} ${identity.apiKey}` : identity.apiKey;
			else throw new Error("request can only be signed with `apiKey` locations `query` or `header`, but found: `" + signingProperties.in + "`");
			return clonedRequest;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/httpBearerAuth.js
var import_dist_cjs$131, HttpBearerAuthSigner;
var init_httpBearerAuth = __esmMin((() => {
	import_dist_cjs$131 = require_dist_cjs$52();
	HttpBearerAuthSigner = class {
		async sign(httpRequest$1, identity, signingProperties) {
			const clonedRequest = import_dist_cjs$131.HttpRequest.clone(httpRequest$1);
			if (!identity.token) throw new Error("request could not be signed with `token` since the `token` is not defined");
			clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
			return clonedRequest;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/noAuth.js
var NoAuthSigner;
var init_noAuth = __esmMin((() => {
	NoAuthSigner = class {
		async sign(httpRequest$1, identity, signingProperties) {
			return httpRequest$1;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/httpAuthSchemes/index.js
var init_httpAuthSchemes$1 = __esmMin((() => {
	init_httpApiKeyAuth();
	init_httpBearerAuth();
	init_noAuth();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/memoizeIdentityProvider.js
var createIsIdentityExpiredFunction, EXPIRATION_MS, isIdentityExpired, doesIdentityRequireRefresh, memoizeIdentityProvider;
var init_memoizeIdentityProvider = __esmMin((() => {
	createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired$1(identity) {
		return doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
	};
	EXPIRATION_MS = 3e5;
	isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
	doesIdentityRequireRefresh = (identity) => identity.expiration !== void 0;
	memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
		if (provider === void 0) return;
		const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
		let resolved;
		let pending;
		let hasResult;
		let isConstant = false;
		const coalesceProvider = async (options) => {
			if (!pending) pending = normalizedProvider(options);
			try {
				resolved = await pending;
				hasResult = true;
				isConstant = false;
			} finally {
				pending = void 0;
			}
			return resolved;
		};
		if (isExpired === void 0) return async (options) => {
			if (!hasResult || options?.forceRefresh) resolved = await coalesceProvider(options);
			return resolved;
		};
		return async (options) => {
			if (!hasResult || options?.forceRefresh) resolved = await coalesceProvider(options);
			if (isConstant) return resolved;
			if (!requiresRefresh(resolved)) {
				isConstant = true;
				return resolved;
			}
			if (isExpired(resolved)) {
				await coalesceProvider(options);
				return resolved;
			}
			return resolved;
		};
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/util-identity-and-auth/index.js
var init_util_identity_and_auth = __esmMin((() => {
	init_DefaultIdentityProviderConfig();
	init_httpAuthSchemes$1();
	init_memoizeIdentityProvider();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/index.js
var dist_es_exports$1 = /* @__PURE__ */ __export({
	DefaultIdentityProviderConfig: () => DefaultIdentityProviderConfig,
	EXPIRATION_MS: () => EXPIRATION_MS,
	HttpApiKeyAuthSigner: () => HttpApiKeyAuthSigner,
	HttpBearerAuthSigner: () => HttpBearerAuthSigner,
	NoAuthSigner: () => NoAuthSigner,
	createIsIdentityExpiredFunction: () => createIsIdentityExpiredFunction,
	createPaginator: () => createPaginator,
	doesIdentityRequireRefresh: () => doesIdentityRequireRefresh,
	getHttpAuthSchemeEndpointRuleSetPlugin: () => getHttpAuthSchemeEndpointRuleSetPlugin,
	getHttpAuthSchemePlugin: () => getHttpAuthSchemePlugin,
	getHttpSigningPlugin: () => getHttpSigningPlugin,
	getSmithyContext: () => getSmithyContext$9,
	httpAuthSchemeEndpointRuleSetMiddlewareOptions: () => httpAuthSchemeEndpointRuleSetMiddlewareOptions,
	httpAuthSchemeMiddleware: () => httpAuthSchemeMiddleware,
	httpAuthSchemeMiddlewareOptions: () => httpAuthSchemeMiddlewareOptions,
	httpSigningMiddleware: () => httpSigningMiddleware,
	httpSigningMiddlewareOptions: () => httpSigningMiddlewareOptions,
	isIdentityExpired: () => isIdentityExpired,
	memoizeIdentityProvider: () => memoizeIdentityProvider,
	normalizeProvider: () => normalizeProvider$3,
	requestBuilder: () => requestBuilder,
	setFeature: () => setFeature$1
});
var init_dist_es$1 = __esmMin((() => {
	init_getSmithyContext();
	init_middleware_http_auth_scheme();
	init_middleware_http_signing();
	init_normalizeProvider();
	init_createPaginator();
	init_requestBuilder();
	init_setFeature$1();
	init_util_identity_and_auth();
}));

//#endregion
//#region node_modules/@smithy/util-endpoints/dist-cjs/index.js
var require_dist_cjs$35 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var types$2 = require_dist_cjs$53();
	var EndpointCache$3 = class {
		capacity;
		data = /* @__PURE__ */ new Map();
		parameters = [];
		constructor({ size, params }) {
			this.capacity = size ?? 50;
			if (params) this.parameters = params;
		}
		get(endpointParams, resolver) {
			const key = this.hash(endpointParams);
			if (key === false) return resolver();
			if (!this.data.has(key)) {
				if (this.data.size > this.capacity + 10) {
					const keys = this.data.keys();
					let i$5 = 0;
					while (true) {
						const { value, done } = keys.next();
						this.data.delete(value);
						if (done || ++i$5 > 10) break;
					}
				}
				this.data.set(key, resolver());
			}
			return this.data.get(key);
		}
		size() {
			return this.data.size;
		}
		hash(endpointParams) {
			let buffer$3 = "";
			const { parameters } = this;
			if (parameters.length === 0) return false;
			for (const param of parameters) {
				const val = String(endpointParams[param] ?? "");
				if (val.includes("|;")) return false;
				buffer$3 += val + "|;";
			}
			return buffer$3;
		}
	};
	const IP_V4_REGEX = /* @__PURE__ */ new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
	const isIpAddress = (value) => IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
	const VALID_HOST_LABEL_REGEX = /* @__PURE__ */ new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
	const isValidHostLabel = (value, allowSubDomains = false) => {
		if (!allowSubDomains) return VALID_HOST_LABEL_REGEX.test(value);
		const labels = value.split(".");
		for (const label of labels) if (!isValidHostLabel(label)) return false;
		return true;
	};
	const customEndpointFunctions$3 = {};
	const debugId = "endpoints";
	function toDebugString(input) {
		if (typeof input !== "object" || input == null) return input;
		if ("ref" in input) return `$${toDebugString(input.ref)}`;
		if ("fn" in input) return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
		return JSON.stringify(input, null, 2);
	}
	var EndpointError = class extends Error {
		constructor(message) {
			super(message);
			this.name = "EndpointError";
		}
	};
	const booleanEquals = (value1, value2) => value1 === value2;
	const getAttrPathList = (path$6) => {
		const parts = path$6.split(".");
		const pathList = [];
		for (const part of parts) {
			const squareBracketIndex = part.indexOf("[");
			if (squareBracketIndex !== -1) {
				if (part.indexOf("]") !== part.length - 1) throw new EndpointError(`Path: '${path$6}' does not end with ']'`);
				const arrayIndex = part.slice(squareBracketIndex + 1, -1);
				if (Number.isNaN(parseInt(arrayIndex))) throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path$6}'`);
				if (squareBracketIndex !== 0) pathList.push(part.slice(0, squareBracketIndex));
				pathList.push(arrayIndex);
			} else pathList.push(part);
		}
		return pathList;
	};
	const getAttr = (value, path$6) => getAttrPathList(path$6).reduce((acc, index) => {
		if (typeof acc !== "object") throw new EndpointError(`Index '${index}' in '${path$6}' not found in '${JSON.stringify(value)}'`);
		else if (Array.isArray(acc)) return acc[parseInt(index)];
		return acc[index];
	}, value);
	const isSet = (value) => value != null;
	const not = (value) => !value;
	const DEFAULT_PORTS = {
		[types$2.EndpointURLScheme.HTTP]: 80,
		[types$2.EndpointURLScheme.HTTPS]: 443
	};
	const parseURL = (value) => {
		const whatwgURL = (() => {
			try {
				if (value instanceof URL) return value;
				if (typeof value === "object" && "hostname" in value) {
					const { hostname: hostname$1, port, protocol: protocol$1 = "", path: path$6 = "", query = {} } = value;
					const url$1 = new URL(`${protocol$1}//${hostname$1}${port ? `:${port}` : ""}${path$6}`);
					url$1.search = Object.entries(query).map(([k$5, v$5]) => `${k$5}=${v$5}`).join("&");
					return url$1;
				}
				return new URL(value);
			} catch (error$2) {
				return null;
			}
		})();
		if (!whatwgURL) {
			console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
			return null;
		}
		const urlString = whatwgURL.href;
		const { host, hostname, pathname, protocol, search } = whatwgURL;
		if (search) return null;
		const scheme = protocol.slice(0, -1);
		if (!Object.values(types$2.EndpointURLScheme).includes(scheme)) return null;
		const isIp = isIpAddress(hostname);
		return {
			scheme,
			authority: `${host}${urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ? `:${DEFAULT_PORTS[scheme]}` : ``}`,
			path: pathname,
			normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
			isIp
		};
	};
	const stringEquals = (value1, value2) => value1 === value2;
	const substring = (input, start, stop, reverse) => {
		if (start >= stop || input.length < stop) return null;
		if (!reverse) return input.substring(start, stop);
		return input.substring(input.length - stop, input.length - start);
	};
	const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c$5) => `%${c$5.charCodeAt(0).toString(16).toUpperCase()}`);
	const endpointFunctions = {
		booleanEquals,
		getAttr,
		isSet,
		isValidHostLabel,
		not,
		parseURL,
		stringEquals,
		substring,
		uriEncode
	};
	const evaluateTemplate = (template, options) => {
		const evaluatedTemplateArr = [];
		const templateContext = {
			...options.endpointParams,
			...options.referenceRecord
		};
		let currentIndex = 0;
		while (currentIndex < template.length) {
			const openingBraceIndex = template.indexOf("{", currentIndex);
			if (openingBraceIndex === -1) {
				evaluatedTemplateArr.push(template.slice(currentIndex));
				break;
			}
			evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
			const closingBraceIndex = template.indexOf("}", openingBraceIndex);
			if (closingBraceIndex === -1) {
				evaluatedTemplateArr.push(template.slice(openingBraceIndex));
				break;
			}
			if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
				evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
				currentIndex = closingBraceIndex + 2;
			}
			const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
			if (parameterName.includes("#")) {
				const [refName, attrName] = parameterName.split("#");
				evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
			} else evaluatedTemplateArr.push(templateContext[parameterName]);
			currentIndex = closingBraceIndex + 1;
		}
		return evaluatedTemplateArr.join("");
	};
	const getReferenceValue = ({ ref }, options) => {
		return {
			...options.endpointParams,
			...options.referenceRecord
		}[ref];
	};
	const evaluateExpression = (obj, keyName, options) => {
		if (typeof obj === "string") return evaluateTemplate(obj, options);
		else if (obj["fn"]) return group$2.callFunction(obj, options);
		else if (obj["ref"]) return getReferenceValue(obj, options);
		throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
	};
	const callFunction = ({ fn, argv }, options) => {
		const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group$2.evaluateExpression(arg, "arg", options));
		const fnSegments = fn.split(".");
		if (fnSegments[0] in customEndpointFunctions$3 && fnSegments[1] != null) return customEndpointFunctions$3[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
		return endpointFunctions[fn](...evaluatedArgs);
	};
	const group$2 = {
		evaluateExpression,
		callFunction
	};
	const evaluateCondition = ({ assign, ...fnArgs }, options) => {
		if (assign && assign in options.referenceRecord) throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
		const value = callFunction(fnArgs, options);
		options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
		return {
			result: value === "" ? true : !!value,
			...assign != null && { toAssign: {
				name: assign,
				value
			} }
		};
	};
	const evaluateConditions = (conditions = [], options) => {
		const conditionsReferenceRecord = {};
		for (const condition of conditions) {
			const { result, toAssign } = evaluateCondition(condition, {
				...options,
				referenceRecord: {
					...options.referenceRecord,
					...conditionsReferenceRecord
				}
			});
			if (!result) return { result };
			if (toAssign) {
				conditionsReferenceRecord[toAssign.name] = toAssign.value;
				options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
			}
		}
		return {
			result: true,
			referenceRecord: conditionsReferenceRecord
		};
	};
	const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
		...acc,
		[headerKey]: headerVal.map((headerValEntry) => {
			const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
			if (typeof processedExpr !== "string") throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
			return processedExpr;
		})
	}), {});
	const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
		...acc,
		[propertyKey]: group$1.getEndpointProperty(propertyVal, options)
	}), {});
	const getEndpointProperty = (property, options) => {
		if (Array.isArray(property)) return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
		switch (typeof property) {
			case "string": return evaluateTemplate(property, options);
			case "object":
				if (property === null) throw new EndpointError(`Unexpected endpoint property: ${property}`);
				return group$1.getEndpointProperties(property, options);
			case "boolean": return property;
			default: throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
		}
	};
	const group$1 = {
		getEndpointProperty,
		getEndpointProperties
	};
	const getEndpointUrl = (endpointUrl, options) => {
		const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
		if (typeof expression === "string") try {
			return new URL(expression);
		} catch (error$2) {
			console.error(`Failed to construct URL with ${expression}`, error$2);
			throw error$2;
		}
		throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
	};
	const evaluateEndpointRule = (endpointRule, options) => {
		const { conditions, endpoint } = endpointRule;
		const { result, referenceRecord } = evaluateConditions(conditions, options);
		if (!result) return;
		const endpointRuleOptions = {
			...options,
			referenceRecord: {
				...options.referenceRecord,
				...referenceRecord
			}
		};
		const { url: url$1, properties, headers } = endpoint;
		options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
		return {
			...headers != void 0 && { headers: getEndpointHeaders(headers, endpointRuleOptions) },
			...properties != void 0 && { properties: getEndpointProperties(properties, endpointRuleOptions) },
			url: getEndpointUrl(url$1, endpointRuleOptions)
		};
	};
	const evaluateErrorRule = (errorRule, options) => {
		const { conditions, error: error$2 } = errorRule;
		const { result, referenceRecord } = evaluateConditions(conditions, options);
		if (!result) return;
		throw new EndpointError(evaluateExpression(error$2, "Error", {
			...options,
			referenceRecord: {
				...options.referenceRecord,
				...referenceRecord
			}
		}));
	};
	const evaluateRules = (rules, options) => {
		for (const rule of rules) if (rule.type === "endpoint") {
			const endpointOrUndefined = evaluateEndpointRule(rule, options);
			if (endpointOrUndefined) return endpointOrUndefined;
		} else if (rule.type === "error") evaluateErrorRule(rule, options);
		else if (rule.type === "tree") {
			const endpointOrUndefined = group.evaluateTreeRule(rule, options);
			if (endpointOrUndefined) return endpointOrUndefined;
		} else throw new EndpointError(`Unknown endpoint rule: ${rule}`);
		throw new EndpointError(`Rules evaluation failed`);
	};
	const evaluateTreeRule = (treeRule, options) => {
		const { conditions, rules } = treeRule;
		const { result, referenceRecord } = evaluateConditions(conditions, options);
		if (!result) return;
		return group.evaluateRules(rules, {
			...options,
			referenceRecord: {
				...options.referenceRecord,
				...referenceRecord
			}
		});
	};
	const group = {
		evaluateRules,
		evaluateTreeRule
	};
	const resolveEndpoint$3 = (ruleSetObject, options) => {
		const { endpointParams, logger: logger$1 } = options;
		const { parameters, rules } = ruleSetObject;
		options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
		const paramsWithDefault = Object.entries(parameters).filter(([, v$5]) => v$5.default != null).map(([k$5, v$5]) => [k$5, v$5.default]);
		if (paramsWithDefault.length > 0) for (const [paramKey, paramDefaultValue] of paramsWithDefault) endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
		const requiredParams = Object.entries(parameters).filter(([, v$5]) => v$5.required).map(([k$5]) => k$5);
		for (const requiredParam of requiredParams) if (endpointParams[requiredParam] == null) throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
		const endpoint = evaluateRules(rules, {
			endpointParams,
			logger: logger$1,
			referenceRecord: {}
		});
		options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
		return endpoint;
	};
	exports.EndpointCache = EndpointCache$3;
	exports.EndpointError = EndpointError;
	exports.customEndpointFunctions = customEndpointFunctions$3;
	exports.isIpAddress = isIpAddress;
	exports.isValidHostLabel = isValidHostLabel;
	exports.resolveEndpoint = resolveEndpoint$3;
}));

//#endregion
//#region node_modules/@smithy/querystring-parser/dist-cjs/index.js
var require_dist_cjs$34 = /* @__PURE__ */ __commonJSMin(((exports) => {
	function parseQueryString(querystring) {
		const query = {};
		querystring = querystring.replace(/^\?/, "");
		if (querystring) for (const pair of querystring.split("&")) {
			let [key, value = null] = pair.split("=");
			key = decodeURIComponent(key);
			if (value) value = decodeURIComponent(value);
			if (!(key in query)) query[key] = value;
			else if (Array.isArray(query[key])) query[key].push(value);
			else query[key] = [query[key], value];
		}
		return query;
	}
	exports.parseQueryString = parseQueryString;
}));

//#endregion
//#region node_modules/@smithy/url-parser/dist-cjs/index.js
var require_dist_cjs$33 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var querystringParser = require_dist_cjs$34();
	const parseUrl$3 = (url$1) => {
		if (typeof url$1 === "string") return parseUrl$3(new URL(url$1));
		const { hostname, pathname, port, protocol, search } = url$1;
		let query;
		if (search) query = querystringParser.parseQueryString(search);
		return {
			hostname,
			port: port ? parseInt(port) : void 0,
			protocol,
			path: pathname,
			query
		};
	};
	exports.parseUrl = parseUrl$3;
}));

//#endregion
//#region node_modules/@aws-sdk/util-endpoints/dist-cjs/index.js
var require_dist_cjs$32 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilEndpoints$2 = require_dist_cjs$35();
	var urlParser$2 = require_dist_cjs$33();
	const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
		if (allowSubDomains) {
			for (const label of value.split(".")) if (!isVirtualHostableS3Bucket(label)) return false;
			return true;
		}
		if (!utilEndpoints$2.isValidHostLabel(value)) return false;
		if (value.length < 3 || value.length > 63) return false;
		if (value !== value.toLowerCase()) return false;
		if (utilEndpoints$2.isIpAddress(value)) return false;
		return true;
	};
	const ARN_DELIMITER = ":";
	const RESOURCE_DELIMITER = "/";
	const parseArn = (value) => {
		const segments = value.split(ARN_DELIMITER);
		if (segments.length < 6) return null;
		const [arn, partition$1, service, region, accountId, ...resourcePath] = segments;
		if (arn !== "arn" || partition$1 === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "") return null;
		return {
			partition: partition$1,
			service,
			region,
			accountId,
			resourceId: resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat()
		};
	};
	var partitionsInfo = {
		partitions: [
			{
				id: "aws",
				outputs: {
					dnsSuffix: "amazonaws.com",
					dualStackDnsSuffix: "api.aws",
					implicitGlobalRegion: "us-east-1",
					name: "aws",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
				regions: {
					"af-south-1": { description: "Africa (Cape Town)" },
					"ap-east-1": { description: "Asia Pacific (Hong Kong)" },
					"ap-east-2": { description: "Asia Pacific (Taipei)" },
					"ap-northeast-1": { description: "Asia Pacific (Tokyo)" },
					"ap-northeast-2": { description: "Asia Pacific (Seoul)" },
					"ap-northeast-3": { description: "Asia Pacific (Osaka)" },
					"ap-south-1": { description: "Asia Pacific (Mumbai)" },
					"ap-south-2": { description: "Asia Pacific (Hyderabad)" },
					"ap-southeast-1": { description: "Asia Pacific (Singapore)" },
					"ap-southeast-2": { description: "Asia Pacific (Sydney)" },
					"ap-southeast-3": { description: "Asia Pacific (Jakarta)" },
					"ap-southeast-4": { description: "Asia Pacific (Melbourne)" },
					"ap-southeast-5": { description: "Asia Pacific (Malaysia)" },
					"ap-southeast-6": { description: "Asia Pacific (New Zealand)" },
					"ap-southeast-7": { description: "Asia Pacific (Thailand)" },
					"aws-global": { description: "aws global region" },
					"ca-central-1": { description: "Canada (Central)" },
					"ca-west-1": { description: "Canada West (Calgary)" },
					"eu-central-1": { description: "Europe (Frankfurt)" },
					"eu-central-2": { description: "Europe (Zurich)" },
					"eu-north-1": { description: "Europe (Stockholm)" },
					"eu-south-1": { description: "Europe (Milan)" },
					"eu-south-2": { description: "Europe (Spain)" },
					"eu-west-1": { description: "Europe (Ireland)" },
					"eu-west-2": { description: "Europe (London)" },
					"eu-west-3": { description: "Europe (Paris)" },
					"il-central-1": { description: "Israel (Tel Aviv)" },
					"me-central-1": { description: "Middle East (UAE)" },
					"me-south-1": { description: "Middle East (Bahrain)" },
					"mx-central-1": { description: "Mexico (Central)" },
					"sa-east-1": { description: "South America (Sao Paulo)" },
					"us-east-1": { description: "US East (N. Virginia)" },
					"us-east-2": { description: "US East (Ohio)" },
					"us-west-1": { description: "US West (N. California)" },
					"us-west-2": { description: "US West (Oregon)" }
				}
			},
			{
				id: "aws-cn",
				outputs: {
					dnsSuffix: "amazonaws.com.cn",
					dualStackDnsSuffix: "api.amazonwebservices.com.cn",
					implicitGlobalRegion: "cn-northwest-1",
					name: "aws-cn",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^cn\\-\\w+\\-\\d+$",
				regions: {
					"aws-cn-global": { description: "aws-cn global region" },
					"cn-north-1": { description: "China (Beijing)" },
					"cn-northwest-1": { description: "China (Ningxia)" }
				}
			},
			{
				id: "aws-eusc",
				outputs: {
					dnsSuffix: "amazonaws.eu",
					dualStackDnsSuffix: "api.amazonwebservices.eu",
					implicitGlobalRegion: "eusc-de-east-1",
					name: "aws-eusc",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
				regions: { "eusc-de-east-1": { description: "EU (Germany)" } }
			},
			{
				id: "aws-iso",
				outputs: {
					dnsSuffix: "c2s.ic.gov",
					dualStackDnsSuffix: "api.aws.ic.gov",
					implicitGlobalRegion: "us-iso-east-1",
					name: "aws-iso",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
				regions: {
					"aws-iso-global": { description: "aws-iso global region" },
					"us-iso-east-1": { description: "US ISO East" },
					"us-iso-west-1": { description: "US ISO WEST" }
				}
			},
			{
				id: "aws-iso-b",
				outputs: {
					dnsSuffix: "sc2s.sgov.gov",
					dualStackDnsSuffix: "api.aws.scloud",
					implicitGlobalRegion: "us-isob-east-1",
					name: "aws-iso-b",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
				regions: {
					"aws-iso-b-global": { description: "aws-iso-b global region" },
					"us-isob-east-1": { description: "US ISOB East (Ohio)" },
					"us-isob-west-1": { description: "US ISOB West" }
				}
			},
			{
				id: "aws-iso-e",
				outputs: {
					dnsSuffix: "cloud.adc-e.uk",
					dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
					implicitGlobalRegion: "eu-isoe-west-1",
					name: "aws-iso-e",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
				regions: {
					"aws-iso-e-global": { description: "aws-iso-e global region" },
					"eu-isoe-west-1": { description: "EU ISOE West" }
				}
			},
			{
				id: "aws-iso-f",
				outputs: {
					dnsSuffix: "csp.hci.ic.gov",
					dualStackDnsSuffix: "api.aws.hci.ic.gov",
					implicitGlobalRegion: "us-isof-south-1",
					name: "aws-iso-f",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
				regions: {
					"aws-iso-f-global": { description: "aws-iso-f global region" },
					"us-isof-east-1": { description: "US ISOF EAST" },
					"us-isof-south-1": { description: "US ISOF SOUTH" }
				}
			},
			{
				id: "aws-us-gov",
				outputs: {
					dnsSuffix: "amazonaws.com",
					dualStackDnsSuffix: "api.aws",
					implicitGlobalRegion: "us-gov-west-1",
					name: "aws-us-gov",
					supportsDualStack: true,
					supportsFIPS: true
				},
				regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
				regions: {
					"aws-us-gov-global": { description: "aws-us-gov global region" },
					"us-gov-east-1": { description: "AWS GovCloud (US-East)" },
					"us-gov-west-1": { description: "AWS GovCloud (US-West)" }
				}
			}
		],
		version: "1.1"
	};
	let selectedPartitionsInfo = partitionsInfo;
	let selectedUserAgentPrefix = "";
	const partition = (value) => {
		const { partitions } = selectedPartitionsInfo;
		for (const partition$1 of partitions) {
			const { regions, outputs } = partition$1;
			for (const [region, regionData] of Object.entries(regions)) if (region === value) return {
				...outputs,
				...regionData
			};
		}
		for (const partition$1 of partitions) {
			const { regionRegex, outputs } = partition$1;
			if (new RegExp(regionRegex).test(value)) return { ...outputs };
		}
		const DEFAULT_PARTITION = partitions.find((partition$1) => partition$1.id === "aws");
		if (!DEFAULT_PARTITION) throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
		return { ...DEFAULT_PARTITION.outputs };
	};
	const setPartitionInfo = (partitionsInfo$1, userAgentPrefix = "") => {
		selectedPartitionsInfo = partitionsInfo$1;
		selectedUserAgentPrefix = userAgentPrefix;
	};
	const useDefaultPartitionInfo = () => {
		setPartitionInfo(partitionsInfo, "");
	};
	const getUserAgentPrefix = () => selectedUserAgentPrefix;
	const awsEndpointFunctions$3 = {
		isVirtualHostableS3Bucket,
		parseArn,
		partition
	};
	utilEndpoints$2.customEndpointFunctions.aws = awsEndpointFunctions$3;
	const resolveDefaultAwsRegionalEndpointsConfig = (input) => {
		if (typeof input.endpointProvider !== "function") throw new Error("@aws-sdk/util-endpoint - endpointProvider and endpoint missing in config for this client.");
		const { endpoint } = input;
		if (endpoint === void 0) input.endpoint = async () => {
			return toEndpointV1$1(input.endpointProvider({
				Region: typeof input.region === "function" ? await input.region() : input.region,
				UseDualStack: typeof input.useDualstackEndpoint === "function" ? await input.useDualstackEndpoint() : input.useDualstackEndpoint,
				UseFIPS: typeof input.useFipsEndpoint === "function" ? await input.useFipsEndpoint() : input.useFipsEndpoint,
				Endpoint: void 0
			}, { logger: input.logger }));
		};
		return input;
	};
	const toEndpointV1$1 = (endpoint) => urlParser$2.parseUrl(endpoint.url);
	Object.defineProperty(exports, "EndpointError", {
		enumerable: true,
		get: function() {
			return utilEndpoints$2.EndpointError;
		}
	});
	Object.defineProperty(exports, "isIpAddress", {
		enumerable: true,
		get: function() {
			return utilEndpoints$2.isIpAddress;
		}
	});
	Object.defineProperty(exports, "resolveEndpoint", {
		enumerable: true,
		get: function() {
			return utilEndpoints$2.resolveEndpoint;
		}
	});
	exports.awsEndpointFunctions = awsEndpointFunctions$3;
	exports.getUserAgentPrefix = getUserAgentPrefix;
	exports.partition = partition;
	exports.resolveDefaultAwsRegionalEndpointsConfig = resolveDefaultAwsRegionalEndpointsConfig;
	exports.setPartitionInfo = setPartitionInfo;
	exports.toEndpointV1 = toEndpointV1$1;
	exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/client/emitWarningIfUnsupportedVersion.js
var state, emitWarningIfUnsupportedVersion;
var init_emitWarningIfUnsupportedVersion = __esmMin((() => {
	state = { warningEmitted: false };
	emitWarningIfUnsupportedVersion = (version$1) => {
		if (version$1 && !state.warningEmitted && parseInt(version$1.substring(1, version$1.indexOf("."))) < 18) {
			state.warningEmitted = true;
			process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js 16.x on January 6, 2025.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/74kJMmI`);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/client/setCredentialFeature.js
function setCredentialFeature(credentials, feature, value) {
	if (!credentials.$source) credentials.$source = {};
	credentials.$source[feature] = value;
	return credentials;
}
var init_setCredentialFeature = __esmMin((() => {}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/client/setFeature.js
function setFeature(context, feature, value) {
	if (!context.__aws_sdk_context) context.__aws_sdk_context = { features: {} };
	else if (!context.__aws_sdk_context.features) context.__aws_sdk_context.features = {};
	context.__aws_sdk_context.features[feature] = value;
}
var init_setFeature = __esmMin((() => {}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/client/setTokenFeature.js
function setTokenFeature(token, feature, value) {
	if (!token.$source) token.$source = {};
	token.$source[feature] = value;
	return token;
}
var init_setTokenFeature = __esmMin((() => {}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/client/index.js
var client_exports = /* @__PURE__ */ __export({
	emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
	setCredentialFeature: () => setCredentialFeature,
	setFeature: () => setFeature,
	setTokenFeature: () => setTokenFeature,
	state: () => state
});
var init_client = __esmMin((() => {
	init_emitWarningIfUnsupportedVersion();
	init_setCredentialFeature();
	init_setFeature();
	init_setTokenFeature();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getDateHeader.js
var import_dist_cjs$130, getDateHeader;
var init_getDateHeader = __esmMin((() => {
	import_dist_cjs$130 = require_dist_cjs$52();
	getDateHeader = (response) => import_dist_cjs$130.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : void 0;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getSkewCorrectedDate.js
var getSkewCorrectedDate;
var init_getSkewCorrectedDate = __esmMin((() => {
	getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/isClockSkewed.js
var isClockSkewed;
var init_isClockSkewed = __esmMin((() => {
	init_getSkewCorrectedDate();
	isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 3e5;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getUpdatedSystemClockOffset.js
var getUpdatedSystemClockOffset;
var init_getUpdatedSystemClockOffset = __esmMin((() => {
	init_isClockSkewed();
	getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
		const clockTimeInMs = Date.parse(clockTime);
		if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) return clockTimeInMs - Date.now();
		return currentSystemClockOffset;
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/index.js
var init_utils = __esmMin((() => {
	init_getDateHeader();
	init_getSkewCorrectedDate();
	init_getUpdatedSystemClockOffset();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4Signer.js
var import_dist_cjs$129, throwSigningPropertyError, validateSigningProperties, AwsSdkSigV4Signer, AWSSDKSigV4Signer;
var init_AwsSdkSigV4Signer = __esmMin((() => {
	import_dist_cjs$129 = require_dist_cjs$52();
	init_utils();
	throwSigningPropertyError = (name, property) => {
		if (!property) throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
		return property;
	};
	validateSigningProperties = async (signingProperties) => {
		const context = throwSigningPropertyError("context", signingProperties.context);
		const config = throwSigningPropertyError("config", signingProperties.config);
		const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
		return {
			config,
			signer: await throwSigningPropertyError("signer", config.signer)(authScheme),
			signingRegion: signingProperties?.signingRegion,
			signingRegionSet: signingProperties?.signingRegionSet,
			signingName: signingProperties?.signingName
		};
	};
	AwsSdkSigV4Signer = class {
		async sign(httpRequest$1, identity, signingProperties) {
			if (!import_dist_cjs$129.HttpRequest.isInstance(httpRequest$1)) throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
			const validatedProps = await validateSigningProperties(signingProperties);
			const { config, signer } = validatedProps;
			let { signingRegion, signingName } = validatedProps;
			const handlerExecutionContext = signingProperties.context;
			if (handlerExecutionContext?.authSchemes?.length ?? false) {
				const [first, second] = handlerExecutionContext.authSchemes;
				if (first?.name === "sigv4a" && second?.name === "sigv4") {
					signingRegion = second?.signingRegion ?? signingRegion;
					signingName = second?.signingName ?? signingName;
				}
			}
			return await signer.sign(httpRequest$1, {
				signingDate: getSkewCorrectedDate(config.systemClockOffset),
				signingRegion,
				signingService: signingName
			});
		}
		errorHandler(signingProperties) {
			return (error$2) => {
				const serverTime = error$2.ServerTime ?? getDateHeader(error$2.$response);
				if (serverTime) {
					const config = throwSigningPropertyError("config", signingProperties.config);
					const initialSystemClockOffset = config.systemClockOffset;
					config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
					if (config.systemClockOffset !== initialSystemClockOffset && error$2.$metadata) error$2.$metadata.clockSkewCorrected = true;
				}
				throw error$2;
			};
		}
		successHandler(httpResponse, signingProperties) {
			const dateHeader = getDateHeader(httpResponse);
			if (dateHeader) {
				const config = throwSigningPropertyError("config", signingProperties.config);
				config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
			}
		}
	};
	AWSSDKSigV4Signer = AwsSdkSigV4Signer;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/AwsSdkSigV4ASigner.js
var import_dist_cjs$128, AwsSdkSigV4ASigner;
var init_AwsSdkSigV4ASigner = __esmMin((() => {
	import_dist_cjs$128 = require_dist_cjs$52();
	init_utils();
	init_AwsSdkSigV4Signer();
	AwsSdkSigV4ASigner = class extends AwsSdkSigV4Signer {
		async sign(httpRequest$1, identity, signingProperties) {
			if (!import_dist_cjs$128.HttpRequest.isInstance(httpRequest$1)) throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
			const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
			const multiRegionOverride = (await config.sigv4aSigningRegionSet?.() ?? signingRegionSet ?? [signingRegion]).join(",");
			return await signer.sign(httpRequest$1, {
				signingDate: getSkewCorrectedDate(config.systemClockOffset),
				signingRegion: multiRegionOverride,
				signingService: signingName
			});
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getArrayForCommaSeparatedString.js
var getArrayForCommaSeparatedString;
var init_getArrayForCommaSeparatedString = __esmMin((() => {
	getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/utils/getBearerTokenEnvKey.js
var getBearerTokenEnvKey;
var init_getBearerTokenEnvKey = __esmMin((() => {
	getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/NODE_AUTH_SCHEME_PREFERENCE_OPTIONS.js
var NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY, NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY, NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
var init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = __esmMin((() => {
	init_getArrayForCommaSeparatedString();
	init_getBearerTokenEnvKey();
	NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
	NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
	NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
		environmentVariableSelector: (env, options) => {
			if (options?.signingName) {
				if (getBearerTokenEnvKey(options.signingName) in env) return ["httpBearerAuth"];
			}
			if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env)) return void 0;
			return getArrayForCommaSeparatedString(env[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
		},
		configFileSelector: (profile) => {
			if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile)) return void 0;
			return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
		},
		default: []
	};
}));

//#endregion
//#region node_modules/@smithy/property-provider/dist-cjs/index.js
var require_dist_cjs$31 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var ProviderError$1 = class ProviderError$1 extends Error {
		name = "ProviderError";
		tryNextLink;
		constructor(message, options = true) {
			let logger$1;
			let tryNextLink = true;
			if (typeof options === "boolean") {
				logger$1 = void 0;
				tryNextLink = options;
			} else if (options != null && typeof options === "object") {
				logger$1 = options.logger;
				tryNextLink = options.tryNextLink ?? true;
			}
			super(message);
			this.tryNextLink = tryNextLink;
			Object.setPrototypeOf(this, ProviderError$1.prototype);
			logger$1?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
		}
		static from(error$2, options = true) {
			return Object.assign(new this(error$2.message, options), error$2);
		}
	};
	var CredentialsProviderError = class CredentialsProviderError extends ProviderError$1 {
		name = "CredentialsProviderError";
		constructor(message, options = true) {
			super(message, options);
			Object.setPrototypeOf(this, CredentialsProviderError.prototype);
		}
	};
	var TokenProviderError = class TokenProviderError extends ProviderError$1 {
		name = "TokenProviderError";
		constructor(message, options = true) {
			super(message, options);
			Object.setPrototypeOf(this, TokenProviderError.prototype);
		}
	};
	const chain = (...providers) => async () => {
		if (providers.length === 0) throw new ProviderError$1("No providers in chain");
		let lastProviderError;
		for (const provider of providers) try {
			return await provider();
		} catch (err) {
			lastProviderError = err;
			if (err?.tryNextLink) continue;
			throw err;
		}
		throw lastProviderError;
	};
	const fromStatic$2 = (staticValue) => () => Promise.resolve(staticValue);
	const memoize = (provider, isExpired, requiresRefresh) => {
		let resolved;
		let pending;
		let hasResult;
		let isConstant = false;
		const coalesceProvider = async () => {
			if (!pending) pending = provider();
			try {
				resolved = await pending;
				hasResult = true;
				isConstant = false;
			} finally {
				pending = void 0;
			}
			return resolved;
		};
		if (isExpired === void 0) return async (options) => {
			if (!hasResult || options?.forceRefresh) resolved = await coalesceProvider();
			return resolved;
		};
		return async (options) => {
			if (!hasResult || options?.forceRefresh) resolved = await coalesceProvider();
			if (isConstant) return resolved;
			if (requiresRefresh && !requiresRefresh(resolved)) {
				isConstant = true;
				return resolved;
			}
			if (isExpired(resolved)) {
				await coalesceProvider();
				return resolved;
			}
			return resolved;
		};
	};
	exports.CredentialsProviderError = CredentialsProviderError;
	exports.ProviderError = ProviderError$1;
	exports.TokenProviderError = TokenProviderError;
	exports.chain = chain;
	exports.fromStatic = fromStatic$2;
	exports.memoize = memoize;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4AConfig.js
var import_dist_cjs$127, resolveAwsSdkSigV4AConfig, NODE_SIGV4A_CONFIG_OPTIONS;
var init_resolveAwsSdkSigV4AConfig = __esmMin((() => {
	init_dist_es$1();
	import_dist_cjs$127 = require_dist_cjs$31();
	resolveAwsSdkSigV4AConfig = (config) => {
		config.sigv4aSigningRegionSet = normalizeProvider$3(config.sigv4aSigningRegionSet);
		return config;
	};
	NODE_SIGV4A_CONFIG_OPTIONS = {
		environmentVariableSelector(env) {
			if (env.AWS_SIGV4A_SIGNING_REGION_SET) return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
			throw new import_dist_cjs$127.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", { tryNextLink: true });
		},
		configFileSelector(profile) {
			if (profile.sigv4a_signing_region_set) return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
			throw new import_dist_cjs$127.ProviderError("sigv4a_signing_region_set not set in profile.", { tryNextLink: true });
		},
		default: void 0
	};
}));

//#endregion
//#region node_modules/@smithy/signature-v4/dist-cjs/index.js
var require_dist_cjs$30 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilHexEncoding = require_dist_cjs$38();
	var utilUtf8$1 = require_dist_cjs$44();
	var isArrayBuffer = require_dist_cjs$46();
	var protocolHttp$6 = require_dist_cjs$52();
	var utilMiddleware$3 = require_dist_cjs$48();
	var utilUriEscape = require_dist_cjs$42();
	const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
	const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
	const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
	const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
	const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
	const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
	const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
	const AUTH_HEADER = "authorization";
	const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
	const DATE_HEADER = "date";
	const GENERATED_HEADERS = [
		AUTH_HEADER,
		AMZ_DATE_HEADER,
		DATE_HEADER
	];
	const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
	const SHA256_HEADER = "x-amz-content-sha256";
	const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
	const ALWAYS_UNSIGNABLE_HEADERS = {
		authorization: true,
		"cache-control": true,
		connection: true,
		expect: true,
		from: true,
		"keep-alive": true,
		"max-forwards": true,
		pragma: true,
		referer: true,
		te: true,
		trailer: true,
		"transfer-encoding": true,
		upgrade: true,
		"user-agent": true,
		"x-amzn-trace-id": true
	};
	const PROXY_HEADER_PATTERN = /^proxy-/;
	const SEC_HEADER_PATTERN = /^sec-/;
	const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
	const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
	const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
	const MAX_CACHE_SIZE = 50;
	const KEY_TYPE_IDENTIFIER = "aws4_request";
	const MAX_PRESIGNED_TTL = 3600 * 24 * 7;
	const signingKeyCache = {};
	const cacheQueue = [];
	const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
	const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
		const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
		const cacheKey = `${shortDate}:${region}:${service}:${utilHexEncoding.toHex(credsHash)}:${credentials.sessionToken}`;
		if (cacheKey in signingKeyCache) return signingKeyCache[cacheKey];
		cacheQueue.push(cacheKey);
		while (cacheQueue.length > MAX_CACHE_SIZE) delete signingKeyCache[cacheQueue.shift()];
		let key = `AWS4${credentials.secretAccessKey}`;
		for (const signable of [
			shortDate,
			region,
			service,
			KEY_TYPE_IDENTIFIER
		]) key = await hmac(sha256Constructor, key, signable);
		return signingKeyCache[cacheKey] = key;
	};
	const hmac = (ctor, secret, data$1) => {
		const hash = new ctor(secret);
		hash.update(utilUtf8$1.toUint8Array(data$1));
		return hash.digest();
	};
	const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
		const canonical = {};
		for (const headerName of Object.keys(headers).sort()) {
			if (headers[headerName] == void 0) continue;
			const canonicalHeaderName = headerName.toLowerCase();
			if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || unsignableHeaders?.has(canonicalHeaderName) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
				if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) continue;
			}
			canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
		}
		return canonical;
	};
	const getPayloadHash = async ({ headers, body }, hashConstructor) => {
		for (const headerName of Object.keys(headers)) if (headerName.toLowerCase() === SHA256_HEADER) return headers[headerName];
		if (body == void 0) return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
		else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer.isArrayBuffer(body)) {
			const hashCtor = new hashConstructor();
			hashCtor.update(utilUtf8$1.toUint8Array(body));
			return utilHexEncoding.toHex(await hashCtor.digest());
		}
		return UNSIGNED_PAYLOAD;
	};
	var HeaderFormatter = class {
		format(headers) {
			const chunks = [];
			for (const headerName of Object.keys(headers)) {
				const bytes = utilUtf8$1.fromUtf8(headerName);
				chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
			}
			const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
			let position = 0;
			for (const chunk of chunks) {
				out.set(chunk, position);
				position += chunk.byteLength;
			}
			return out;
		}
		formatHeaderValue(header) {
			switch (header.type) {
				case "boolean": return Uint8Array.from([header.value ? 0 : 1]);
				case "byte": return Uint8Array.from([2, header.value]);
				case "short":
					const shortView = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(3));
					shortView.setUint8(0, 3);
					shortView.setInt16(1, header.value, false);
					return new Uint8Array(shortView.buffer);
				case "integer":
					const intView = /* @__PURE__ */ new DataView(/* @__PURE__ */ new ArrayBuffer(5));
					intView.setUint8(0, 4);
					intView.setInt32(1, header.value, false);
					return new Uint8Array(intView.buffer);
				case "long":
					const longBytes = new Uint8Array(9);
					longBytes[0] = 5;
					longBytes.set(header.value.bytes, 1);
					return longBytes;
				case "binary":
					const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
					binView.setUint8(0, 6);
					binView.setUint16(1, header.value.byteLength, false);
					const binBytes = new Uint8Array(binView.buffer);
					binBytes.set(header.value, 3);
					return binBytes;
				case "string":
					const utf8Bytes = utilUtf8$1.fromUtf8(header.value);
					const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
					strView.setUint8(0, 7);
					strView.setUint16(1, utf8Bytes.byteLength, false);
					const strBytes = new Uint8Array(strView.buffer);
					strBytes.set(utf8Bytes, 3);
					return strBytes;
				case "timestamp":
					const tsBytes = new Uint8Array(9);
					tsBytes[0] = 8;
					tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
					return tsBytes;
				case "uuid":
					if (!UUID_PATTERN.test(header.value)) throw new Error(`Invalid UUID received: ${header.value}`);
					const uuidBytes = new Uint8Array(17);
					uuidBytes[0] = 9;
					uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
					return uuidBytes;
			}
		}
	};
	const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
	var Int64 = class Int64 {
		bytes;
		constructor(bytes) {
			this.bytes = bytes;
			if (bytes.byteLength !== 8) throw new Error("Int64 buffers must be exactly 8 bytes");
		}
		static fromNumber(number) {
			if (number > 0x8000000000000000 || number < -0x8000000000000000) throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
			const bytes = new Uint8Array(8);
			for (let i$5 = 7, remaining = Math.abs(Math.round(number)); i$5 > -1 && remaining > 0; i$5--, remaining /= 256) bytes[i$5] = remaining;
			if (number < 0) negate(bytes);
			return new Int64(bytes);
		}
		valueOf() {
			const bytes = this.bytes.slice(0);
			const negative = bytes[0] & 128;
			if (negative) negate(bytes);
			return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
		}
		toString() {
			return String(this.valueOf());
		}
	};
	function negate(bytes) {
		for (let i$5 = 0; i$5 < 8; i$5++) bytes[i$5] ^= 255;
		for (let i$5 = 7; i$5 > -1; i$5--) {
			bytes[i$5]++;
			if (bytes[i$5] !== 0) break;
		}
	}
	const hasHeader = (soughtHeader, headers) => {
		soughtHeader = soughtHeader.toLowerCase();
		for (const headerName of Object.keys(headers)) if (soughtHeader === headerName.toLowerCase()) return true;
		return false;
	};
	const moveHeadersToQuery = (request$1, options = {}) => {
		const { headers, query = {} } = protocolHttp$6.HttpRequest.clone(request$1);
		for (const name of Object.keys(headers)) {
			const lname = name.toLowerCase();
			if (lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname) || options.hoistableHeaders?.has(lname)) {
				query[name] = headers[name];
				delete headers[name];
			}
		}
		return {
			...request$1,
			headers,
			query
		};
	};
	const prepareRequest = (request$1) => {
		request$1 = protocolHttp$6.HttpRequest.clone(request$1);
		for (const headerName of Object.keys(request$1.headers)) if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) delete request$1.headers[headerName];
		return request$1;
	};
	const getCanonicalQuery = ({ query = {} }) => {
		const keys = [];
		const serialized = {};
		for (const key of Object.keys(query)) {
			if (key.toLowerCase() === SIGNATURE_HEADER) continue;
			const encodedKey = utilUriEscape.escapeUri(key);
			keys.push(encodedKey);
			const value = query[key];
			if (typeof value === "string") serialized[encodedKey] = `${encodedKey}=${utilUriEscape.escapeUri(value)}`;
			else if (Array.isArray(value)) serialized[encodedKey] = value.slice(0).reduce((encoded, value$1) => encoded.concat([`${encodedKey}=${utilUriEscape.escapeUri(value$1)}`]), []).sort().join("&");
		}
		return keys.sort().map((key) => serialized[key]).filter((serialized$1) => serialized$1).join("&");
	};
	const iso8601 = (time$1) => toDate(time$1).toISOString().replace(/\.\d{3}Z$/, "Z");
	const toDate = (time$1) => {
		if (typeof time$1 === "number") return /* @__PURE__ */ new Date(time$1 * 1e3);
		if (typeof time$1 === "string") {
			if (Number(time$1)) return /* @__PURE__ */ new Date(Number(time$1) * 1e3);
			return new Date(time$1);
		}
		return time$1;
	};
	var SignatureV4Base = class {
		service;
		regionProvider;
		credentialProvider;
		sha256;
		uriEscapePath;
		applyChecksum;
		constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
			this.service = service;
			this.sha256 = sha256;
			this.uriEscapePath = uriEscapePath;
			this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
			this.regionProvider = utilMiddleware$3.normalizeProvider(region);
			this.credentialProvider = utilMiddleware$3.normalizeProvider(credentials);
		}
		createCanonicalRequest(request$1, canonicalHeaders, payloadHash) {
			const sortedHeaders = Object.keys(canonicalHeaders).sort();
			return `${request$1.method}
${this.getCanonicalPath(request$1)}
${getCanonicalQuery(request$1)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
		}
		async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
			const hash = new this.sha256();
			hash.update(utilUtf8$1.toUint8Array(canonicalRequest));
			const hashedRequest = await hash.digest();
			return `${algorithmIdentifier}
${longDate}
${credentialScope}
${utilHexEncoding.toHex(hashedRequest)}`;
		}
		getCanonicalPath({ path: path$6 }) {
			if (this.uriEscapePath) {
				const normalizedPathSegments = [];
				for (const pathSegment of path$6.split("/")) {
					if (pathSegment?.length === 0) continue;
					if (pathSegment === ".") continue;
					if (pathSegment === "..") normalizedPathSegments.pop();
					else normalizedPathSegments.push(pathSegment);
				}
				const normalizedPath = `${path$6?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path$6?.endsWith("/") ? "/" : ""}`;
				return utilUriEscape.escapeUri(normalizedPath).replace(/%2F/g, "/");
			}
			return path$6;
		}
		validateResolvedCredentials(credentials) {
			if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") throw new Error("Resolved credential object is not valid");
		}
		formatDate(now) {
			const longDate = iso8601(now).replace(/[\-:]/g, "");
			return {
				longDate,
				shortDate: longDate.slice(0, 8)
			};
		}
		getCanonicalHeaderList(headers) {
			return Object.keys(headers).sort().join(";");
		}
	};
	var SignatureV4$1 = class extends SignatureV4Base {
		headerFormatter = new HeaderFormatter();
		constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }) {
			super({
				applyChecksum,
				credentials,
				region,
				service,
				sha256,
				uriEscapePath
			});
		}
		async presign(originalRequest, options = {}) {
			const { signingDate = /* @__PURE__ */ new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService } = options;
			const credentials = await this.credentialProvider();
			this.validateResolvedCredentials(credentials);
			const region = signingRegion ?? await this.regionProvider();
			const { longDate, shortDate } = this.formatDate(signingDate);
			if (expiresIn > MAX_PRESIGNED_TTL) return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
			const scope = createScope(shortDate, region, signingService ?? this.service);
			const request$1 = moveHeadersToQuery(prepareRequest(originalRequest), {
				unhoistableHeaders,
				hoistableHeaders
			});
			if (credentials.sessionToken) request$1.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
			request$1.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
			request$1.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
			request$1.query[AMZ_DATE_QUERY_PARAM] = longDate;
			request$1.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
			const canonicalHeaders = getCanonicalHeaders(request$1, unsignableHeaders, signableHeaders);
			request$1.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
			request$1.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request$1, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
			return request$1;
		}
		async sign(toSign, options) {
			if (typeof toSign === "string") return this.signString(toSign, options);
			else if (toSign.headers && toSign.payload) return this.signEvent(toSign, options);
			else if (toSign.message) return this.signMessage(toSign, options);
			else return this.signRequest(toSign, options);
		}
		async signEvent({ headers, payload: payload$1 }, { signingDate = /* @__PURE__ */ new Date(), priorSignature, signingRegion, signingService }) {
			const region = signingRegion ?? await this.regionProvider();
			const { shortDate, longDate } = this.formatDate(signingDate);
			const scope = createScope(shortDate, region, signingService ?? this.service);
			const hashedPayload = await getPayloadHash({
				headers: {},
				body: payload$1
			}, this.sha256);
			const hash = new this.sha256();
			hash.update(headers);
			const stringToSign = [
				EVENT_ALGORITHM_IDENTIFIER,
				longDate,
				scope,
				priorSignature,
				utilHexEncoding.toHex(await hash.digest()),
				hashedPayload
			].join("\n");
			return this.signString(stringToSign, {
				signingDate,
				signingRegion: region,
				signingService
			});
		}
		async signMessage(signableMessage, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService }) {
			return this.signEvent({
				headers: this.headerFormatter.format(signableMessage.message.headers),
				payload: signableMessage.message.body
			}, {
				signingDate,
				signingRegion,
				signingService,
				priorSignature: signableMessage.priorSignature
			}).then((signature) => {
				return {
					message: signableMessage.message,
					signature
				};
			});
		}
		async signString(stringToSign, { signingDate = /* @__PURE__ */ new Date(), signingRegion, signingService } = {}) {
			const credentials = await this.credentialProvider();
			this.validateResolvedCredentials(credentials);
			const region = signingRegion ?? await this.regionProvider();
			const { shortDate } = this.formatDate(signingDate);
			const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
			hash.update(utilUtf8$1.toUint8Array(stringToSign));
			return utilHexEncoding.toHex(await hash.digest());
		}
		async signRequest(requestToSign, { signingDate = /* @__PURE__ */ new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
			const credentials = await this.credentialProvider();
			this.validateResolvedCredentials(credentials);
			const region = signingRegion ?? await this.regionProvider();
			const request$1 = prepareRequest(requestToSign);
			const { longDate, shortDate } = this.formatDate(signingDate);
			const scope = createScope(shortDate, region, signingService ?? this.service);
			request$1.headers[AMZ_DATE_HEADER] = longDate;
			if (credentials.sessionToken) request$1.headers[TOKEN_HEADER] = credentials.sessionToken;
			const payloadHash = await getPayloadHash(request$1, this.sha256);
			if (!hasHeader(SHA256_HEADER, request$1.headers) && this.applyChecksum) request$1.headers[SHA256_HEADER] = payloadHash;
			const canonicalHeaders = getCanonicalHeaders(request$1, unsignableHeaders, signableHeaders);
			const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request$1, canonicalHeaders, payloadHash));
			request$1.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${credentials.accessKeyId}/${scope}, SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, Signature=${signature}`;
			return request$1;
		}
		async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
			const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
			const hash = new this.sha256(await keyPromise);
			hash.update(utilUtf8$1.toUint8Array(stringToSign));
			return utilHexEncoding.toHex(await hash.digest());
		}
		getSigningKey(credentials, region, shortDate, service) {
			return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
		}
	};
	exports.SignatureV4 = SignatureV4$1;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/resolveAwsSdkSigV4Config.js
function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider }) {
	let credentialsProvider;
	if (credentials) if (!credentials?.memoized) credentialsProvider = memoizeIdentityProvider(credentials, isIdentityExpired, doesIdentityRequireRefresh);
	else credentialsProvider = credentials;
	else if (credentialDefaultProvider) credentialsProvider = normalizeProvider$3(credentialDefaultProvider(Object.assign({}, config, { parentClientConfig: config })));
	else credentialsProvider = async () => {
		throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
	};
	credentialsProvider.memoized = true;
	return credentialsProvider;
}
function bindCallerConfig(config, credentialsProvider) {
	if (credentialsProvider.configBound) return credentialsProvider;
	const fn = async (options) => credentialsProvider({
		...options,
		callerClientConfig: config
	});
	fn.memoized = credentialsProvider.memoized;
	fn.configBound = true;
	return fn;
}
var import_dist_cjs$126, resolveAwsSdkSigV4Config, resolveAWSSDKSigV4Config;
var init_resolveAwsSdkSigV4Config = __esmMin((() => {
	init_client();
	init_dist_es$1();
	import_dist_cjs$126 = require_dist_cjs$30();
	resolveAwsSdkSigV4Config = (config) => {
		let inputCredentials = config.credentials;
		let isUserSupplied = !!config.credentials;
		let resolvedCredentials = void 0;
		Object.defineProperty(config, "credentials", {
			set(credentials) {
				if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) isUserSupplied = true;
				inputCredentials = credentials;
				const boundProvider = bindCallerConfig(config, normalizeCredentialProvider(config, {
					credentials: inputCredentials,
					credentialDefaultProvider: config.credentialDefaultProvider
				}));
				if (isUserSupplied && !boundProvider.attributed) {
					resolvedCredentials = async (options) => boundProvider(options).then((creds) => setCredentialFeature(creds, "CREDENTIALS_CODE", "e"));
					resolvedCredentials.memoized = boundProvider.memoized;
					resolvedCredentials.configBound = boundProvider.configBound;
					resolvedCredentials.attributed = true;
				} else resolvedCredentials = boundProvider;
			},
			get() {
				return resolvedCredentials;
			},
			enumerable: true,
			configurable: true
		});
		config.credentials = inputCredentials;
		const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256 } = config;
		let signer;
		if (config.signer) signer = normalizeProvider$3(config.signer);
		else if (config.regionInfoProvider) signer = () => normalizeProvider$3(config.region)().then(async (region) => [await config.regionInfoProvider(region, {
			useFipsEndpoint: await config.useFipsEndpoint(),
			useDualstackEndpoint: await config.useDualstackEndpoint()
		}) || {}, region]).then(([regionInfo, region]) => {
			const { signingRegion, signingService } = regionInfo;
			config.signingRegion = config.signingRegion || signingRegion || region;
			config.signingName = config.signingName || signingService || config.serviceId;
			const params = {
				...config,
				credentials: config.credentials,
				region: config.signingRegion,
				service: config.signingName,
				sha256,
				uriEscapePath: signingEscapePath
			};
			return new (config.signerConstructor || import_dist_cjs$126.SignatureV4)(params);
		});
		else signer = async (authScheme) => {
			authScheme = Object.assign({}, {
				name: "sigv4",
				signingName: config.signingName || config.defaultSigningName,
				signingRegion: await normalizeProvider$3(config.region)(),
				properties: {}
			}, authScheme);
			const signingRegion = authScheme.signingRegion;
			const signingService = authScheme.signingName;
			config.signingRegion = config.signingRegion || signingRegion;
			config.signingName = config.signingName || signingService || config.serviceId;
			const params = {
				...config,
				credentials: config.credentials,
				region: config.signingRegion,
				service: config.signingName,
				sha256,
				uriEscapePath: signingEscapePath
			};
			return new (config.signerConstructor || import_dist_cjs$126.SignatureV4)(params);
		};
		return Object.assign(config, {
			systemClockOffset,
			signingEscapePath,
			signer
		});
	};
	resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/aws_sdk/index.js
var init_aws_sdk = __esmMin((() => {
	init_AwsSdkSigV4Signer();
	init_AwsSdkSigV4ASigner();
	init_NODE_AUTH_SCHEME_PREFERENCE_OPTIONS();
	init_resolveAwsSdkSigV4AConfig();
	init_resolveAwsSdkSigV4Config();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/httpAuthSchemes/index.js
var httpAuthSchemes_exports = /* @__PURE__ */ __export({
	AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
	AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
	AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
	NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => NODE_AUTH_SCHEME_PREFERENCE_OPTIONS,
	NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
	getBearerTokenEnvKey: () => getBearerTokenEnvKey,
	resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
	resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
	resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
	validateSigningProperties: () => validateSigningProperties
});
var init_httpAuthSchemes = __esmMin((() => {
	init_aws_sdk();
	init_getBearerTokenEnvKey();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/cbor-types.js
function alloc(size) {
	return typeof Buffer !== "undefined" ? Buffer.alloc(size) : new Uint8Array(size);
}
function tag(data$1) {
	data$1[tagSymbol] = true;
	return data$1;
}
var majorUint64, majorNegativeInt64, majorUnstructuredByteString, majorUtf8String, majorList, majorMap, majorTag, majorSpecial, specialFalse, specialTrue, specialNull, specialUndefined, extendedOneByte, extendedFloat16, extendedFloat32, extendedFloat64, minorIndefinite, tagSymbol;
var init_cbor_types = __esmMin((() => {
	majorUint64 = 0;
	majorNegativeInt64 = 1;
	majorUnstructuredByteString = 2;
	majorUtf8String = 3;
	majorList = 4;
	majorMap = 5;
	majorTag = 6;
	majorSpecial = 7;
	specialFalse = 20;
	specialTrue = 21;
	specialNull = 22;
	specialUndefined = 23;
	extendedOneByte = 24;
	extendedFloat16 = 25;
	extendedFloat32 = 26;
	extendedFloat64 = 27;
	minorIndefinite = 31;
	tagSymbol = Symbol("@smithy/core/cbor::tagSymbol");
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/cbor-decode.js
function setPayload(bytes) {
	payload = bytes;
	dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
}
function decode(at, to) {
	if (at >= to) throw new Error("unexpected end of (decode) payload.");
	const major = (payload[at] & 224) >> 5;
	const minor = payload[at] & 31;
	switch (major) {
		case majorUint64:
		case majorNegativeInt64:
		case majorTag:
			let unsignedInt;
			let offset;
			if (minor < 24) {
				unsignedInt = minor;
				offset = 1;
			} else switch (minor) {
				case extendedOneByte:
				case extendedFloat16:
				case extendedFloat32:
				case extendedFloat64:
					const countLength = minorValueToArgumentLength[minor];
					const countOffset = countLength + 1;
					offset = countOffset;
					if (to - at < countOffset) throw new Error(`countLength ${countLength} greater than remaining buf len.`);
					const countIndex = at + 1;
					if (countLength === 1) unsignedInt = payload[countIndex];
					else if (countLength === 2) unsignedInt = dataView$1.getUint16(countIndex);
					else if (countLength === 4) unsignedInt = dataView$1.getUint32(countIndex);
					else unsignedInt = dataView$1.getBigUint64(countIndex);
					break;
				default: throw new Error(`unexpected minor value ${minor}.`);
			}
			if (major === majorUint64) {
				_offset = offset;
				return castBigInt(unsignedInt);
			} else if (major === majorNegativeInt64) {
				let negativeInt;
				if (typeof unsignedInt === "bigint") negativeInt = BigInt(-1) - unsignedInt;
				else negativeInt = -1 - unsignedInt;
				_offset = offset;
				return castBigInt(negativeInt);
			} else if (minor === 2 || minor === 3) {
				const length = decodeCount(at + offset, to);
				let b$5 = BigInt(0);
				const start = at + offset + _offset;
				for (let i$5 = start; i$5 < start + length; ++i$5) b$5 = b$5 << BigInt(8) | BigInt(payload[i$5]);
				_offset = offset + _offset + length;
				return minor === 3 ? -b$5 - BigInt(1) : b$5;
			} else if (minor === 4) {
				const [exponent, mantissa] = decode(at + offset, to);
				const normalizer = mantissa < 0 ? -1 : 1;
				const mantissaStr = "0".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));
				let numericString;
				const sign = mantissa < 0 ? "-" : "";
				numericString = exponent === 0 ? mantissaStr : mantissaStr.slice(0, mantissaStr.length + exponent) + "." + mantissaStr.slice(exponent);
				numericString = numericString.replace(/^0+/g, "");
				if (numericString === "") numericString = "0";
				if (numericString[0] === ".") numericString = "0" + numericString;
				numericString = sign + numericString;
				_offset = offset + _offset;
				return nv(numericString);
			} else {
				const value = decode(at + offset, to);
				_offset = offset + _offset;
				return tag({
					tag: castBigInt(unsignedInt),
					value
				});
			}
		case majorUtf8String:
		case majorMap:
		case majorList:
		case majorUnstructuredByteString: if (minor === minorIndefinite) switch (major) {
			case majorUtf8String: return decodeUtf8StringIndefinite(at, to);
			case majorMap: return decodeMapIndefinite(at, to);
			case majorList: return decodeListIndefinite(at, to);
			case majorUnstructuredByteString: return decodeUnstructuredByteStringIndefinite(at, to);
		}
		else switch (major) {
			case majorUtf8String: return decodeUtf8String(at, to);
			case majorMap: return decodeMap(at, to);
			case majorList: return decodeList(at, to);
			case majorUnstructuredByteString: return decodeUnstructuredByteString(at, to);
		}
		default: return decodeSpecial(at, to);
	}
}
function bytesToUtf8(bytes, at, to) {
	if (USE_BUFFER$1 && bytes.constructor?.name === "Buffer") return bytes.toString("utf-8", at, to);
	if (textDecoder) return textDecoder.decode(bytes.subarray(at, to));
	return (0, import_dist_cjs$125.toUtf8)(bytes.subarray(at, to));
}
function demote(bigInteger) {
	const num = Number(bigInteger);
	if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) console.warn(/* @__PURE__ */ new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));
	return num;
}
function bytesToFloat16(a$5, b$5) {
	const sign = a$5 >> 7;
	const exponent = (a$5 & 124) >> 2;
	const fraction = (a$5 & 3) << 8 | b$5;
	const scalar = sign === 0 ? 1 : -1;
	let exponentComponent;
	let summation;
	if (exponent === 0) if (fraction === 0) return 0;
	else {
		exponentComponent = Math.pow(2, -14);
		summation = 0;
	}
	else if (exponent === 31) if (fraction === 0) return scalar * Infinity;
	else return NaN;
	else {
		exponentComponent = Math.pow(2, exponent - 15);
		summation = 1;
	}
	summation += fraction / 1024;
	return scalar * (exponentComponent * summation);
}
function decodeCount(at, to) {
	const minor = payload[at] & 31;
	if (minor < 24) {
		_offset = 1;
		return minor;
	}
	if (minor === extendedOneByte || minor === extendedFloat16 || minor === extendedFloat32 || minor === extendedFloat64) {
		const countLength = minorValueToArgumentLength[minor];
		_offset = countLength + 1;
		if (to - at < _offset) throw new Error(`countLength ${countLength} greater than remaining buf len.`);
		const countIndex = at + 1;
		if (countLength === 1) return payload[countIndex];
		else if (countLength === 2) return dataView$1.getUint16(countIndex);
		else if (countLength === 4) return dataView$1.getUint32(countIndex);
		return demote(dataView$1.getBigUint64(countIndex));
	}
	throw new Error(`unexpected minor value ${minor}.`);
}
function decodeUtf8String(at, to) {
	const length = decodeCount(at, to);
	const offset = _offset;
	at += offset;
	if (to - at < length) throw new Error(`string len ${length} greater than remaining buf len.`);
	const value = bytesToUtf8(payload, at, at + length);
	_offset = offset + length;
	return value;
}
function decodeUtf8StringIndefinite(at, to) {
	at += 1;
	const vector = [];
	for (const base = at; at < to;) {
		if (payload[at] === 255) {
			const data$1 = alloc(vector.length);
			data$1.set(vector, 0);
			_offset = at - base + 2;
			return bytesToUtf8(data$1, 0, data$1.length);
		}
		const major = (payload[at] & 224) >> 5;
		const minor = payload[at] & 31;
		if (major !== majorUtf8String) throw new Error(`unexpected major type ${major} in indefinite string.`);
		if (minor === minorIndefinite) throw new Error("nested indefinite string.");
		const bytes = decodeUnstructuredByteString(at, to);
		at += _offset;
		for (let i$5 = 0; i$5 < bytes.length; ++i$5) vector.push(bytes[i$5]);
	}
	throw new Error("expected break marker.");
}
function decodeUnstructuredByteString(at, to) {
	const length = decodeCount(at, to);
	const offset = _offset;
	at += offset;
	if (to - at < length) throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);
	const value = payload.subarray(at, at + length);
	_offset = offset + length;
	return value;
}
function decodeUnstructuredByteStringIndefinite(at, to) {
	at += 1;
	const vector = [];
	for (const base = at; at < to;) {
		if (payload[at] === 255) {
			const data$1 = alloc(vector.length);
			data$1.set(vector, 0);
			_offset = at - base + 2;
			return data$1;
		}
		const major = (payload[at] & 224) >> 5;
		const minor = payload[at] & 31;
		if (major !== majorUnstructuredByteString) throw new Error(`unexpected major type ${major} in indefinite string.`);
		if (minor === minorIndefinite) throw new Error("nested indefinite string.");
		const bytes = decodeUnstructuredByteString(at, to);
		at += _offset;
		for (let i$5 = 0; i$5 < bytes.length; ++i$5) vector.push(bytes[i$5]);
	}
	throw new Error("expected break marker.");
}
function decodeList(at, to) {
	const listDataLength = decodeCount(at, to);
	const offset = _offset;
	at += offset;
	const base = at;
	const list$1 = Array(listDataLength);
	for (let i$5 = 0; i$5 < listDataLength; ++i$5) {
		const item = decode(at, to);
		const itemOffset = _offset;
		list$1[i$5] = item;
		at += itemOffset;
	}
	_offset = offset + (at - base);
	return list$1;
}
function decodeListIndefinite(at, to) {
	at += 1;
	const list$1 = [];
	for (const base = at; at < to;) {
		if (payload[at] === 255) {
			_offset = at - base + 2;
			return list$1;
		}
		const item = decode(at, to);
		at += _offset;
		list$1.push(item);
	}
	throw new Error("expected break marker.");
}
function decodeMap(at, to) {
	const mapDataLength = decodeCount(at, to);
	const offset = _offset;
	at += offset;
	const base = at;
	const map$2 = {};
	for (let i$5 = 0; i$5 < mapDataLength; ++i$5) {
		if (at >= to) throw new Error("unexpected end of map payload.");
		const major = (payload[at] & 224) >> 5;
		if (major !== majorUtf8String) throw new Error(`unexpected major type ${major} for map key at index ${at}.`);
		const key = decode(at, to);
		at += _offset;
		const value = decode(at, to);
		at += _offset;
		map$2[key] = value;
	}
	_offset = offset + (at - base);
	return map$2;
}
function decodeMapIndefinite(at, to) {
	at += 1;
	const base = at;
	const map$2 = {};
	for (; at < to;) {
		if (at >= to) throw new Error("unexpected end of map payload.");
		if (payload[at] === 255) {
			_offset = at - base + 2;
			return map$2;
		}
		const major = (payload[at] & 224) >> 5;
		if (major !== majorUtf8String) throw new Error(`unexpected major type ${major} for map key.`);
		const key = decode(at, to);
		at += _offset;
		const value = decode(at, to);
		at += _offset;
		map$2[key] = value;
	}
	throw new Error("expected break marker.");
}
function decodeSpecial(at, to) {
	const minor = payload[at] & 31;
	switch (minor) {
		case specialTrue:
		case specialFalse:
			_offset = 1;
			return minor === specialTrue;
		case specialNull:
			_offset = 1;
			return null;
		case specialUndefined:
			_offset = 1;
			return null;
		case extendedFloat16:
			if (to - at < 3) throw new Error("incomplete float16 at end of buf.");
			_offset = 3;
			return bytesToFloat16(payload[at + 1], payload[at + 2]);
		case extendedFloat32:
			if (to - at < 5) throw new Error("incomplete float32 at end of buf.");
			_offset = 5;
			return dataView$1.getFloat32(at + 1);
		case extendedFloat64:
			if (to - at < 9) throw new Error("incomplete float64 at end of buf.");
			_offset = 9;
			return dataView$1.getFloat64(at + 1);
		default: throw new Error(`unexpected minor value ${minor}.`);
	}
}
function castBigInt(bigInt) {
	if (typeof bigInt === "number") return bigInt;
	const num = Number(bigInt);
	if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) return num;
	return bigInt;
}
var import_dist_cjs$125, USE_TEXT_DECODER, USE_BUFFER$1, payload, dataView$1, textDecoder, _offset, minorValueToArgumentLength;
var init_cbor_decode = __esmMin((() => {
	init_serde();
	import_dist_cjs$125 = require_dist_cjs$44();
	init_cbor_types();
	USE_TEXT_DECODER = typeof TextDecoder !== "undefined";
	USE_BUFFER$1 = typeof Buffer !== "undefined";
	payload = alloc(0);
	dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
	textDecoder = USE_TEXT_DECODER ? new TextDecoder() : null;
	_offset = 0;
	minorValueToArgumentLength = {
		[extendedOneByte]: 1,
		[extendedFloat16]: 2,
		[extendedFloat32]: 4,
		[extendedFloat64]: 8
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/cbor-encode.js
function ensureSpace(bytes) {
	if (data.byteLength - cursor < bytes) if (cursor < 16e6) resize(Math.max(data.byteLength * 4, data.byteLength + bytes));
	else resize(data.byteLength + bytes + 16e6);
}
function toUint8Array() {
	const out = alloc(cursor);
	out.set(data.subarray(0, cursor), 0);
	cursor = 0;
	return out;
}
function resize(size) {
	const old = data;
	data = alloc(size);
	if (old) if (old.copy) old.copy(data, 0, 0, old.byteLength);
	else data.set(old, 0);
	dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
}
function encodeHeader(major, value) {
	if (value < 24) data[cursor++] = major << 5 | value;
	else if (value < 256) {
		data[cursor++] = major << 5 | 24;
		data[cursor++] = value;
	} else if (value < 65536) {
		data[cursor++] = major << 5 | extendedFloat16;
		dataView.setUint16(cursor, value);
		cursor += 2;
	} else if (value < 2 ** 32) {
		data[cursor++] = major << 5 | extendedFloat32;
		dataView.setUint32(cursor, value);
		cursor += 4;
	} else {
		data[cursor++] = major << 5 | extendedFloat64;
		dataView.setBigUint64(cursor, typeof value === "bigint" ? value : BigInt(value));
		cursor += 8;
	}
}
function encode(_input) {
	const encodeStack = [_input];
	while (encodeStack.length) {
		const input = encodeStack.pop();
		ensureSpace(typeof input === "string" ? input.length * 4 : 64);
		if (typeof input === "string") {
			if (USE_BUFFER) {
				encodeHeader(majorUtf8String, Buffer.byteLength(input));
				cursor += data.write(input, cursor);
			} else {
				const bytes = (0, import_dist_cjs$124.fromUtf8)(input);
				encodeHeader(majorUtf8String, bytes.byteLength);
				data.set(bytes, cursor);
				cursor += bytes.byteLength;
			}
			continue;
		} else if (typeof input === "number") {
			if (Number.isInteger(input)) {
				const nonNegative = input >= 0;
				const major = nonNegative ? majorUint64 : majorNegativeInt64;
				const value = nonNegative ? input : -input - 1;
				if (value < 24) data[cursor++] = major << 5 | value;
				else if (value < 256) {
					data[cursor++] = major << 5 | 24;
					data[cursor++] = value;
				} else if (value < 65536) {
					data[cursor++] = major << 5 | extendedFloat16;
					data[cursor++] = value >> 8;
					data[cursor++] = value;
				} else if (value < 4294967296) {
					data[cursor++] = major << 5 | extendedFloat32;
					dataView.setUint32(cursor, value);
					cursor += 4;
				} else {
					data[cursor++] = major << 5 | extendedFloat64;
					dataView.setBigUint64(cursor, BigInt(value));
					cursor += 8;
				}
				continue;
			}
			data[cursor++] = majorSpecial << 5 | extendedFloat64;
			dataView.setFloat64(cursor, input);
			cursor += 8;
			continue;
		} else if (typeof input === "bigint") {
			const nonNegative = input >= 0;
			const major = nonNegative ? majorUint64 : majorNegativeInt64;
			const value = nonNegative ? input : -input - BigInt(1);
			const n$5 = Number(value);
			if (n$5 < 24) data[cursor++] = major << 5 | n$5;
			else if (n$5 < 256) {
				data[cursor++] = major << 5 | 24;
				data[cursor++] = n$5;
			} else if (n$5 < 65536) {
				data[cursor++] = major << 5 | extendedFloat16;
				data[cursor++] = n$5 >> 8;
				data[cursor++] = n$5 & 255;
			} else if (n$5 < 4294967296) {
				data[cursor++] = major << 5 | extendedFloat32;
				dataView.setUint32(cursor, n$5);
				cursor += 4;
			} else if (value < BigInt("18446744073709551616")) {
				data[cursor++] = major << 5 | extendedFloat64;
				dataView.setBigUint64(cursor, value);
				cursor += 8;
			} else {
				const binaryBigInt = value.toString(2);
				const bigIntBytes = new Uint8Array(Math.ceil(binaryBigInt.length / 8));
				let b$5 = value;
				let i$5 = 0;
				while (bigIntBytes.byteLength - ++i$5 >= 0) {
					bigIntBytes[bigIntBytes.byteLength - i$5] = Number(b$5 & BigInt(255));
					b$5 >>= BigInt(8);
				}
				ensureSpace(bigIntBytes.byteLength * 2);
				data[cursor++] = nonNegative ? 194 : 195;
				if (USE_BUFFER) encodeHeader(majorUnstructuredByteString, Buffer.byteLength(bigIntBytes));
				else encodeHeader(majorUnstructuredByteString, bigIntBytes.byteLength);
				data.set(bigIntBytes, cursor);
				cursor += bigIntBytes.byteLength;
			}
			continue;
		} else if (input === null) {
			data[cursor++] = majorSpecial << 5 | specialNull;
			continue;
		} else if (typeof input === "boolean") {
			data[cursor++] = majorSpecial << 5 | (input ? specialTrue : specialFalse);
			continue;
		} else if (typeof input === "undefined") throw new Error("@smithy/core/cbor: client may not serialize undefined value.");
		else if (Array.isArray(input)) {
			for (let i$5 = input.length - 1; i$5 >= 0; --i$5) encodeStack.push(input[i$5]);
			encodeHeader(majorList, input.length);
			continue;
		} else if (typeof input.byteLength === "number") {
			ensureSpace(input.length * 2);
			encodeHeader(majorUnstructuredByteString, input.length);
			data.set(input, cursor);
			cursor += input.byteLength;
			continue;
		} else if (typeof input === "object") {
			if (input instanceof NumericValue) {
				const decimalIndex = input.string.indexOf(".");
				const exponent = decimalIndex === -1 ? 0 : decimalIndex - input.string.length + 1;
				const mantissa = BigInt(input.string.replace(".", ""));
				data[cursor++] = 196;
				encodeStack.push(mantissa);
				encodeStack.push(exponent);
				encodeHeader(majorList, 2);
				continue;
			}
			if (input[tagSymbol]) if ("tag" in input && "value" in input) {
				encodeStack.push(input.value);
				encodeHeader(majorTag, input.tag);
				continue;
			} else throw new Error("tag encountered with missing fields, need 'tag' and 'value', found: " + JSON.stringify(input));
			const keys = Object.keys(input);
			for (let i$5 = keys.length - 1; i$5 >= 0; --i$5) {
				const key = keys[i$5];
				encodeStack.push(input[key]);
				encodeStack.push(key);
			}
			encodeHeader(majorMap, keys.length);
			continue;
		}
		throw new Error(`data type ${input?.constructor?.name ?? typeof input} not compatible for encoding.`);
	}
}
var import_dist_cjs$124, USE_BUFFER, data, dataView, cursor;
var init_cbor_encode = __esmMin((() => {
	init_serde();
	import_dist_cjs$124 = require_dist_cjs$44();
	init_cbor_types();
	USE_BUFFER = typeof Buffer !== "undefined";
	data = alloc(2048);
	dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
	cursor = 0;
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/cbor.js
var cbor;
var init_cbor$1 = __esmMin((() => {
	init_cbor_decode();
	init_cbor_encode();
	cbor = {
		deserialize(payload$1) {
			setPayload(payload$1);
			return decode(0, payload$1.length);
		},
		serialize(input) {
			try {
				encode(input);
				return toUint8Array();
			} catch (e$5) {
				toUint8Array();
				throw e$5;
			}
		},
		resizeEncodingBuffer(size) {
			resize(size);
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/parseCborBody.js
var dateToTag, loadSmithyRpcV2CborErrorCode;
var init_parseCborBody = __esmMin((() => {
	init_protocols$1();
	init_cbor_types();
	dateToTag = (date$1) => {
		return tag({
			tag: 1,
			value: date$1.getTime() / 1e3
		});
	};
	loadSmithyRpcV2CborErrorCode = (output, data$1) => {
		const sanitizeErrorCode = (rawValue) => {
			let cleanValue = rawValue;
			if (typeof cleanValue === "number") cleanValue = cleanValue.toString();
			if (cleanValue.indexOf(",") >= 0) cleanValue = cleanValue.split(",")[0];
			if (cleanValue.indexOf(":") >= 0) cleanValue = cleanValue.split(":")[0];
			if (cleanValue.indexOf("#") >= 0) cleanValue = cleanValue.split("#")[1];
			return cleanValue;
		};
		if (data$1["__type"] !== void 0) return sanitizeErrorCode(data$1["__type"]);
		const codeKey = Object.keys(data$1).find((key) => key.toLowerCase() === "code");
		if (codeKey && data$1[codeKey] !== void 0) return sanitizeErrorCode(data$1[codeKey]);
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/CborCodec.js
var import_dist_cjs$123, CborCodec, CborShapeSerializer, CborShapeDeserializer;
var init_CborCodec = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_serde();
	import_dist_cjs$123 = require_dist_cjs$43();
	init_cbor$1();
	init_parseCborBody();
	CborCodec = class extends SerdeContext {
		createSerializer() {
			const serializer = new CborShapeSerializer();
			serializer.setSerdeContext(this.serdeContext);
			return serializer;
		}
		createDeserializer() {
			const deserializer = new CborShapeDeserializer();
			deserializer.setSerdeContext(this.serdeContext);
			return deserializer;
		}
	};
	CborShapeSerializer = class extends SerdeContext {
		value;
		write(schema$3, value) {
			this.value = this.serialize(schema$3, value);
		}
		serialize(schema$3, source) {
			const ns = NormalizedSchema.of(schema$3);
			if (source == null) {
				if (ns.isIdempotencyToken()) return (0, import_dist_cjs$143.v4)();
				return source;
			}
			if (ns.isBlobSchema()) {
				if (typeof source === "string") return (this.serdeContext?.base64Decoder ?? import_dist_cjs$123.fromBase64)(source);
				return source;
			}
			if (ns.isTimestampSchema()) {
				if (typeof source === "number" || typeof source === "bigint") return dateToTag(/* @__PURE__ */ new Date(Number(source) / 1e3 | 0));
				return dateToTag(source);
			}
			if (typeof source === "function" || typeof source === "object") {
				const sourceObject = source;
				if (ns.isListSchema() && Array.isArray(sourceObject)) {
					const sparse = !!ns.getMergedTraits().sparse;
					const newArray = [];
					let i$5 = 0;
					for (const item of sourceObject) {
						const value = this.serialize(ns.getValueSchema(), item);
						if (value != null || sparse) newArray[i$5++] = value;
					}
					return newArray;
				}
				if (sourceObject instanceof Date) return dateToTag(sourceObject);
				const newObject = {};
				if (ns.isMapSchema()) {
					const sparse = !!ns.getMergedTraits().sparse;
					for (const key of Object.keys(sourceObject)) {
						const value = this.serialize(ns.getValueSchema(), sourceObject[key]);
						if (value != null || sparse) newObject[key] = value;
					}
				} else if (ns.isStructSchema()) for (const [key, memberSchema] of ns.structIterator()) {
					const value = this.serialize(memberSchema, sourceObject[key]);
					if (value != null) newObject[key] = value;
				}
				else if (ns.isDocumentSchema()) for (const key of Object.keys(sourceObject)) newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);
				return newObject;
			}
			return source;
		}
		flush() {
			const buffer$3 = cbor.serialize(this.value);
			this.value = void 0;
			return buffer$3;
		}
	};
	CborShapeDeserializer = class extends SerdeContext {
		read(schema$3, bytes) {
			const data$1 = cbor.deserialize(bytes);
			return this.readValue(schema$3, data$1);
		}
		readValue(_schema, value) {
			const ns = NormalizedSchema.of(_schema);
			if (ns.isTimestampSchema() && typeof value === "number") return _parseEpochTimestamp(value);
			if (ns.isBlobSchema()) {
				if (typeof value === "string") return (this.serdeContext?.base64Decoder ?? import_dist_cjs$123.fromBase64)(value);
				return value;
			}
			if (typeof value === "undefined" || typeof value === "boolean" || typeof value === "number" || typeof value === "string" || typeof value === "bigint" || typeof value === "symbol") return value;
			else if (typeof value === "function" || typeof value === "object") {
				if (value === null) return null;
				if ("byteLength" in value) return value;
				if (value instanceof Date) return value;
				if (ns.isDocumentSchema()) return value;
				if (ns.isListSchema()) {
					const newArray = [];
					const memberSchema = ns.getValueSchema();
					const sparse = !!ns.getMergedTraits().sparse;
					for (const item of value) {
						const itemValue = this.readValue(memberSchema, item);
						if (itemValue != null || sparse) newArray.push(itemValue);
					}
					return newArray;
				}
				const newObject = {};
				if (ns.isMapSchema()) {
					const sparse = !!ns.getMergedTraits().sparse;
					const targetSchema = ns.getValueSchema();
					for (const key of Object.keys(value)) {
						const itemValue = this.readValue(targetSchema, value[key]);
						if (itemValue != null || sparse) newObject[key] = itemValue;
					}
				} else if (ns.isStructSchema()) for (const [key, memberSchema] of ns.structIterator()) {
					const v$5 = this.readValue(memberSchema, value[key]);
					if (v$5 != null) newObject[key] = v$5;
				}
				return newObject;
			} else return value;
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/SmithyRpcV2CborProtocol.js
var import_dist_cjs$122, SmithyRpcV2CborProtocol;
var init_SmithyRpcV2CborProtocol = __esmMin((() => {
	init_protocols$1();
	init_schema();
	import_dist_cjs$122 = require_dist_cjs$48();
	init_CborCodec();
	init_parseCborBody();
	SmithyRpcV2CborProtocol = class extends RpcProtocol {
		codec = new CborCodec();
		serializer = this.codec.createSerializer();
		deserializer = this.codec.createDeserializer();
		constructor({ defaultNamespace }) {
			super({ defaultNamespace });
		}
		getShapeId() {
			return "smithy.protocols#rpcv2Cbor";
		}
		getPayloadCodec() {
			return this.codec;
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			Object.assign(request$1.headers, {
				"content-type": this.getDefaultContentType(),
				"smithy-protocol": "rpc-v2-cbor",
				accept: this.getDefaultContentType()
			});
			if (deref(operationSchema.input) === "unit") {
				delete request$1.body;
				delete request$1.headers["content-type"];
			} else {
				if (!request$1.body) {
					this.serializer.write(15, {});
					request$1.body = this.serializer.flush();
				}
				try {
					request$1.headers["content-length"] = String(request$1.body.byteLength);
				} catch (e$5) {}
			}
			const { service, operation: operation$1 } = (0, import_dist_cjs$122.getSmithyContext)(context);
			const path$6 = `/service/${service}/operation/${operation$1}`;
			if (request$1.path.endsWith("/")) request$1.path += path$6.slice(1);
			else request$1.path += path$6;
			return request$1;
		}
		async deserializeResponse(operationSchema, context, response) {
			return super.deserializeResponse(operationSchema, context, response);
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			const errorName = loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
			let namespace = this.options.defaultNamespace;
			if (errorName.includes("#")) [namespace] = errorName.split("#");
			const errorMetadata = {
				$metadata: metadata,
				$fault: response.statusCode <= 500 ? "client" : "server"
			};
			const registry = TypeRegistry.for(namespace);
			let errorSchema;
			try {
				errorSchema = registry.getSchema(errorName);
			} catch (e$5) {
				if (dataObject.Message) dataObject.message = dataObject.Message;
				const synthetic = TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
				const baseExceptionSchema = synthetic.getBaseException();
				if (baseExceptionSchema) {
					const ErrorCtor$1 = synthetic.getErrorCtor(baseExceptionSchema);
					throw Object.assign(new ErrorCtor$1({ name: errorName }), errorMetadata, dataObject);
				}
				throw Object.assign(new Error(errorName), errorMetadata, dataObject);
			}
			const ns = NormalizedSchema.of(errorSchema);
			const ErrorCtor = registry.getErrorCtor(errorSchema);
			const message = dataObject.message ?? dataObject.Message ?? "Unknown";
			const exception = new ErrorCtor(message);
			const output = {};
			for (const [name, member$1] of ns.structIterator()) output[name] = this.deserializer.readValue(member$1, dataObject[name]);
			throw Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output);
		}
		getDefaultContentType() {
			return "application/cbor";
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/cbor/index.js
var init_cbor = __esmMin((() => {
	init_parseCborBody();
	init_SmithyRpcV2CborProtocol();
	init_CborCodec();
}));

//#endregion
//#region node_modules/@smithy/middleware-stack/dist-cjs/index.js
var require_dist_cjs$29 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const getAllAliases = (name, aliases) => {
		const _aliases = [];
		if (name) _aliases.push(name);
		if (aliases) for (const alias of aliases) _aliases.push(alias);
		return _aliases;
	};
	const getMiddlewareNameWithAliases = (name, aliases) => {
		return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
	};
	const constructStack = () => {
		let absoluteEntries = [];
		let relativeEntries = [];
		let identifyOnResolve = false;
		const entriesNameSet = /* @__PURE__ */ new Set();
		const sort = (entries) => entries.sort((a$5, b$5) => stepWeights[b$5.step] - stepWeights[a$5.step] || priorityWeights[b$5.priority || "normal"] - priorityWeights[a$5.priority || "normal"]);
		const removeByName = (toRemove) => {
			let isRemoved = false;
			const filterCb = (entry) => {
				const aliases = getAllAliases(entry.name, entry.aliases);
				if (aliases.includes(toRemove)) {
					isRemoved = true;
					for (const alias of aliases) entriesNameSet.delete(alias);
					return false;
				}
				return true;
			};
			absoluteEntries = absoluteEntries.filter(filterCb);
			relativeEntries = relativeEntries.filter(filterCb);
			return isRemoved;
		};
		const removeByReference = (toRemove) => {
			let isRemoved = false;
			const filterCb = (entry) => {
				if (entry.middleware === toRemove) {
					isRemoved = true;
					for (const alias of getAllAliases(entry.name, entry.aliases)) entriesNameSet.delete(alias);
					return false;
				}
				return true;
			};
			absoluteEntries = absoluteEntries.filter(filterCb);
			relativeEntries = relativeEntries.filter(filterCb);
			return isRemoved;
		};
		const cloneTo = (toStack) => {
			absoluteEntries.forEach((entry) => {
				toStack.add(entry.middleware, { ...entry });
			});
			relativeEntries.forEach((entry) => {
				toStack.addRelativeTo(entry.middleware, { ...entry });
			});
			toStack.identifyOnResolve?.(stack.identifyOnResolve());
			return toStack;
		};
		const expandRelativeMiddlewareList = (from) => {
			const expandedMiddlewareList = [];
			from.before.forEach((entry) => {
				if (entry.before.length === 0 && entry.after.length === 0) expandedMiddlewareList.push(entry);
				else expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
			});
			expandedMiddlewareList.push(from);
			from.after.reverse().forEach((entry) => {
				if (entry.before.length === 0 && entry.after.length === 0) expandedMiddlewareList.push(entry);
				else expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
			});
			return expandedMiddlewareList;
		};
		const getMiddlewareList = (debug$2 = false) => {
			const normalizedAbsoluteEntries = [];
			const normalizedRelativeEntries = [];
			const normalizedEntriesNameMap = {};
			absoluteEntries.forEach((entry) => {
				const normalizedEntry = {
					...entry,
					before: [],
					after: []
				};
				for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) normalizedEntriesNameMap[alias] = normalizedEntry;
				normalizedAbsoluteEntries.push(normalizedEntry);
			});
			relativeEntries.forEach((entry) => {
				const normalizedEntry = {
					...entry,
					before: [],
					after: []
				};
				for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) normalizedEntriesNameMap[alias] = normalizedEntry;
				normalizedRelativeEntries.push(normalizedEntry);
			});
			normalizedRelativeEntries.forEach((entry) => {
				if (entry.toMiddleware) {
					const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
					if (toMiddleware === void 0) {
						if (debug$2) return;
						throw new Error(`${entry.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(entry.name, entry.aliases)} middleware ${entry.relation} ${entry.toMiddleware}`);
					}
					if (entry.relation === "after") toMiddleware.after.push(entry);
					if (entry.relation === "before") toMiddleware.before.push(entry);
				}
			});
			return sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList) => {
				wholeList.push(...expandedMiddlewareList);
				return wholeList;
			}, []);
		};
		const stack = {
			add: (middleware, options = {}) => {
				const { name, override, aliases: _aliases } = options;
				const entry = {
					step: "initialize",
					priority: "normal",
					middleware,
					...options
				};
				const aliases = getAllAliases(name, _aliases);
				if (aliases.length > 0) {
					if (aliases.some((alias) => entriesNameSet.has(alias))) {
						if (!override) throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
						for (const alias of aliases) {
							const toOverrideIndex = absoluteEntries.findIndex((entry$1) => entry$1.name === alias || entry$1.aliases?.some((a$5) => a$5 === alias));
							if (toOverrideIndex === -1) continue;
							const toOverride = absoluteEntries[toOverrideIndex];
							if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ${entry.priority} priority in ${entry.step} step.`);
							absoluteEntries.splice(toOverrideIndex, 1);
						}
					}
					for (const alias of aliases) entriesNameSet.add(alias);
				}
				absoluteEntries.push(entry);
			},
			addRelativeTo: (middleware, options) => {
				const { name, override, aliases: _aliases } = options;
				const entry = {
					middleware,
					...options
				};
				const aliases = getAllAliases(name, _aliases);
				if (aliases.length > 0) {
					if (aliases.some((alias) => entriesNameSet.has(alias))) {
						if (!override) throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
						for (const alias of aliases) {
							const toOverrideIndex = relativeEntries.findIndex((entry$1) => entry$1.name === alias || entry$1.aliases?.some((a$5) => a$5 === alias));
							if (toOverrideIndex === -1) continue;
							const toOverride = relativeEntries[toOverrideIndex];
							if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
							relativeEntries.splice(toOverrideIndex, 1);
						}
					}
					for (const alias of aliases) entriesNameSet.add(alias);
				}
				relativeEntries.push(entry);
			},
			clone: () => cloneTo(constructStack()),
			use: (plugin) => {
				plugin.applyToStack(stack);
			},
			remove: (toRemove) => {
				if (typeof toRemove === "string") return removeByName(toRemove);
				else return removeByReference(toRemove);
			},
			removeByTag: (toRemove) => {
				let isRemoved = false;
				const filterCb = (entry) => {
					const { tags, name, aliases: _aliases } = entry;
					if (tags && tags.includes(toRemove)) {
						const aliases = getAllAliases(name, _aliases);
						for (const alias of aliases) entriesNameSet.delete(alias);
						isRemoved = true;
						return false;
					}
					return true;
				};
				absoluteEntries = absoluteEntries.filter(filterCb);
				relativeEntries = relativeEntries.filter(filterCb);
				return isRemoved;
			},
			concat: (from) => {
				const cloned = cloneTo(constructStack());
				cloned.use(from);
				cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
				return cloned;
			},
			applyToStack: cloneTo,
			identify: () => {
				return getMiddlewareList(true).map((mw) => {
					const step = mw.step ?? mw.relation + " " + mw.toMiddleware;
					return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
				});
			},
			identifyOnResolve(toggle) {
				if (typeof toggle === "boolean") identifyOnResolve = toggle;
				return identifyOnResolve;
			},
			resolve: (handler, context) => {
				for (const middleware of getMiddlewareList().map((entry) => entry.middleware).reverse()) handler = middleware(handler, context);
				if (identifyOnResolve) console.log(stack.identify());
				return handler;
			}
		};
		return stack;
	};
	const stepWeights = {
		initialize: 5,
		serialize: 4,
		build: 3,
		finalizeRequest: 2,
		deserialize: 1
	};
	const priorityWeights = {
		high: 3,
		normal: 2,
		low: 1
	};
	exports.constructStack = constructStack;
}));

//#endregion
//#region node_modules/@smithy/smithy-client/dist-cjs/index.js
var require_dist_cjs$28 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var middlewareStack = require_dist_cjs$29();
	var protocols = (init_protocols$1(), __toCommonJS(protocols_exports$1));
	var types$1 = require_dist_cjs$53();
	var schema$2 = (init_schema(), __toCommonJS(schema_exports));
	var serde = (init_serde(), __toCommonJS(serde_exports));
	var Client = class {
		config;
		middlewareStack = middlewareStack.constructStack();
		initConfig;
		handlers;
		constructor(config) {
			this.config = config;
		}
		send(command, optionsOrCb, cb) {
			const options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
			const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
			const useHandlerCache = options === void 0 && this.config.cacheMiddleware === true;
			let handler;
			if (useHandlerCache) {
				if (!this.handlers) this.handlers = /* @__PURE__ */ new WeakMap();
				const handlers = this.handlers;
				if (handlers.has(command.constructor)) handler = handlers.get(command.constructor);
				else {
					handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
					handlers.set(command.constructor, handler);
				}
			} else {
				delete this.handlers;
				handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
			}
			if (callback) handler(command).then((result) => callback(null, result.output), (err) => callback(err)).catch(() => {});
			else return handler(command).then((result) => result.output);
		}
		destroy() {
			this.config?.requestHandler?.destroy?.();
			delete this.handlers;
		}
	};
	const SENSITIVE_STRING$1 = "***SensitiveInformation***";
	function schemaLogFilter(schema$1$1, data$1) {
		if (data$1 == null) return data$1;
		const ns = schema$2.NormalizedSchema.of(schema$1$1);
		if (ns.getMergedTraits().sensitive) return SENSITIVE_STRING$1;
		if (ns.isListSchema()) {
			if (!!ns.getValueSchema().getMergedTraits().sensitive) return SENSITIVE_STRING$1;
		} else if (ns.isMapSchema()) {
			if (!!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive) return SENSITIVE_STRING$1;
		} else if (ns.isStructSchema() && typeof data$1 === "object") {
			const object = data$1;
			const newObject = {};
			for (const [member$1, memberNs] of ns.structIterator()) if (object[member$1] != null) newObject[member$1] = schemaLogFilter(memberNs, object[member$1]);
			return newObject;
		}
		return data$1;
	}
	var Command = class {
		middlewareStack = middlewareStack.constructStack();
		schema;
		static classBuilder() {
			return new ClassBuilder();
		}
		resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor }) {
			for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) this.middlewareStack.use(mw);
			const stack = clientStack.concat(this.middlewareStack);
			const { logger: logger$1 } = configuration;
			const handlerExecutionContext = {
				logger: logger$1,
				clientName,
				commandName,
				inputFilterSensitiveLog,
				outputFilterSensitiveLog,
				[types$1.SMITHY_CONTEXT_KEY]: {
					commandInstance: this,
					...smithyContext
				},
				...additionalContext
			};
			const { requestHandler } = configuration;
			return stack.resolve((request$1) => requestHandler.handle(request$1.request, options || {}), handlerExecutionContext);
		}
	};
	var ClassBuilder = class {
		_init = () => {};
		_ep = {};
		_middlewareFn = () => [];
		_commandName = "";
		_clientName = "";
		_additionalContext = {};
		_smithyContext = {};
		_inputFilterSensitiveLog = void 0;
		_outputFilterSensitiveLog = void 0;
		_serializer = null;
		_deserializer = null;
		_operationSchema;
		init(cb) {
			this._init = cb;
		}
		ep(endpointParameterInstructions) {
			this._ep = endpointParameterInstructions;
			return this;
		}
		m(middlewareSupplier) {
			this._middlewareFn = middlewareSupplier;
			return this;
		}
		s(service, operation$1, smithyContext = {}) {
			this._smithyContext = {
				service,
				operation: operation$1,
				...smithyContext
			};
			return this;
		}
		c(additionalContext = {}) {
			this._additionalContext = additionalContext;
			return this;
		}
		n(clientName, commandName) {
			this._clientName = clientName;
			this._commandName = commandName;
			return this;
		}
		f(inputFilter = (_) => _, outputFilter = (_) => _) {
			this._inputFilterSensitiveLog = inputFilter;
			this._outputFilterSensitiveLog = outputFilter;
			return this;
		}
		ser(serializer) {
			this._serializer = serializer;
			return this;
		}
		de(deserializer) {
			this._deserializer = deserializer;
			return this;
		}
		sc(operation$1) {
			this._operationSchema = operation$1;
			this._smithyContext.operationSchema = operation$1;
			return this;
		}
		build() {
			const closure = this;
			let CommandRef;
			return CommandRef = class extends Command {
				input;
				static getEndpointParameterInstructions() {
					return closure._ep;
				}
				constructor(...[input]) {
					super();
					this.input = input ?? {};
					closure._init(this);
					this.schema = closure._operationSchema;
				}
				resolveMiddleware(stack, configuration, options) {
					const op$1 = closure._operationSchema;
					const input = op$1?.[4] ?? op$1?.input;
					const output = op$1?.[5] ?? op$1?.output;
					return this.resolveMiddlewareWithContext(stack, configuration, options, {
						CommandCtor: CommandRef,
						middlewareFn: closure._middlewareFn,
						clientName: closure._clientName,
						commandName: closure._commandName,
						inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op$1 ? schemaLogFilter.bind(null, input) : (_) => _),
						outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op$1 ? schemaLogFilter.bind(null, output) : (_) => _),
						smithyContext: closure._smithyContext,
						additionalContext: closure._additionalContext
					});
				}
				serialize = closure._serializer;
				deserialize = closure._deserializer;
			};
		}
	};
	const SENSITIVE_STRING = "***SensitiveInformation***";
	const createAggregatedClient$3 = (commands$5, Client$6) => {
		for (const command of Object.keys(commands$5)) {
			const CommandCtor = commands$5[command];
			const methodImpl = async function(args, optionsOrCb, cb) {
				const command$1 = new CommandCtor(args);
				if (typeof optionsOrCb === "function") this.send(command$1, optionsOrCb);
				else if (typeof cb === "function") {
					if (typeof optionsOrCb !== "object") throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
					this.send(command$1, optionsOrCb || {}, cb);
				} else return this.send(command$1, optionsOrCb);
			};
			const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
			Client$6.prototype[methodName] = methodImpl;
		}
	};
	var ServiceException = class ServiceException extends Error {
		$fault;
		$response;
		$retryable;
		$metadata;
		constructor(options) {
			super(options.message);
			Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
			this.name = options.name;
			this.$fault = options.$fault;
			this.$metadata = options.$metadata;
		}
		static isInstance(value) {
			if (!value) return false;
			const candidate = value;
			return ServiceException.prototype.isPrototypeOf(candidate) || Boolean(candidate.$fault) && Boolean(candidate.$metadata) && (candidate.$fault === "client" || candidate.$fault === "server");
		}
		static [Symbol.hasInstance](instance) {
			if (!instance) return false;
			const candidate = instance;
			if (this === ServiceException) return ServiceException.isInstance(instance);
			if (ServiceException.isInstance(instance)) {
				if (candidate.name && this.name) return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
				return this.prototype.isPrototypeOf(instance);
			}
			return false;
		}
	};
	const decorateServiceException$1 = (exception, additions = {}) => {
		Object.entries(additions).filter(([, v$5]) => v$5 !== void 0).forEach(([k$5, v$5]) => {
			if (exception[k$5] == void 0 || exception[k$5] === "") exception[k$5] = v$5;
		});
		exception.message = exception.message || exception.Message || "UnknownError";
		delete exception.Message;
		return exception;
	};
	const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
		const $metadata = deserializeMetadata(output);
		const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : void 0;
		throw decorateServiceException$1(new exceptionCtor({
			name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
			$fault: "client",
			$metadata
		}), parsedBody);
	};
	const withBaseException = (ExceptionCtor) => {
		return ({ output, parsedBody, errorCode }) => {
			throwDefaultError({
				output,
				parsedBody,
				exceptionCtor: ExceptionCtor,
				errorCode
			});
		};
	};
	const deserializeMetadata = (output) => ({
		httpStatusCode: output.statusCode,
		requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
		extendedRequestId: output.headers["x-amz-id-2"],
		cfId: output.headers["x-amz-cf-id"]
	});
	const loadConfigsForDefaultMode$3 = (mode) => {
		switch (mode) {
			case "standard": return {
				retryMode: "standard",
				connectionTimeout: 3100
			};
			case "in-region": return {
				retryMode: "standard",
				connectionTimeout: 1100
			};
			case "cross-region": return {
				retryMode: "standard",
				connectionTimeout: 3100
			};
			case "mobile": return {
				retryMode: "standard",
				connectionTimeout: 3e4
			};
			default: return {};
		}
	};
	let warningEmitted = false;
	const emitWarningIfUnsupportedVersion$4 = (version$1) => {
		if (version$1 && !warningEmitted && parseInt(version$1.substring(1, version$1.indexOf("."))) < 16) warningEmitted = true;
	};
	const getChecksumConfiguration = (runtimeConfig$2) => {
		const checksumAlgorithms = [];
		for (const id in types$1.AlgorithmId) {
			const algorithmId = types$1.AlgorithmId[id];
			if (runtimeConfig$2[algorithmId] === void 0) continue;
			checksumAlgorithms.push({
				algorithmId: () => algorithmId,
				checksumConstructor: () => runtimeConfig$2[algorithmId]
			});
		}
		return {
			addChecksumAlgorithm(algo) {
				checksumAlgorithms.push(algo);
			},
			checksumAlgorithms() {
				return checksumAlgorithms;
			}
		};
	};
	const resolveChecksumRuntimeConfig = (clientConfig) => {
		const runtimeConfig$2 = {};
		clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
			runtimeConfig$2[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
		});
		return runtimeConfig$2;
	};
	const getRetryConfiguration = (runtimeConfig$2) => {
		return {
			setRetryStrategy(retryStrategy) {
				runtimeConfig$2.retryStrategy = retryStrategy;
			},
			retryStrategy() {
				return runtimeConfig$2.retryStrategy;
			}
		};
	};
	const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
		const runtimeConfig$2 = {};
		runtimeConfig$2.retryStrategy = retryStrategyConfiguration.retryStrategy();
		return runtimeConfig$2;
	};
	const getDefaultExtensionConfiguration$3 = (runtimeConfig$2) => {
		return Object.assign(getChecksumConfiguration(runtimeConfig$2), getRetryConfiguration(runtimeConfig$2));
	};
	const getDefaultClientConfiguration = getDefaultExtensionConfiguration$3;
	const resolveDefaultRuntimeConfig$3 = (config) => {
		return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
	};
	const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];
	const getValueFromTextNode$2 = (obj) => {
		const textNodeName = "#text";
		for (const key in obj) if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== void 0) obj[key] = obj[key][textNodeName];
		else if (typeof obj[key] === "object" && obj[key] !== null) obj[key] = getValueFromTextNode$2(obj[key]);
		return obj;
	};
	const isSerializableHeaderValue = (value) => {
		return value != null;
	};
	var NoOpLogger$3 = class {
		trace() {}
		debug() {}
		info() {}
		warn() {}
		error() {}
	};
	function map(arg0, arg1, arg2) {
		let target;
		let filter;
		let instructions;
		if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
			target = {};
			instructions = arg0;
		} else {
			target = arg0;
			if (typeof arg1 === "function") {
				filter = arg1;
				instructions = arg2;
				return mapWithFilter(target, filter, instructions);
			} else instructions = arg1;
		}
		for (const key of Object.keys(instructions)) {
			if (!Array.isArray(instructions[key])) {
				target[key] = instructions[key];
				continue;
			}
			applyInstruction(target, null, instructions, key);
		}
		return target;
	}
	const convertMap = (target) => {
		const output = {};
		for (const [k$5, v$5] of Object.entries(target || {})) output[k$5] = [, v$5];
		return output;
	};
	const take = (source, instructions) => {
		const out = {};
		for (const key in instructions) applyInstruction(out, source, instructions, key);
		return out;
	};
	const mapWithFilter = (target, filter, instructions) => {
		return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
			if (Array.isArray(value)) _instructions[key] = value;
			else if (typeof value === "function") _instructions[key] = [filter, value()];
			else _instructions[key] = [filter, value];
			return _instructions;
		}, {}));
	};
	const applyInstruction = (target, source, instructions, targetKey) => {
		if (source !== null) {
			let instruction = instructions[targetKey];
			if (typeof instruction === "function") instruction = [, instruction];
			const [filter$1 = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
			if (typeof filter$1 === "function" && filter$1(source[sourceKey]) || typeof filter$1 !== "function" && !!filter$1) target[targetKey] = valueFn(source[sourceKey]);
			return;
		}
		let [filter, value] = instructions[targetKey];
		if (typeof value === "function") {
			let _value;
			const defaultFilterPassed = filter === void 0 && (_value = value()) != null;
			const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
			if (defaultFilterPassed) target[targetKey] = _value;
			else if (customFilterPassed) target[targetKey] = value();
		} else {
			const defaultFilterPassed = filter === void 0 && value != null;
			const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
			if (defaultFilterPassed || customFilterPassed) target[targetKey] = value;
		}
	};
	const nonNullish = (_) => _ != null;
	const pass = (_) => _;
	const serializeFloat = (value) => {
		if (value !== value) return "NaN";
		switch (value) {
			case Infinity: return "Infinity";
			case -Infinity: return "-Infinity";
			default: return value;
		}
	};
	const serializeDateTime = (date$1) => date$1.toISOString().replace(".000Z", "Z");
	const _json = (obj) => {
		if (obj == null) return {};
		if (Array.isArray(obj)) return obj.filter((_) => _ != null).map(_json);
		if (typeof obj === "object") {
			const target = {};
			for (const key of Object.keys(obj)) {
				if (obj[key] == null) continue;
				target[key] = _json(obj[key]);
			}
			return target;
		}
		return obj;
	};
	Object.defineProperty(exports, "collectBody", {
		enumerable: true,
		get: function() {
			return protocols.collectBody;
		}
	});
	Object.defineProperty(exports, "extendedEncodeURIComponent", {
		enumerable: true,
		get: function() {
			return protocols.extendedEncodeURIComponent;
		}
	});
	Object.defineProperty(exports, "resolvedPath", {
		enumerable: true,
		get: function() {
			return protocols.resolvedPath;
		}
	});
	exports.Client = Client;
	exports.Command = Command;
	exports.NoOpLogger = NoOpLogger$3;
	exports.SENSITIVE_STRING = SENSITIVE_STRING;
	exports.ServiceException = ServiceException;
	exports._json = _json;
	exports.convertMap = convertMap;
	exports.createAggregatedClient = createAggregatedClient$3;
	exports.decorateServiceException = decorateServiceException$1;
	exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion$4;
	exports.getArrayIfSingleItem = getArrayIfSingleItem;
	exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
	exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration$3;
	exports.getValueFromTextNode = getValueFromTextNode$2;
	exports.isSerializableHeaderValue = isSerializableHeaderValue;
	exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode$3;
	exports.map = map;
	exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig$3;
	exports.serializeDateTime = serializeDateTime;
	exports.serializeFloat = serializeFloat;
	exports.take = take;
	exports.throwDefaultError = throwDefaultError;
	exports.withBaseException = withBaseException;
	Object.keys(serde).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return serde[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/ProtocolLib.js
var import_dist_cjs$121, ProtocolLib;
var init_ProtocolLib = __esmMin((() => {
	init_schema();
	import_dist_cjs$121 = require_dist_cjs$28();
	ProtocolLib = class {
		queryCompat;
		constructor(queryCompat = false) {
			this.queryCompat = queryCompat;
		}
		resolveRestContentType(defaultContentType, inputSchema) {
			const members = inputSchema.getMemberSchemas();
			const httpPayloadMember = Object.values(members).find((m$5) => {
				return !!m$5.getMergedTraits().httpPayload;
			});
			if (httpPayloadMember) {
				const mediaType = httpPayloadMember.getMergedTraits().mediaType;
				if (mediaType) return mediaType;
				else if (httpPayloadMember.isStringSchema()) return "text/plain";
				else if (httpPayloadMember.isBlobSchema()) return "application/octet-stream";
				else return defaultContentType;
			} else if (!inputSchema.isUnitSchema()) {
				if (Object.values(members).find((m$5) => {
					const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m$5.getMergedTraits();
					return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && httpPrefixHeaders === void 0;
				})) return defaultContentType;
			}
		}
		async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
			let namespace = defaultNamespace;
			let errorName = errorIdentifier;
			if (errorIdentifier.includes("#")) [namespace, errorName] = errorIdentifier.split("#");
			const errorMetadata = {
				$metadata: metadata,
				$fault: response.statusCode < 500 ? "client" : "server"
			};
			const registry = TypeRegistry.for(namespace);
			try {
				return {
					errorSchema: getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier),
					errorMetadata
				};
			} catch (e$5) {
				dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
				const synthetic = TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
				const baseExceptionSchema = synthetic.getBaseException();
				if (baseExceptionSchema) {
					const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
					throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
				}
				throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
			}
		}
		decorateServiceException(exception, additions = {}) {
			if (this.queryCompat) {
				const msg = exception.Message ?? additions.Message;
				const error$2 = (0, import_dist_cjs$121.decorateServiceException)(exception, additions);
				if (msg) {
					error$2.Message = msg;
					error$2.message = msg;
				}
				return error$2;
			}
			return (0, import_dist_cjs$121.decorateServiceException)(exception, additions);
		}
		setQueryCompatError(output, response) {
			const queryErrorHeader = response.headers?.["x-amzn-query-error"];
			if (output !== void 0 && queryErrorHeader != null) {
				const [Code, Type] = queryErrorHeader.split(";");
				const entries = Object.entries(output);
				const Error$1 = {
					Code,
					Type
				};
				Object.assign(output, Error$1);
				for (const [k$5, v$5] of entries) Error$1[k$5] = v$5;
				delete Error$1.__type;
				output.Error = Error$1;
			}
		}
		queryCompatOutput(queryCompatErrorData, errorData) {
			if (queryCompatErrorData.Error) errorData.Error = queryCompatErrorData.Error;
			if (queryCompatErrorData.Type) errorData.Type = queryCompatErrorData.Type;
			if (queryCompatErrorData.Code) errorData.Code = queryCompatErrorData.Code;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/cbor/AwsSmithyRpcV2CborProtocol.js
var AwsSmithyRpcV2CborProtocol;
var init_AwsSmithyRpcV2CborProtocol = __esmMin((() => {
	init_cbor();
	init_schema();
	init_ProtocolLib();
	AwsSmithyRpcV2CborProtocol = class extends SmithyRpcV2CborProtocol {
		awsQueryCompatible;
		mixin;
		constructor({ defaultNamespace, awsQueryCompatible }) {
			super({ defaultNamespace });
			this.awsQueryCompatible = !!awsQueryCompatible;
			this.mixin = new ProtocolLib(this.awsQueryCompatible);
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			if (this.awsQueryCompatible) request$1.headers["x-amzn-query-mode"] = "true";
			return request$1;
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			if (this.awsQueryCompatible) this.mixin.setQueryCompatError(dataObject, response);
			const errorName = loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
			const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata);
			const ns = NormalizedSchema.of(errorSchema);
			const message = dataObject.message ?? dataObject.Message ?? "Unknown";
			const exception = new ((TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema)) ?? Error)(message);
			const output = {};
			for (const [name, member$1] of ns.structIterator()) output[name] = this.deserializer.readValue(member$1, dataObject[name]);
			if (this.awsQueryCompatible) this.mixin.queryCompatOutput(dataObject, output);
			throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output), dataObject);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/coercing-serializers.js
var _toStr, _toBool, _toNum;
var init_coercing_serializers = __esmMin((() => {
	_toStr = (val) => {
		if (val == null) return val;
		if (typeof val === "number" || typeof val === "bigint") {
			const warning$1 = /* @__PURE__ */ new Error(`Received number ${val} where a string was expected.`);
			warning$1.name = "Warning";
			console.warn(warning$1);
			return String(val);
		}
		if (typeof val === "boolean") {
			const warning$1 = /* @__PURE__ */ new Error(`Received boolean ${val} where a string was expected.`);
			warning$1.name = "Warning";
			console.warn(warning$1);
			return String(val);
		}
		return val;
	};
	_toBool = (val) => {
		if (val == null) return val;
		if (typeof val === "number") {}
		if (typeof val === "string") {
			const lowercase = val.toLowerCase();
			if (val !== "" && lowercase !== "false" && lowercase !== "true") {
				const warning$1 = /* @__PURE__ */ new Error(`Received string "${val}" where a boolean was expected.`);
				warning$1.name = "Warning";
				console.warn(warning$1);
			}
			return val !== "" && lowercase !== "false";
		}
		return val;
	};
	_toNum = (val) => {
		if (val == null) return val;
		if (typeof val === "boolean") {}
		if (typeof val === "string") {
			const num = Number(val);
			if (num.toString() !== val) {
				const warning$1 = /* @__PURE__ */ new Error(`Received string "${val}" where a number was expected.`);
				warning$1.name = "Warning";
				console.warn(warning$1);
				return val;
			}
			return num;
		}
		return val;
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/ConfigurableSerdeContext.js
var SerdeContextConfig;
var init_ConfigurableSerdeContext = __esmMin((() => {
	SerdeContextConfig = class {
		serdeContext;
		setSerdeContext(serdeContext) {
			this.serdeContext = serdeContext;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/structIterator.js
function* serializingStructIterator(ns, sourceObject) {
	if (ns.isUnitSchema()) return;
	const struct$1 = ns.getSchema();
	for (let i$5 = 0; i$5 < struct$1[4].length; ++i$5) {
		const key = struct$1[4][i$5];
		const memberNs = new NormalizedSchema([struct$1[5][i$5], 0], key);
		if (!(key in sourceObject) && !memberNs.isIdempotencyToken()) continue;
		yield [key, memberNs];
	}
}
function* deserializingStructIterator(ns, sourceObject, nameTrait) {
	if (ns.isUnitSchema()) return;
	const struct$1 = ns.getSchema();
	let keysRemaining = Object.keys(sourceObject).length;
	for (let i$5 = 0; i$5 < struct$1[4].length; ++i$5) {
		if (keysRemaining === 0) break;
		const key = struct$1[4][i$5];
		const memberNs = new NormalizedSchema([struct$1[5][i$5], 0], key);
		let serializationKey = key;
		if (nameTrait) serializationKey = memberNs.getMergedTraits()[nameTrait] ?? key;
		if (!(serializationKey in sourceObject)) continue;
		yield [key, memberNs];
		keysRemaining -= 1;
	}
}
var init_structIterator = __esmMin((() => {
	init_schema();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReviver.js
function jsonReviver(key, value, context) {
	if (context?.source) {
		const numericString = context.source;
		if (typeof value === "number") {
			if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) if (numericString.includes(".")) return new NumericValue(numericString, "bigDecimal");
			else return BigInt(numericString);
		}
	}
	return value;
}
var init_jsonReviver = __esmMin((() => {
	init_serde();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/common.js
var import_dist_cjs$119, import_dist_cjs$120, collectBodyString;
var init_common = __esmMin((() => {
	import_dist_cjs$119 = require_dist_cjs$28();
	import_dist_cjs$120 = require_dist_cjs$44();
	collectBodyString = (streamBody, context) => (0, import_dist_cjs$119.collectBody)(streamBody, context).then((body) => (context?.utf8Encoder ?? import_dist_cjs$120.toUtf8)(body));
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/parseJsonBody.js
var parseJsonBody, parseJsonErrorBody, loadRestJsonErrorCode;
var init_parseJsonBody = __esmMin((() => {
	init_common();
	parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
		if (encoded.length) try {
			return JSON.parse(encoded);
		} catch (e$5) {
			if (e$5?.name === "SyntaxError") Object.defineProperty(e$5, "$responseBodyText", { value: encoded });
			throw e$5;
		}
		return {};
	});
	parseJsonErrorBody = async (errorBody, context) => {
		const value = await parseJsonBody(errorBody, context);
		value.message = value.message ?? value.Message;
		return value;
	};
	loadRestJsonErrorCode = (output, data$1) => {
		const findKey = (object, key) => Object.keys(object).find((k$5) => k$5.toLowerCase() === key.toLowerCase());
		const sanitizeErrorCode = (rawValue) => {
			let cleanValue = rawValue;
			if (typeof cleanValue === "number") cleanValue = cleanValue.toString();
			if (cleanValue.indexOf(",") >= 0) cleanValue = cleanValue.split(",")[0];
			if (cleanValue.indexOf(":") >= 0) cleanValue = cleanValue.split(":")[0];
			if (cleanValue.indexOf("#") >= 0) cleanValue = cleanValue.split("#")[1];
			return cleanValue;
		};
		const headerKey = findKey(output.headers, "x-amzn-errortype");
		if (headerKey !== void 0) return sanitizeErrorCode(output.headers[headerKey]);
		if (data$1 && typeof data$1 === "object") {
			const codeKey = findKey(data$1, "code");
			if (codeKey && data$1[codeKey] !== void 0) return sanitizeErrorCode(data$1[codeKey]);
			if (data$1["__type"] !== void 0) return sanitizeErrorCode(data$1["__type"]);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeDeserializer.js
var import_dist_cjs$118, JsonShapeDeserializer;
var init_JsonShapeDeserializer = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_serde();
	import_dist_cjs$118 = require_dist_cjs$43();
	init_ConfigurableSerdeContext();
	init_structIterator();
	init_jsonReviver();
	init_parseJsonBody();
	JsonShapeDeserializer = class extends SerdeContextConfig {
		settings;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		async read(schema$3, data$1) {
			return this._read(schema$3, typeof data$1 === "string" ? JSON.parse(data$1, jsonReviver) : await parseJsonBody(data$1, this.serdeContext));
		}
		readObject(schema$3, data$1) {
			return this._read(schema$3, data$1);
		}
		_read(schema$3, value) {
			const isObject = value !== null && typeof value === "object";
			const ns = NormalizedSchema.of(schema$3);
			if (ns.isListSchema() && Array.isArray(value)) {
				const listMember = ns.getValueSchema();
				const out = [];
				const sparse = !!ns.getMergedTraits().sparse;
				for (const item of value) if (sparse || item != null) out.push(this._read(listMember, item));
				return out;
			} else if (ns.isMapSchema() && isObject) {
				const mapMember = ns.getValueSchema();
				const out = {};
				const sparse = !!ns.getMergedTraits().sparse;
				for (const [_k, _v] of Object.entries(value)) if (sparse || _v != null) out[_k] = this._read(mapMember, _v);
				return out;
			} else if (ns.isStructSchema() && isObject) {
				const out = {};
				for (const [memberName, memberSchema] of deserializingStructIterator(ns, value, this.settings.jsonName ? "jsonName" : false)) {
					const fromKey = this.settings.jsonName ? memberSchema.getMergedTraits().jsonName ?? memberName : memberName;
					const deserializedValue = this._read(memberSchema, value[fromKey]);
					if (deserializedValue != null) out[memberName] = deserializedValue;
				}
				return out;
			}
			if (ns.isBlobSchema() && typeof value === "string") return (0, import_dist_cjs$118.fromBase64)(value);
			const mediaType = ns.getMergedTraits().mediaType;
			if (ns.isStringSchema() && typeof value === "string" && mediaType) {
				if (mediaType === "application/json" || mediaType.endsWith("+json")) return LazyJsonString.from(value);
			}
			if (ns.isTimestampSchema() && value != null) switch (determineTimestampFormat(ns, this.settings)) {
				case 5: return parseRfc3339DateTimeWithOffset(value);
				case 6: return parseRfc7231DateTime(value);
				case 7: return parseEpochTimestamp(value);
				default:
					console.warn("Missing timestamp format, parsing value with Date constructor:", value);
					return new Date(value);
			}
			if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) return BigInt(value);
			if (ns.isBigDecimalSchema() && value != void 0) {
				if (value instanceof NumericValue) return value;
				const untyped = value;
				if (untyped.type === "bigDecimal" && "string" in untyped) return new NumericValue(untyped.string, untyped.type);
				return new NumericValue(String(value), "bigDecimal");
			}
			if (ns.isNumericSchema() && typeof value === "string") switch (value) {
				case "Infinity": return Infinity;
				case "-Infinity": return -Infinity;
				case "NaN": return NaN;
			}
			if (ns.isDocumentSchema()) if (isObject) {
				const out = Array.isArray(value) ? [] : {};
				for (const [k$5, v$5] of Object.entries(value)) if (v$5 instanceof NumericValue) out[k$5] = v$5;
				else out[k$5] = this._read(ns, v$5);
				return out;
			} else return structuredClone(value);
			return value;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/jsonReplacer.js
var NUMERIC_CONTROL_CHAR, JsonReplacer;
var init_jsonReplacer = __esmMin((() => {
	init_serde();
	NUMERIC_CONTROL_CHAR = String.fromCharCode(925);
	JsonReplacer = class {
		values = /* @__PURE__ */ new Map();
		counter = 0;
		stage = 0;
		createReplacer() {
			if (this.stage === 1) throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
			if (this.stage === 2) throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
			this.stage = 1;
			return (key, value) => {
				if (value instanceof NumericValue) {
					const v$5 = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
					this.values.set(`"${v$5}"`, value.string);
					return v$5;
				}
				if (typeof value === "bigint") {
					const s$5 = value.toString();
					const v$5 = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s$5;
					this.values.set(`"${v$5}"`, s$5);
					return v$5;
				}
				return value;
			};
		}
		replaceInJson(json) {
			if (this.stage === 0) throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
			if (this.stage === 2) throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
			this.stage = 2;
			if (this.counter === 0) return json;
			for (const [key, value] of this.values) json = json.replace(key, value);
			return json;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonShapeSerializer.js
var import_dist_cjs$117, JsonShapeSerializer;
var init_JsonShapeSerializer = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_serde();
	import_dist_cjs$117 = require_dist_cjs$43();
	init_ConfigurableSerdeContext();
	init_structIterator();
	init_jsonReplacer();
	JsonShapeSerializer = class extends SerdeContextConfig {
		settings;
		buffer;
		rootSchema;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		write(schema$3, value) {
			this.rootSchema = NormalizedSchema.of(schema$3);
			this.buffer = this._write(this.rootSchema, value);
		}
		writeDiscriminatedDocument(schema$3, value) {
			this.write(schema$3, value);
			if (typeof this.buffer === "object") this.buffer.__type = NormalizedSchema.of(schema$3).getName(true);
		}
		flush() {
			const { rootSchema } = this;
			this.rootSchema = void 0;
			if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
				const replacer = new JsonReplacer();
				return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
			}
			return this.buffer;
		}
		_write(schema$3, value, container) {
			const isObject = value !== null && typeof value === "object";
			const ns = NormalizedSchema.of(schema$3);
			if (ns.isListSchema() && Array.isArray(value)) {
				const listMember = ns.getValueSchema();
				const out = [];
				const sparse = !!ns.getMergedTraits().sparse;
				for (const item of value) if (sparse || item != null) out.push(this._write(listMember, item));
				return out;
			} else if (ns.isMapSchema() && isObject) {
				const mapMember = ns.getValueSchema();
				const out = {};
				const sparse = !!ns.getMergedTraits().sparse;
				for (const [_k, _v] of Object.entries(value)) if (sparse || _v != null) out[_k] = this._write(mapMember, _v);
				return out;
			} else if (ns.isStructSchema() && isObject) {
				const out = {};
				for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {
					const serializableValue = this._write(memberSchema, value[memberName], ns);
					if (serializableValue !== void 0) {
						const targetKey = this.settings.jsonName ? memberSchema.getMergedTraits().jsonName ?? memberName : memberName;
						out[targetKey] = serializableValue;
					}
				}
				return out;
			}
			if (value === null && container?.isStructSchema()) return;
			if (ns.isBlobSchema() && (value instanceof Uint8Array || typeof value === "string") || ns.isDocumentSchema() && value instanceof Uint8Array) {
				if (ns === this.rootSchema) return value;
				return (this.serdeContext?.base64Encoder ?? import_dist_cjs$117.toBase64)(value);
			}
			if ((ns.isTimestampSchema() || ns.isDocumentSchema()) && value instanceof Date) switch (determineTimestampFormat(ns, this.settings)) {
				case 5: return value.toISOString().replace(".000Z", "Z");
				case 6: return dateToUtcString$2(value);
				case 7: return value.getTime() / 1e3;
				default:
					console.warn("Missing timestamp format, using epoch seconds", value);
					return value.getTime() / 1e3;
			}
			if (ns.isNumericSchema() && typeof value === "number") {
				if (Math.abs(value) === Infinity || isNaN(value)) return String(value);
			}
			if (ns.isStringSchema()) {
				if (typeof value === "undefined" && ns.isIdempotencyToken()) return (0, import_dist_cjs$143.v4)();
				const mediaType = ns.getMergedTraits().mediaType;
				if (value != null && mediaType) {
					if (mediaType === "application/json" || mediaType.endsWith("+json")) return LazyJsonString.from(value);
				}
			}
			if (ns.isDocumentSchema()) if (isObject) {
				const out = Array.isArray(value) ? [] : {};
				for (const [k$5, v$5] of Object.entries(value)) if (v$5 instanceof NumericValue) out[k$5] = v$5;
				else out[k$5] = this._write(ns, v$5);
				return out;
			} else return structuredClone(value);
			return value;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/JsonCodec.js
var JsonCodec;
var init_JsonCodec = __esmMin((() => {
	init_ConfigurableSerdeContext();
	init_JsonShapeDeserializer();
	init_JsonShapeSerializer();
	JsonCodec = class extends SerdeContextConfig {
		settings;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		createSerializer() {
			const serializer = new JsonShapeSerializer(this.settings);
			serializer.setSerdeContext(this.serdeContext);
			return serializer;
		}
		createDeserializer() {
			const deserializer = new JsonShapeDeserializer(this.settings);
			deserializer.setSerdeContext(this.serdeContext);
			return deserializer;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJsonRpcProtocol.js
var AwsJsonRpcProtocol;
var init_AwsJsonRpcProtocol = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_ProtocolLib();
	init_JsonCodec();
	init_parseJsonBody();
	AwsJsonRpcProtocol = class extends RpcProtocol {
		serializer;
		deserializer;
		serviceTarget;
		codec;
		mixin;
		awsQueryCompatible;
		constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
			super({ defaultNamespace });
			this.serviceTarget = serviceTarget;
			this.codec = new JsonCodec({
				timestampFormat: {
					useTrait: true,
					default: 7
				},
				jsonName: false
			});
			this.serializer = this.codec.createSerializer();
			this.deserializer = this.codec.createDeserializer();
			this.awsQueryCompatible = !!awsQueryCompatible;
			this.mixin = new ProtocolLib(this.awsQueryCompatible);
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			if (!request$1.path.endsWith("/")) request$1.path += "/";
			Object.assign(request$1.headers, {
				"content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
				"x-amz-target": `${this.serviceTarget}.${operationSchema.name}`
			});
			if (this.awsQueryCompatible) request$1.headers["x-amzn-query-mode"] = "true";
			if (deref(operationSchema.input) === "unit" || !request$1.body) request$1.body = "{}";
			return request$1;
		}
		getPayloadCodec() {
			return this.codec;
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			if (this.awsQueryCompatible) this.mixin.setQueryCompatError(dataObject, response);
			const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
			const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
			const ns = NormalizedSchema.of(errorSchema);
			const message = dataObject.message ?? dataObject.Message ?? "Unknown";
			const exception = new ((TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema)) ?? Error)(message);
			const output = {};
			for (const [name, member$1] of ns.structIterator()) {
				const target = member$1.getMergedTraits().jsonName ?? name;
				output[name] = this.codec.createDeserializer().readObject(member$1, dataObject[target]);
			}
			if (this.awsQueryCompatible) this.mixin.queryCompatOutput(dataObject, output);
			throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output), dataObject);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_0Protocol.js
var AwsJson1_0Protocol;
var init_AwsJson1_0Protocol = __esmMin((() => {
	init_AwsJsonRpcProtocol();
	AwsJson1_0Protocol = class extends AwsJsonRpcProtocol {
		constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
			super({
				defaultNamespace,
				serviceTarget,
				awsQueryCompatible
			});
		}
		getShapeId() {
			return "aws.protocols#awsJson1_0";
		}
		getJsonRpcVersion() {
			return "1.0";
		}
		getDefaultContentType() {
			return "application/x-amz-json-1.0";
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsJson1_1Protocol.js
var AwsJson1_1Protocol;
var init_AwsJson1_1Protocol = __esmMin((() => {
	init_AwsJsonRpcProtocol();
	AwsJson1_1Protocol = class extends AwsJsonRpcProtocol {
		constructor({ defaultNamespace, serviceTarget, awsQueryCompatible }) {
			super({
				defaultNamespace,
				serviceTarget,
				awsQueryCompatible
			});
		}
		getShapeId() {
			return "aws.protocols#awsJson1_1";
		}
		getJsonRpcVersion() {
			return "1.1";
		}
		getDefaultContentType() {
			return "application/x-amz-json-1.1";
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/AwsRestJsonProtocol.js
var AwsRestJsonProtocol;
var init_AwsRestJsonProtocol = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_ProtocolLib();
	init_JsonCodec();
	init_parseJsonBody();
	AwsRestJsonProtocol = class extends HttpBindingProtocol {
		serializer;
		deserializer;
		codec;
		mixin = new ProtocolLib();
		constructor({ defaultNamespace }) {
			super({ defaultNamespace });
			const settings = {
				timestampFormat: {
					useTrait: true,
					default: 7
				},
				httpBindings: true,
				jsonName: true
			};
			this.codec = new JsonCodec(settings);
			this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
			this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
		}
		getShapeId() {
			return "aws.protocols#restJson1";
		}
		getPayloadCodec() {
			return this.codec;
		}
		setSerdeContext(serdeContext) {
			this.codec.setSerdeContext(serdeContext);
			super.setSerdeContext(serdeContext);
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			const inputSchema = NormalizedSchema.of(operationSchema.input);
			if (!request$1.headers["content-type"]) {
				const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
				if (contentType) request$1.headers["content-type"] = contentType;
			}
			if (request$1.body == null && request$1.headers["content-type"] === this.getDefaultContentType()) request$1.body = "{}";
			return request$1;
		}
		async deserializeResponse(operationSchema, context, response) {
			const output = await super.deserializeResponse(operationSchema, context, response);
			const outputSchema = NormalizedSchema.of(operationSchema.output);
			for (const [name, member$1] of outputSchema.structIterator()) if (member$1.getMemberTraits().httpPayload && !(name in output)) output[name] = null;
			return output;
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
			const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
			const ns = NormalizedSchema.of(errorSchema);
			const message = dataObject.message ?? dataObject.Message ?? "Unknown";
			const exception = new ((TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema)) ?? Error)(message);
			await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
			const output = {};
			for (const [name, member$1] of ns.structIterator()) {
				const target = member$1.getMergedTraits().jsonName ?? name;
				output[name] = this.codec.createDeserializer().readObject(member$1, dataObject[target]);
			}
			throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output), dataObject);
		}
		getDefaultContentType() {
			return "application/json";
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/json/awsExpectUnion.js
var import_dist_cjs$116, awsExpectUnion;
var init_awsExpectUnion = __esmMin((() => {
	import_dist_cjs$116 = require_dist_cjs$28();
	awsExpectUnion = (value) => {
		if (value == null) return;
		if (typeof value === "object" && "__type" in value) delete value.__type;
		return (0, import_dist_cjs$116.expectUnion)(value);
	};
}));

//#endregion
//#region node_modules/fast-xml-parser/lib/fxp.cjs
var require_fxp = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	(() => {
		"use strict";
		var t$5 = {
			d: (e$6, n$5) => {
				for (var i$6 in n$5) t$5.o(n$5, i$6) && !t$5.o(e$6, i$6) && Object.defineProperty(e$6, i$6, {
					enumerable: !0,
					get: n$5[i$6]
				});
			},
			o: (t$6, e$6) => Object.prototype.hasOwnProperty.call(t$6, e$6),
			r: (t$6) => {
				"undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t$6, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t$6, "__esModule", { value: !0 });
			}
		}, e$5 = {};
		t$5.r(e$5), t$5.d(e$5, {
			XMLBuilder: () => ft,
			XMLParser: () => st,
			XMLValidator: () => mt
		});
		const i$5 = /* @__PURE__ */ new RegExp("^[:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");
		function s$5(t$6, e$6) {
			const n$5 = [];
			let i$6 = e$6.exec(t$6);
			for (; i$6;) {
				const s$6 = [];
				s$6.startIndex = e$6.lastIndex - i$6[0].length;
				const r$6 = i$6.length;
				for (let t$7 = 0; t$7 < r$6; t$7++) s$6.push(i$6[t$7]);
				n$5.push(s$6), i$6 = e$6.exec(t$6);
			}
			return n$5;
		}
		const r$5 = function(t$6) {
			return !(null == i$5.exec(t$6));
		}, o$5 = {
			allowBooleanAttributes: !1,
			unpairedTags: []
		};
		function a$5(t$6, e$6) {
			e$6 = Object.assign({}, o$5, e$6);
			const n$5 = [];
			let i$6 = !1, s$6 = !1;
			"" === t$6[0] && (t$6 = t$6.substr(1));
			for (let o$6 = 0; o$6 < t$6.length; o$6++) if ("<" === t$6[o$6] && "?" === t$6[o$6 + 1]) {
				if (o$6 += 2, o$6 = u$5(t$6, o$6), o$6.err) return o$6;
			} else {
				if ("<" !== t$6[o$6]) {
					if (l$5(t$6[o$6])) continue;
					return x$5("InvalidChar", "char '" + t$6[o$6] + "' is not expected.", N(t$6, o$6));
				}
				{
					let a$6 = o$6;
					if (o$6++, "!" === t$6[o$6]) {
						o$6 = h$5(t$6, o$6);
						continue;
					}
					{
						let d$6 = !1;
						"/" === t$6[o$6] && (d$6 = !0, o$6++);
						let f$6 = "";
						for (; o$6 < t$6.length && ">" !== t$6[o$6] && " " !== t$6[o$6] && "	" !== t$6[o$6] && "\n" !== t$6[o$6] && "\r" !== t$6[o$6]; o$6++) f$6 += t$6[o$6];
						if (f$6 = f$6.trim(), "/" === f$6[f$6.length - 1] && (f$6 = f$6.substring(0, f$6.length - 1), o$6--), !r$5(f$6)) {
							let e$7;
							return e$7 = 0 === f$6.trim().length ? "Invalid space after '<'." : "Tag '" + f$6 + "' is an invalid name.", x$5("InvalidTag", e$7, N(t$6, o$6));
						}
						const p$6 = c$5(t$6, o$6);
						if (!1 === p$6) return x$5("InvalidAttr", "Attributes for '" + f$6 + "' have open quote.", N(t$6, o$6));
						let b$6 = p$6.value;
						if (o$6 = p$6.index, "/" === b$6[b$6.length - 1]) {
							const n$6 = o$6 - b$6.length;
							b$6 = b$6.substring(0, b$6.length - 1);
							const s$7 = g$5(b$6, e$6);
							if (!0 !== s$7) return x$5(s$7.err.code, s$7.err.msg, N(t$6, n$6 + s$7.err.line));
							i$6 = !0;
						} else if (d$6) {
							if (!p$6.tagClosed) return x$5("InvalidTag", "Closing tag '" + f$6 + "' doesn't have proper closing.", N(t$6, o$6));
							if (b$6.trim().length > 0) return x$5("InvalidTag", "Closing tag '" + f$6 + "' can't have attributes or invalid starting.", N(t$6, a$6));
							if (0 === n$5.length) return x$5("InvalidTag", "Closing tag '" + f$6 + "' has not been opened.", N(t$6, a$6));
							{
								const e$7 = n$5.pop();
								if (f$6 !== e$7.tagName) {
									let n$6 = N(t$6, e$7.tagStartPos);
									return x$5("InvalidTag", "Expected closing tag '" + e$7.tagName + "' (opened in line " + n$6.line + ", col " + n$6.col + ") instead of closing tag '" + f$6 + "'.", N(t$6, a$6));
								}
								0 == n$5.length && (s$6 = !0);
							}
						} else {
							const r$6 = g$5(b$6, e$6);
							if (!0 !== r$6) return x$5(r$6.err.code, r$6.err.msg, N(t$6, o$6 - b$6.length + r$6.err.line));
							if (!0 === s$6) return x$5("InvalidXml", "Multiple possible root nodes found.", N(t$6, o$6));
							-1 !== e$6.unpairedTags.indexOf(f$6) || n$5.push({
								tagName: f$6,
								tagStartPos: a$6
							}), i$6 = !0;
						}
						for (o$6++; o$6 < t$6.length; o$6++) if ("<" === t$6[o$6]) {
							if ("!" === t$6[o$6 + 1]) {
								o$6++, o$6 = h$5(t$6, o$6);
								continue;
							}
							if ("?" !== t$6[o$6 + 1]) break;
							if (o$6 = u$5(t$6, ++o$6), o$6.err) return o$6;
						} else if ("&" === t$6[o$6]) {
							const e$7 = m$5(t$6, o$6);
							if (-1 == e$7) return x$5("InvalidChar", "char '&' is not expected.", N(t$6, o$6));
							o$6 = e$7;
						} else if (!0 === s$6 && !l$5(t$6[o$6])) return x$5("InvalidXml", "Extra text at the end", N(t$6, o$6));
						"<" === t$6[o$6] && o$6--;
					}
				}
			}
			return i$6 ? 1 == n$5.length ? x$5("InvalidTag", "Unclosed tag '" + n$5[0].tagName + "'.", N(t$6, n$5[0].tagStartPos)) : !(n$5.length > 0) || x$5("InvalidXml", "Invalid '" + JSON.stringify(n$5.map(((t$7) => t$7.tagName)), null, 4).replace(/\r?\n/g, "") + "' found.", {
				line: 1,
				col: 1
			}) : x$5("InvalidXml", "Start tag expected.", 1);
		}
		function l$5(t$6) {
			return " " === t$6 || "	" === t$6 || "\n" === t$6 || "\r" === t$6;
		}
		function u$5(t$6, e$6) {
			const n$5 = e$6;
			for (; e$6 < t$6.length; e$6++) if ("?" != t$6[e$6] && " " != t$6[e$6]);
			else {
				const i$6 = t$6.substr(n$5, e$6 - n$5);
				if (e$6 > 5 && "xml" === i$6) return x$5("InvalidXml", "XML declaration allowed only at the start of the document.", N(t$6, e$6));
				if ("?" == t$6[e$6] && ">" == t$6[e$6 + 1]) {
					e$6++;
					break;
				}
			}
			return e$6;
		}
		function h$5(t$6, e$6) {
			if (t$6.length > e$6 + 5 && "-" === t$6[e$6 + 1] && "-" === t$6[e$6 + 2]) {
				for (e$6 += 3; e$6 < t$6.length; e$6++) if ("-" === t$6[e$6] && "-" === t$6[e$6 + 1] && ">" === t$6[e$6 + 2]) {
					e$6 += 2;
					break;
				}
			} else if (t$6.length > e$6 + 8 && "D" === t$6[e$6 + 1] && "O" === t$6[e$6 + 2] && "C" === t$6[e$6 + 3] && "T" === t$6[e$6 + 4] && "Y" === t$6[e$6 + 5] && "P" === t$6[e$6 + 6] && "E" === t$6[e$6 + 7]) {
				let n$5 = 1;
				for (e$6 += 8; e$6 < t$6.length; e$6++) if ("<" === t$6[e$6]) n$5++;
				else if (">" === t$6[e$6] && (n$5--, 0 === n$5)) break;
			} else if (t$6.length > e$6 + 9 && "[" === t$6[e$6 + 1] && "C" === t$6[e$6 + 2] && "D" === t$6[e$6 + 3] && "A" === t$6[e$6 + 4] && "T" === t$6[e$6 + 5] && "A" === t$6[e$6 + 6] && "[" === t$6[e$6 + 7]) {
				for (e$6 += 8; e$6 < t$6.length; e$6++) if ("]" === t$6[e$6] && "]" === t$6[e$6 + 1] && ">" === t$6[e$6 + 2]) {
					e$6 += 2;
					break;
				}
			}
			return e$6;
		}
		const d$5 = "\"", f$5 = "'";
		function c$5(t$6, e$6) {
			let n$5 = "", i$6 = "", s$6 = !1;
			for (; e$6 < t$6.length; e$6++) {
				if (t$6[e$6] === d$5 || t$6[e$6] === f$5) "" === i$6 ? i$6 = t$6[e$6] : i$6 !== t$6[e$6] || (i$6 = "");
				else if (">" === t$6[e$6] && "" === i$6) {
					s$6 = !0;
					break;
				}
				n$5 += t$6[e$6];
			}
			return "" === i$6 && {
				value: n$5,
				index: e$6,
				tagClosed: s$6
			};
		}
		const p$5 = new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?", "g");
		function g$5(t$6, e$6) {
			const n$5 = s$5(t$6, p$5), i$6 = {};
			for (let t$7 = 0; t$7 < n$5.length; t$7++) {
				if (0 === n$5[t$7][1].length) return x$5("InvalidAttr", "Attribute '" + n$5[t$7][2] + "' has no space in starting.", E$1(n$5[t$7]));
				if (void 0 !== n$5[t$7][3] && void 0 === n$5[t$7][4]) return x$5("InvalidAttr", "Attribute '" + n$5[t$7][2] + "' is without value.", E$1(n$5[t$7]));
				if (void 0 === n$5[t$7][3] && !e$6.allowBooleanAttributes) return x$5("InvalidAttr", "boolean attribute '" + n$5[t$7][2] + "' is not allowed.", E$1(n$5[t$7]));
				const s$6 = n$5[t$7][2];
				if (!b$5(s$6)) return x$5("InvalidAttr", "Attribute '" + s$6 + "' is an invalid name.", E$1(n$5[t$7]));
				if (i$6.hasOwnProperty(s$6)) return x$5("InvalidAttr", "Attribute '" + s$6 + "' is repeated.", E$1(n$5[t$7]));
				i$6[s$6] = 1;
			}
			return !0;
		}
		function m$5(t$6, e$6) {
			if (";" === t$6[++e$6]) return -1;
			if ("#" === t$6[e$6]) return function(t$7, e$7) {
				let n$6 = /\d/;
				for ("x" === t$7[e$7] && (e$7++, n$6 = /[\da-fA-F]/); e$7 < t$7.length; e$7++) {
					if (";" === t$7[e$7]) return e$7;
					if (!t$7[e$7].match(n$6)) break;
				}
				return -1;
			}(t$6, ++e$6);
			let n$5 = 0;
			for (; e$6 < t$6.length; e$6++, n$5++) if (!(t$6[e$6].match(/\w/) && n$5 < 20)) {
				if (";" === t$6[e$6]) break;
				return -1;
			}
			return e$6;
		}
		function x$5(t$6, e$6, n$5) {
			return { err: {
				code: t$6,
				msg: e$6,
				line: n$5.line || n$5,
				col: n$5.col
			} };
		}
		function b$5(t$6) {
			return r$5(t$6);
		}
		function N(t$6, e$6) {
			const n$5 = t$6.substring(0, e$6).split(/\r?\n/);
			return {
				line: n$5.length,
				col: n$5[n$5.length - 1].length + 1
			};
		}
		function E$1(t$6) {
			return t$6.startIndex + t$6[1].length;
		}
		const v$5 = {
			preserveOrder: !1,
			attributeNamePrefix: "@_",
			attributesGroupName: !1,
			textNodeName: "#text",
			ignoreAttributes: !0,
			removeNSPrefix: !1,
			allowBooleanAttributes: !1,
			parseTagValue: !0,
			parseAttributeValue: !1,
			trimValues: !0,
			cdataPropName: !1,
			numberParseOptions: {
				hex: !0,
				leadingZeros: !0,
				eNotation: !0
			},
			tagValueProcessor: function(t$6, e$6) {
				return e$6;
			},
			attributeValueProcessor: function(t$6, e$6) {
				return e$6;
			},
			stopNodes: [],
			alwaysCreateTextNode: !1,
			isArray: () => !1,
			commentPropName: !1,
			unpairedTags: [],
			processEntities: !0,
			htmlEntities: !1,
			ignoreDeclaration: !1,
			ignorePiTags: !1,
			transformTagName: !1,
			transformAttributeName: !1,
			updateTag: function(t$6, e$6, n$5) {
				return t$6;
			},
			captureMetaData: !1
		};
		let y$2;
		y$2 = "function" != typeof Symbol ? "@@xmlMetadata" : Symbol("XML Node Metadata");
		class T {
			constructor(t$6) {
				this.tagname = t$6, this.child = [], this[":@"] = {};
			}
			add(t$6, e$6) {
				"__proto__" === t$6 && (t$6 = "#__proto__"), this.child.push({ [t$6]: e$6 });
			}
			addChild(t$6, e$6) {
				"__proto__" === t$6.tagname && (t$6.tagname = "#__proto__"), t$6[":@"] && Object.keys(t$6[":@"]).length > 0 ? this.child.push({
					[t$6.tagname]: t$6.child,
					":@": t$6[":@"]
				}) : this.child.push({ [t$6.tagname]: t$6.child }), void 0 !== e$6 && (this.child[this.child.length - 1][y$2] = { startIndex: e$6 });
			}
			static getMetaDataSymbol() {
				return y$2;
			}
		}
		function w$5(t$6, e$6) {
			const n$5 = {};
			if ("O" !== t$6[e$6 + 3] || "C" !== t$6[e$6 + 4] || "T" !== t$6[e$6 + 5] || "Y" !== t$6[e$6 + 6] || "P" !== t$6[e$6 + 7] || "E" !== t$6[e$6 + 8]) throw new Error("Invalid Tag instead of DOCTYPE");
			{
				e$6 += 9;
				let i$6 = 1, s$6 = !1, r$6 = !1, o$6 = "";
				for (; e$6 < t$6.length; e$6++) if ("<" !== t$6[e$6] || r$6) if (">" === t$6[e$6]) {
					if (r$6 ? "-" === t$6[e$6 - 1] && "-" === t$6[e$6 - 2] && (r$6 = !1, i$6--) : i$6--, 0 === i$6) break;
				} else "[" === t$6[e$6] ? s$6 = !0 : o$6 += t$6[e$6];
				else {
					if (s$6 && C$2(t$6, "!ENTITY", e$6)) {
						let i$7, s$7;
						e$6 += 7, [i$7, s$7, e$6] = O(t$6, e$6 + 1), -1 === s$7.indexOf("&") && (n$5[i$7] = {
							regx: RegExp(`&${i$7};`, "g"),
							val: s$7
						});
					} else if (s$6 && C$2(t$6, "!ELEMENT", e$6)) {
						e$6 += 8;
						const { index: n$6 } = S(t$6, e$6 + 1);
						e$6 = n$6;
					} else if (s$6 && C$2(t$6, "!ATTLIST", e$6)) e$6 += 8;
					else if (s$6 && C$2(t$6, "!NOTATION", e$6)) {
						e$6 += 9;
						const { index: n$6 } = A$2(t$6, e$6 + 1);
						e$6 = n$6;
					} else {
						if (!C$2(t$6, "!--", e$6)) throw new Error("Invalid DOCTYPE");
						r$6 = !0;
					}
					i$6++, o$6 = "";
				}
				if (0 !== i$6) throw new Error("Unclosed DOCTYPE");
			}
			return {
				entities: n$5,
				i: e$6
			};
		}
		const P = (t$6, e$6) => {
			for (; e$6 < t$6.length && /\s/.test(t$6[e$6]);) e$6++;
			return e$6;
		};
		function O(t$6, e$6) {
			e$6 = P(t$6, e$6);
			let n$5 = "";
			for (; e$6 < t$6.length && !/\s/.test(t$6[e$6]) && "\"" !== t$6[e$6] && "'" !== t$6[e$6];) n$5 += t$6[e$6], e$6++;
			if ($(n$5), e$6 = P(t$6, e$6), "SYSTEM" === t$6.substring(e$6, e$6 + 6).toUpperCase()) throw new Error("External entities are not supported");
			if ("%" === t$6[e$6]) throw new Error("Parameter entities are not supported");
			let i$6 = "";
			return [e$6, i$6] = I$1(t$6, e$6, "entity"), [
				n$5,
				i$6,
				--e$6
			];
		}
		function A$2(t$6, e$6) {
			e$6 = P(t$6, e$6);
			let n$5 = "";
			for (; e$6 < t$6.length && !/\s/.test(t$6[e$6]);) n$5 += t$6[e$6], e$6++;
			$(n$5), e$6 = P(t$6, e$6);
			const i$6 = t$6.substring(e$6, e$6 + 6).toUpperCase();
			if ("SYSTEM" !== i$6 && "PUBLIC" !== i$6) throw new Error(`Expected SYSTEM or PUBLIC, found "${i$6}"`);
			e$6 += i$6.length, e$6 = P(t$6, e$6);
			let s$6 = null, r$6 = null;
			if ("PUBLIC" === i$6) [e$6, s$6] = I$1(t$6, e$6, "publicIdentifier"), "\"" !== t$6[e$6 = P(t$6, e$6)] && "'" !== t$6[e$6] || ([e$6, r$6] = I$1(t$6, e$6, "systemIdentifier"));
			else if ("SYSTEM" === i$6 && ([e$6, r$6] = I$1(t$6, e$6, "systemIdentifier"), !r$6)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
			return {
				notationName: n$5,
				publicIdentifier: s$6,
				systemIdentifier: r$6,
				index: --e$6
			};
		}
		function I$1(t$6, e$6, n$5) {
			let i$6 = "";
			const s$6 = t$6[e$6];
			if ("\"" !== s$6 && "'" !== s$6) throw new Error(`Expected quoted string, found "${s$6}"`);
			for (e$6++; e$6 < t$6.length && t$6[e$6] !== s$6;) i$6 += t$6[e$6], e$6++;
			if (t$6[e$6] !== s$6) throw new Error(`Unterminated ${n$5} value`);
			return [++e$6, i$6];
		}
		function S(t$6, e$6) {
			e$6 = P(t$6, e$6);
			let n$5 = "";
			for (; e$6 < t$6.length && !/\s/.test(t$6[e$6]);) n$5 += t$6[e$6], e$6++;
			if (!$(n$5)) throw new Error(`Invalid element name: "${n$5}"`);
			let i$6 = "";
			if ("E" === t$6[e$6 = P(t$6, e$6)] && C$2(t$6, "MPTY", e$6)) e$6 += 4;
			else if ("A" === t$6[e$6] && C$2(t$6, "NY", e$6)) e$6 += 2;
			else {
				if ("(" !== t$6[e$6]) throw new Error(`Invalid Element Expression, found "${t$6[e$6]}"`);
				for (e$6++; e$6 < t$6.length && ")" !== t$6[e$6];) i$6 += t$6[e$6], e$6++;
				if (")" !== t$6[e$6]) throw new Error("Unterminated content model");
			}
			return {
				elementName: n$5,
				contentModel: i$6.trim(),
				index: e$6
			};
		}
		function C$2(t$6, e$6, n$5) {
			for (let i$6 = 0; i$6 < e$6.length; i$6++) if (e$6[i$6] !== t$6[n$5 + i$6 + 1]) return !1;
			return !0;
		}
		function $(t$6) {
			if (r$5(t$6)) return t$6;
			throw new Error(`Invalid entity name ${t$6}`);
		}
		const j$5 = /^[-+]?0x[a-fA-F0-9]+$/, D$2 = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, V = {
			hex: !0,
			leadingZeros: !0,
			decimalPoint: ".",
			eNotation: !0
		};
		const M = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
		function _(t$6) {
			return "function" == typeof t$6 ? t$6 : Array.isArray(t$6) ? (e$6) => {
				for (const n$5 of t$6) {
					if ("string" == typeof n$5 && e$6 === n$5) return !0;
					if (n$5 instanceof RegExp && n$5.test(e$6)) return !0;
				}
			} : () => !1;
		}
		class k$5 {
			constructor(t$6) {
				this.options = t$6, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
					apos: {
						regex: /&(apos|#39|#x27);/g,
						val: "'"
					},
					gt: {
						regex: /&(gt|#62|#x3E);/g,
						val: ">"
					},
					lt: {
						regex: /&(lt|#60|#x3C);/g,
						val: "<"
					},
					quot: {
						regex: /&(quot|#34|#x22);/g,
						val: "\""
					}
				}, this.ampEntity = {
					regex: /&(amp|#38|#x26);/g,
					val: "&"
				}, this.htmlEntities = {
					space: {
						regex: /&(nbsp|#160);/g,
						val: " "
					},
					cent: {
						regex: /&(cent|#162);/g,
						val: ""
					},
					pound: {
						regex: /&(pound|#163);/g,
						val: ""
					},
					yen: {
						regex: /&(yen|#165);/g,
						val: ""
					},
					euro: {
						regex: /&(euro|#8364);/g,
						val: ""
					},
					copyright: {
						regex: /&(copy|#169);/g,
						val: ""
					},
					reg: {
						regex: /&(reg|#174);/g,
						val: ""
					},
					inr: {
						regex: /&(inr|#8377);/g,
						val: ""
					},
					num_dec: {
						regex: /&#([0-9]{1,7});/g,
						val: (t$7, e$6) => String.fromCodePoint(Number.parseInt(e$6, 10))
					},
					num_hex: {
						regex: /&#x([0-9a-fA-F]{1,6});/g,
						val: (t$7, e$6) => String.fromCodePoint(Number.parseInt(e$6, 16))
					}
				}, this.addExternalEntities = F$1, this.parseXml = X, this.parseTextData = L, this.resolveNameSpace = B$2, this.buildAttributesMap = G$1, this.isItStopNode = Z, this.replaceEntitiesValue = R, this.readStopNodeData = J$1, this.saveTextToParentTag = q$5, this.addChild = Y, this.ignoreAttributesFn = _(this.options.ignoreAttributes);
			}
		}
		function F$1(t$6) {
			const e$6 = Object.keys(t$6);
			for (let n$5 = 0; n$5 < e$6.length; n$5++) {
				const i$6 = e$6[n$5];
				this.lastEntities[i$6] = {
					regex: new RegExp("&" + i$6 + ";", "g"),
					val: t$6[i$6]
				};
			}
		}
		function L(t$6, e$6, n$5, i$6, s$6, r$6, o$6) {
			if (void 0 !== t$6 && (this.options.trimValues && !i$6 && (t$6 = t$6.trim()), t$6.length > 0)) {
				o$6 || (t$6 = this.replaceEntitiesValue(t$6));
				const i$7 = this.options.tagValueProcessor(e$6, t$6, n$5, s$6, r$6);
				return null == i$7 ? t$6 : typeof i$7 != typeof t$6 || i$7 !== t$6 ? i$7 : this.options.trimValues || t$6.trim() === t$6 ? H$1(t$6, this.options.parseTagValue, this.options.numberParseOptions) : t$6;
			}
		}
		function B$2(t$6) {
			if (this.options.removeNSPrefix) {
				const e$6 = t$6.split(":"), n$5 = "/" === t$6.charAt(0) ? "/" : "";
				if ("xmlns" === e$6[0]) return "";
				2 === e$6.length && (t$6 = n$5 + e$6[1]);
			}
			return t$6;
		}
		const U = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
		function G$1(t$6, e$6, n$5) {
			if (!0 !== this.options.ignoreAttributes && "string" == typeof t$6) {
				const n$6 = s$5(t$6, U), i$6 = n$6.length, r$6 = {};
				for (let t$7 = 0; t$7 < i$6; t$7++) {
					const i$7 = this.resolveNameSpace(n$6[t$7][1]);
					if (this.ignoreAttributesFn(i$7, e$6)) continue;
					let s$6 = n$6[t$7][4], o$6 = this.options.attributeNamePrefix + i$7;
					if (i$7.length) if (this.options.transformAttributeName && (o$6 = this.options.transformAttributeName(o$6)), "__proto__" === o$6 && (o$6 = "#__proto__"), void 0 !== s$6) {
						this.options.trimValues && (s$6 = s$6.trim()), s$6 = this.replaceEntitiesValue(s$6);
						const t$8 = this.options.attributeValueProcessor(i$7, s$6, e$6);
						r$6[o$6] = null == t$8 ? s$6 : typeof t$8 != typeof s$6 || t$8 !== s$6 ? t$8 : H$1(s$6, this.options.parseAttributeValue, this.options.numberParseOptions);
					} else this.options.allowBooleanAttributes && (r$6[o$6] = !0);
				}
				if (!Object.keys(r$6).length) return;
				if (this.options.attributesGroupName) {
					const t$7 = {};
					return t$7[this.options.attributesGroupName] = r$6, t$7;
				}
				return r$6;
			}
		}
		const X = function(t$6) {
			t$6 = t$6.replace(/\r\n?/g, "\n");
			const e$6 = new T("!xml");
			let n$5 = e$6, i$6 = "", s$6 = "";
			for (let r$6 = 0; r$6 < t$6.length; r$6++) if ("<" === t$6[r$6]) if ("/" === t$6[r$6 + 1]) {
				const e$7 = W(t$6, ">", r$6, "Closing Tag is not closed.");
				let o$6 = t$6.substring(r$6 + 2, e$7).trim();
				if (this.options.removeNSPrefix) {
					const t$7 = o$6.indexOf(":");
					-1 !== t$7 && (o$6 = o$6.substr(t$7 + 1));
				}
				this.options.transformTagName && (o$6 = this.options.transformTagName(o$6)), n$5 && (i$6 = this.saveTextToParentTag(i$6, n$5, s$6));
				const a$6 = s$6.substring(s$6.lastIndexOf(".") + 1);
				if (o$6 && -1 !== this.options.unpairedTags.indexOf(o$6)) throw new Error(`Unpaired tag can not be used as closing tag: </${o$6}>`);
				let l$6 = 0;
				a$6 && -1 !== this.options.unpairedTags.indexOf(a$6) ? (l$6 = s$6.lastIndexOf(".", s$6.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l$6 = s$6.lastIndexOf("."), s$6 = s$6.substring(0, l$6), n$5 = this.tagsNodeStack.pop(), i$6 = "", r$6 = e$7;
			} else if ("?" === t$6[r$6 + 1]) {
				let e$7 = z$2(t$6, r$6, !1, "?>");
				if (!e$7) throw new Error("Pi Tag is not closed.");
				if (i$6 = this.saveTextToParentTag(i$6, n$5, s$6), this.options.ignoreDeclaration && "?xml" === e$7.tagName || this.options.ignorePiTags);
				else {
					const t$7 = new T(e$7.tagName);
					t$7.add(this.options.textNodeName, ""), e$7.tagName !== e$7.tagExp && e$7.attrExpPresent && (t$7[":@"] = this.buildAttributesMap(e$7.tagExp, s$6, e$7.tagName)), this.addChild(n$5, t$7, s$6, r$6);
				}
				r$6 = e$7.closeIndex + 1;
			} else if ("!--" === t$6.substr(r$6 + 1, 3)) {
				const e$7 = W(t$6, "-->", r$6 + 4, "Comment is not closed.");
				if (this.options.commentPropName) {
					const o$6 = t$6.substring(r$6 + 4, e$7 - 2);
					i$6 = this.saveTextToParentTag(i$6, n$5, s$6), n$5.add(this.options.commentPropName, [{ [this.options.textNodeName]: o$6 }]);
				}
				r$6 = e$7;
			} else if ("!D" === t$6.substr(r$6 + 1, 2)) {
				const e$7 = w$5(t$6, r$6);
				this.docTypeEntities = e$7.entities, r$6 = e$7.i;
			} else if ("![" === t$6.substr(r$6 + 1, 2)) {
				const e$7 = W(t$6, "]]>", r$6, "CDATA is not closed.") - 2, o$6 = t$6.substring(r$6 + 9, e$7);
				i$6 = this.saveTextToParentTag(i$6, n$5, s$6);
				let a$6 = this.parseTextData(o$6, n$5.tagname, s$6, !0, !1, !0, !0);
				a$6 ??= "", this.options.cdataPropName ? n$5.add(this.options.cdataPropName, [{ [this.options.textNodeName]: o$6 }]) : n$5.add(this.options.textNodeName, a$6), r$6 = e$7 + 2;
			} else {
				let o$6 = z$2(t$6, r$6, this.options.removeNSPrefix), a$6 = o$6.tagName;
				const l$6 = o$6.rawTagName;
				let u$6 = o$6.tagExp, h$6 = o$6.attrExpPresent, d$6 = o$6.closeIndex;
				this.options.transformTagName && (a$6 = this.options.transformTagName(a$6)), n$5 && i$6 && "!xml" !== n$5.tagname && (i$6 = this.saveTextToParentTag(i$6, n$5, s$6, !1));
				const f$6 = n$5;
				f$6 && -1 !== this.options.unpairedTags.indexOf(f$6.tagname) && (n$5 = this.tagsNodeStack.pop(), s$6 = s$6.substring(0, s$6.lastIndexOf("."))), a$6 !== e$6.tagname && (s$6 += s$6 ? "." + a$6 : a$6);
				const c$6 = r$6;
				if (this.isItStopNode(this.options.stopNodes, s$6, a$6)) {
					let e$7 = "";
					if (u$6.length > 0 && u$6.lastIndexOf("/") === u$6.length - 1) "/" === a$6[a$6.length - 1] ? (a$6 = a$6.substr(0, a$6.length - 1), s$6 = s$6.substr(0, s$6.length - 1), u$6 = a$6) : u$6 = u$6.substr(0, u$6.length - 1), r$6 = o$6.closeIndex;
					else if (-1 !== this.options.unpairedTags.indexOf(a$6)) r$6 = o$6.closeIndex;
					else {
						const n$6 = this.readStopNodeData(t$6, l$6, d$6 + 1);
						if (!n$6) throw new Error(`Unexpected end of ${l$6}`);
						r$6 = n$6.i, e$7 = n$6.tagContent;
					}
					const i$7 = new T(a$6);
					a$6 !== u$6 && h$6 && (i$7[":@"] = this.buildAttributesMap(u$6, s$6, a$6)), e$7 && (e$7 = this.parseTextData(e$7, a$6, s$6, !0, h$6, !0, !0)), s$6 = s$6.substr(0, s$6.lastIndexOf(".")), i$7.add(this.options.textNodeName, e$7), this.addChild(n$5, i$7, s$6, c$6);
				} else {
					if (u$6.length > 0 && u$6.lastIndexOf("/") === u$6.length - 1) {
						"/" === a$6[a$6.length - 1] ? (a$6 = a$6.substr(0, a$6.length - 1), s$6 = s$6.substr(0, s$6.length - 1), u$6 = a$6) : u$6 = u$6.substr(0, u$6.length - 1), this.options.transformTagName && (a$6 = this.options.transformTagName(a$6));
						const t$7 = new T(a$6);
						a$6 !== u$6 && h$6 && (t$7[":@"] = this.buildAttributesMap(u$6, s$6, a$6)), this.addChild(n$5, t$7, s$6, c$6), s$6 = s$6.substr(0, s$6.lastIndexOf("."));
					} else {
						const t$7 = new T(a$6);
						this.tagsNodeStack.push(n$5), a$6 !== u$6 && h$6 && (t$7[":@"] = this.buildAttributesMap(u$6, s$6, a$6)), this.addChild(n$5, t$7, s$6, c$6), n$5 = t$7;
					}
					i$6 = "", r$6 = d$6;
				}
			}
			else i$6 += t$6[r$6];
			return e$6.child;
		};
		function Y(t$6, e$6, n$5, i$6) {
			this.options.captureMetaData || (i$6 = void 0);
			const s$6 = this.options.updateTag(e$6.tagname, n$5, e$6[":@"]);
			!1 === s$6 || ("string" == typeof s$6 ? (e$6.tagname = s$6, t$6.addChild(e$6, i$6)) : t$6.addChild(e$6, i$6));
		}
		const R = function(t$6) {
			if (this.options.processEntities) {
				for (let e$6 in this.docTypeEntities) {
					const n$5 = this.docTypeEntities[e$6];
					t$6 = t$6.replace(n$5.regx, n$5.val);
				}
				for (let e$6 in this.lastEntities) {
					const n$5 = this.lastEntities[e$6];
					t$6 = t$6.replace(n$5.regex, n$5.val);
				}
				if (this.options.htmlEntities) for (let e$6 in this.htmlEntities) {
					const n$5 = this.htmlEntities[e$6];
					t$6 = t$6.replace(n$5.regex, n$5.val);
				}
				t$6 = t$6.replace(this.ampEntity.regex, this.ampEntity.val);
			}
			return t$6;
		};
		function q$5(t$6, e$6, n$5, i$6) {
			return t$6 && (void 0 === i$6 && (i$6 = 0 === e$6.child.length), void 0 !== (t$6 = this.parseTextData(t$6, e$6.tagname, n$5, !1, !!e$6[":@"] && 0 !== Object.keys(e$6[":@"]).length, i$6)) && "" !== t$6 && e$6.add(this.options.textNodeName, t$6), t$6 = ""), t$6;
		}
		function Z(t$6, e$6, n$5) {
			const i$6 = "*." + n$5;
			for (const n$6 in t$6) {
				const s$6 = t$6[n$6];
				if (i$6 === s$6 || e$6 === s$6) return !0;
			}
			return !1;
		}
		function W(t$6, e$6, n$5, i$6) {
			const s$6 = t$6.indexOf(e$6, n$5);
			if (-1 === s$6) throw new Error(i$6);
			return s$6 + e$6.length - 1;
		}
		function z$2(t$6, e$6, n$5, i$6 = ">") {
			const s$6 = function(t$7, e$7, n$6 = ">") {
				let i$7, s$7 = "";
				for (let r$7 = e$7; r$7 < t$7.length; r$7++) {
					let e$8 = t$7[r$7];
					if (i$7) e$8 === i$7 && (i$7 = "");
					else if ("\"" === e$8 || "'" === e$8) i$7 = e$8;
					else if (e$8 === n$6[0]) {
						if (!n$6[1]) return {
							data: s$7,
							index: r$7
						};
						if (t$7[r$7 + 1] === n$6[1]) return {
							data: s$7,
							index: r$7
						};
					} else "	" === e$8 && (e$8 = " ");
					s$7 += e$8;
				}
			}(t$6, e$6 + 1, i$6);
			if (!s$6) return;
			let r$6 = s$6.data;
			const o$6 = s$6.index, a$6 = r$6.search(/\s/);
			let l$6 = r$6, u$6 = !0;
			-1 !== a$6 && (l$6 = r$6.substring(0, a$6), r$6 = r$6.substring(a$6 + 1).trimStart());
			const h$6 = l$6;
			if (n$5) {
				const t$7 = l$6.indexOf(":");
				-1 !== t$7 && (l$6 = l$6.substr(t$7 + 1), u$6 = l$6 !== s$6.data.substr(t$7 + 1));
			}
			return {
				tagName: l$6,
				tagExp: r$6,
				closeIndex: o$6,
				attrExpPresent: u$6,
				rawTagName: h$6
			};
		}
		function J$1(t$6, e$6, n$5) {
			const i$6 = n$5;
			let s$6 = 1;
			for (; n$5 < t$6.length; n$5++) if ("<" === t$6[n$5]) if ("/" === t$6[n$5 + 1]) {
				const r$6 = W(t$6, ">", n$5, `${e$6} is not closed`);
				if (t$6.substring(n$5 + 2, r$6).trim() === e$6 && (s$6--, 0 === s$6)) return {
					tagContent: t$6.substring(i$6, n$5),
					i: r$6
				};
				n$5 = r$6;
			} else if ("?" === t$6[n$5 + 1]) n$5 = W(t$6, "?>", n$5 + 1, "StopNode is not closed.");
			else if ("!--" === t$6.substr(n$5 + 1, 3)) n$5 = W(t$6, "-->", n$5 + 3, "StopNode is not closed.");
			else if ("![" === t$6.substr(n$5 + 1, 2)) n$5 = W(t$6, "]]>", n$5, "StopNode is not closed.") - 2;
			else {
				const i$7 = z$2(t$6, n$5, ">");
				i$7 && ((i$7 && i$7.tagName) === e$6 && "/" !== i$7.tagExp[i$7.tagExp.length - 1] && s$6++, n$5 = i$7.closeIndex);
			}
		}
		function H$1(t$6, e$6, n$5) {
			if (e$6 && "string" == typeof t$6) {
				const e$7 = t$6.trim();
				return "true" === e$7 || "false" !== e$7 && function(t$7, e$8 = {}) {
					if (e$8 = Object.assign({}, V, e$8), !t$7 || "string" != typeof t$7) return t$7;
					let n$6 = t$7.trim();
					if (void 0 !== e$8.skipLike && e$8.skipLike.test(n$6)) return t$7;
					if ("0" === t$7) return 0;
					if (e$8.hex && j$5.test(n$6)) return function(t$8) {
						if (parseInt) return parseInt(t$8, 16);
						if (Number.parseInt) return Number.parseInt(t$8, 16);
						if (window && window.parseInt) return window.parseInt(t$8, 16);
						throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
					}(n$6);
					if (-1 !== n$6.search(/.+[eE].+/)) return function(t$8, e$9, n$7) {
						if (!n$7.eNotation) return t$8;
						const i$7 = e$9.match(M);
						if (i$7) {
							let s$6 = i$7[1] || "";
							const r$6 = -1 === i$7[3].indexOf("e") ? "E" : "e", o$6 = i$7[2], a$6 = s$6 ? t$8[o$6.length + 1] === r$6 : t$8[o$6.length] === r$6;
							return o$6.length > 1 && a$6 ? t$8 : 1 !== o$6.length || !i$7[3].startsWith(`.${r$6}`) && i$7[3][0] !== r$6 ? n$7.leadingZeros && !a$6 ? (e$9 = (i$7[1] || "") + i$7[3], Number(e$9)) : t$8 : Number(e$9);
						}
						return t$8;
					}(t$7, n$6, e$8);
					{
						const s$6 = D$2.exec(n$6);
						if (s$6) {
							const r$6 = s$6[1] || "", o$6 = s$6[2];
							let a$6 = (i$6 = s$6[3]) && -1 !== i$6.indexOf(".") ? ("." === (i$6 = i$6.replace(/0+$/, "")) ? i$6 = "0" : "." === i$6[0] ? i$6 = "0" + i$6 : "." === i$6[i$6.length - 1] && (i$6 = i$6.substring(0, i$6.length - 1)), i$6) : i$6;
							const l$6 = r$6 ? "." === t$7[o$6.length + 1] : "." === t$7[o$6.length];
							if (!e$8.leadingZeros && (o$6.length > 1 || 1 === o$6.length && !l$6)) return t$7;
							{
								const i$7 = Number(n$6), s$7 = String(i$7);
								if (0 === i$7 || -0 === i$7) return i$7;
								if (-1 !== s$7.search(/[eE]/)) return e$8.eNotation ? i$7 : t$7;
								if (-1 !== n$6.indexOf(".")) return "0" === s$7 || s$7 === a$6 || s$7 === `${r$6}${a$6}` ? i$7 : t$7;
								let l$7 = o$6 ? a$6 : n$6;
								return o$6 ? l$7 === s$7 || r$6 + l$7 === s$7 ? i$7 : t$7 : l$7 === s$7 || l$7 === r$6 + s$7 ? i$7 : t$7;
							}
						}
						return t$7;
					}
					var i$6;
				}(t$6, n$5);
			}
			return void 0 !== t$6 ? t$6 : "";
		}
		const K = T.getMetaDataSymbol();
		function Q(t$6, e$6) {
			return tt(t$6, e$6);
		}
		function tt(t$6, e$6, n$5) {
			let i$6;
			const s$6 = {};
			for (let r$6 = 0; r$6 < t$6.length; r$6++) {
				const o$6 = t$6[r$6], a$6 = et(o$6);
				let l$6 = "";
				if (l$6 = void 0 === n$5 ? a$6 : n$5 + "." + a$6, a$6 === e$6.textNodeName) void 0 === i$6 ? i$6 = o$6[a$6] : i$6 += "" + o$6[a$6];
				else {
					if (void 0 === a$6) continue;
					if (o$6[a$6]) {
						let t$7 = tt(o$6[a$6], e$6, l$6);
						const n$6 = it(t$7, e$6);
						void 0 !== o$6[K] && (t$7[K] = o$6[K]), o$6[":@"] ? nt(t$7, o$6[":@"], l$6, e$6) : 1 !== Object.keys(t$7).length || void 0 === t$7[e$6.textNodeName] || e$6.alwaysCreateTextNode ? 0 === Object.keys(t$7).length && (e$6.alwaysCreateTextNode ? t$7[e$6.textNodeName] = "" : t$7 = "") : t$7 = t$7[e$6.textNodeName], void 0 !== s$6[a$6] && s$6.hasOwnProperty(a$6) ? (Array.isArray(s$6[a$6]) || (s$6[a$6] = [s$6[a$6]]), s$6[a$6].push(t$7)) : e$6.isArray(a$6, l$6, n$6) ? s$6[a$6] = [t$7] : s$6[a$6] = t$7;
					}
				}
			}
			return "string" == typeof i$6 ? i$6.length > 0 && (s$6[e$6.textNodeName] = i$6) : void 0 !== i$6 && (s$6[e$6.textNodeName] = i$6), s$6;
		}
		function et(t$6) {
			const e$6 = Object.keys(t$6);
			for (let t$7 = 0; t$7 < e$6.length; t$7++) {
				const n$5 = e$6[t$7];
				if (":@" !== n$5) return n$5;
			}
		}
		function nt(t$6, e$6, n$5, i$6) {
			if (e$6) {
				const s$6 = Object.keys(e$6), r$6 = s$6.length;
				for (let o$6 = 0; o$6 < r$6; o$6++) {
					const r$7 = s$6[o$6];
					i$6.isArray(r$7, n$5 + "." + r$7, !0, !0) ? t$6[r$7] = [e$6[r$7]] : t$6[r$7] = e$6[r$7];
				}
			}
		}
		function it(t$6, e$6) {
			const { textNodeName: n$5 } = e$6, i$6 = Object.keys(t$6).length;
			return 0 === i$6 || !(1 !== i$6 || !t$6[n$5] && "boolean" != typeof t$6[n$5] && 0 !== t$6[n$5]);
		}
		class st {
			constructor(t$6) {
				this.externalEntities = {}, this.options = function(t$7) {
					return Object.assign({}, v$5, t$7);
				}(t$6);
			}
			parse(t$6, e$6) {
				if ("string" == typeof t$6);
				else {
					if (!t$6.toString) throw new Error("XML data is accepted in String or Bytes[] form.");
					t$6 = t$6.toString();
				}
				if (e$6) {
					!0 === e$6 && (e$6 = {});
					const n$6 = a$5(t$6, e$6);
					if (!0 !== n$6) throw Error(`${n$6.err.msg}:${n$6.err.line}:${n$6.err.col}`);
				}
				const n$5 = new k$5(this.options);
				n$5.addExternalEntities(this.externalEntities);
				const i$6 = n$5.parseXml(t$6);
				return this.options.preserveOrder || void 0 === i$6 ? i$6 : Q(i$6, this.options);
			}
			addEntity(t$6, e$6) {
				if (-1 !== e$6.indexOf("&")) throw new Error("Entity value can't have '&'");
				if (-1 !== t$6.indexOf("&") || -1 !== t$6.indexOf(";")) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
				if ("&" === e$6) throw new Error("An entity with value '&' is not permitted");
				this.externalEntities[t$6] = e$6;
			}
			static getMetaDataSymbol() {
				return T.getMetaDataSymbol();
			}
		}
		function rt(t$6, e$6) {
			let n$5 = "";
			return e$6.format && e$6.indentBy.length > 0 && (n$5 = "\n"), ot(t$6, e$6, "", n$5);
		}
		function ot(t$6, e$6, n$5, i$6) {
			let s$6 = "", r$6 = !1;
			for (let o$6 = 0; o$6 < t$6.length; o$6++) {
				const a$6 = t$6[o$6], l$6 = at(a$6);
				if (void 0 === l$6) continue;
				let u$6 = "";
				if (u$6 = 0 === n$5.length ? l$6 : `${n$5}.${l$6}`, l$6 === e$6.textNodeName) {
					let t$7 = a$6[l$6];
					ut(u$6, e$6) || (t$7 = e$6.tagValueProcessor(l$6, t$7), t$7 = ht(t$7, e$6)), r$6 && (s$6 += i$6), s$6 += t$7, r$6 = !1;
					continue;
				}
				if (l$6 === e$6.cdataPropName) {
					r$6 && (s$6 += i$6), s$6 += `<![CDATA[${a$6[l$6][0][e$6.textNodeName]}]]>`, r$6 = !1;
					continue;
				}
				if (l$6 === e$6.commentPropName) {
					s$6 += i$6 + `\x3c!--${a$6[l$6][0][e$6.textNodeName]}--\x3e`, r$6 = !0;
					continue;
				}
				if ("?" === l$6[0]) {
					const t$7 = lt(a$6[":@"], e$6), n$6 = "?xml" === l$6 ? "" : i$6;
					let o$7 = a$6[l$6][0][e$6.textNodeName];
					o$7 = 0 !== o$7.length ? " " + o$7 : "", s$6 += n$6 + `<${l$6}${o$7}${t$7}?>`, r$6 = !0;
					continue;
				}
				let h$6 = i$6;
				"" !== h$6 && (h$6 += e$6.indentBy);
				const d$6 = i$6 + `<${l$6}${lt(a$6[":@"], e$6)}`, f$6 = ot(a$6[l$6], e$6, u$6, h$6);
				-1 !== e$6.unpairedTags.indexOf(l$6) ? e$6.suppressUnpairedNode ? s$6 += d$6 + ">" : s$6 += d$6 + "/>" : f$6 && 0 !== f$6.length || !e$6.suppressEmptyNode ? f$6 && f$6.endsWith(">") ? s$6 += d$6 + `>${f$6}${i$6}</${l$6}>` : (s$6 += d$6 + ">", f$6 && "" !== i$6 && (f$6.includes("/>") || f$6.includes("</")) ? s$6 += i$6 + e$6.indentBy + f$6 + i$6 : s$6 += f$6, s$6 += `</${l$6}>`) : s$6 += d$6 + "/>", r$6 = !0;
			}
			return s$6;
		}
		function at(t$6) {
			const e$6 = Object.keys(t$6);
			for (let n$5 = 0; n$5 < e$6.length; n$5++) {
				const i$6 = e$6[n$5];
				if (t$6.hasOwnProperty(i$6) && ":@" !== i$6) return i$6;
			}
		}
		function lt(t$6, e$6) {
			let n$5 = "";
			if (t$6 && !e$6.ignoreAttributes) for (let i$6 in t$6) {
				if (!t$6.hasOwnProperty(i$6)) continue;
				let s$6 = e$6.attributeValueProcessor(i$6, t$6[i$6]);
				s$6 = ht(s$6, e$6), !0 === s$6 && e$6.suppressBooleanAttributes ? n$5 += ` ${i$6.substr(e$6.attributeNamePrefix.length)}` : n$5 += ` ${i$6.substr(e$6.attributeNamePrefix.length)}="${s$6}"`;
			}
			return n$5;
		}
		function ut(t$6, e$6) {
			let n$5 = (t$6 = t$6.substr(0, t$6.length - e$6.textNodeName.length - 1)).substr(t$6.lastIndexOf(".") + 1);
			for (let i$6 in e$6.stopNodes) if (e$6.stopNodes[i$6] === t$6 || e$6.stopNodes[i$6] === "*." + n$5) return !0;
			return !1;
		}
		function ht(t$6, e$6) {
			if (t$6 && t$6.length > 0 && e$6.processEntities) for (let n$5 = 0; n$5 < e$6.entities.length; n$5++) {
				const i$6 = e$6.entities[n$5];
				t$6 = t$6.replace(i$6.regex, i$6.val);
			}
			return t$6;
		}
		const dt = {
			attributeNamePrefix: "@_",
			attributesGroupName: !1,
			textNodeName: "#text",
			ignoreAttributes: !0,
			cdataPropName: !1,
			format: !1,
			indentBy: "  ",
			suppressEmptyNode: !1,
			suppressUnpairedNode: !0,
			suppressBooleanAttributes: !0,
			tagValueProcessor: function(t$6, e$6) {
				return e$6;
			},
			attributeValueProcessor: function(t$6, e$6) {
				return e$6;
			},
			preserveOrder: !1,
			commentPropName: !1,
			unpairedTags: [],
			entities: [
				{
					regex: new RegExp("&", "g"),
					val: "&amp;"
				},
				{
					regex: new RegExp(">", "g"),
					val: "&gt;"
				},
				{
					regex: new RegExp("<", "g"),
					val: "&lt;"
				},
				{
					regex: new RegExp("'", "g"),
					val: "&apos;"
				},
				{
					regex: new RegExp("\"", "g"),
					val: "&quot;"
				}
			],
			processEntities: !0,
			stopNodes: [],
			oneListGroup: !1
		};
		function ft(t$6) {
			this.options = Object.assign({}, dt, t$6), !0 === this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
				return !1;
			} : (this.ignoreAttributesFn = _(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = gt), this.processTextOrObjNode = ct, this.options.format ? (this.indentate = pt, this.tagEndChar = ">\n", this.newLine = "\n") : (this.indentate = function() {
				return "";
			}, this.tagEndChar = ">", this.newLine = "");
		}
		function ct(t$6, e$6, n$5, i$6) {
			const s$6 = this.j2x(t$6, n$5 + 1, i$6.concat(e$6));
			return void 0 !== t$6[this.options.textNodeName] && 1 === Object.keys(t$6).length ? this.buildTextValNode(t$6[this.options.textNodeName], e$6, s$6.attrStr, n$5) : this.buildObjectNode(s$6.val, e$6, s$6.attrStr, n$5);
		}
		function pt(t$6) {
			return this.options.indentBy.repeat(t$6);
		}
		function gt(t$6) {
			return !(!t$6.startsWith(this.options.attributeNamePrefix) || t$6 === this.options.textNodeName) && t$6.substr(this.attrPrefixLen);
		}
		ft.prototype.build = function(t$6) {
			return this.options.preserveOrder ? rt(t$6, this.options) : (Array.isArray(t$6) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t$6 = { [this.options.arrayNodeName]: t$6 }), this.j2x(t$6, 0, []).val);
		}, ft.prototype.j2x = function(t$6, e$6, n$5) {
			let i$6 = "", s$6 = "";
			const r$6 = n$5.join(".");
			for (let o$6 in t$6) if (Object.prototype.hasOwnProperty.call(t$6, o$6)) if (void 0 === t$6[o$6]) this.isAttribute(o$6) && (s$6 += "");
			else if (null === t$6[o$6]) this.isAttribute(o$6) || o$6 === this.options.cdataPropName ? s$6 += "" : "?" === o$6[0] ? s$6 += this.indentate(e$6) + "<" + o$6 + "?" + this.tagEndChar : s$6 += this.indentate(e$6) + "<" + o$6 + "/" + this.tagEndChar;
			else if (t$6[o$6] instanceof Date) s$6 += this.buildTextValNode(t$6[o$6], o$6, "", e$6);
			else if ("object" != typeof t$6[o$6]) {
				const n$6 = this.isAttribute(o$6);
				if (n$6 && !this.ignoreAttributesFn(n$6, r$6)) i$6 += this.buildAttrPairStr(n$6, "" + t$6[o$6]);
				else if (!n$6) if (o$6 === this.options.textNodeName) {
					let e$7 = this.options.tagValueProcessor(o$6, "" + t$6[o$6]);
					s$6 += this.replaceEntitiesValue(e$7);
				} else s$6 += this.buildTextValNode(t$6[o$6], o$6, "", e$6);
			} else if (Array.isArray(t$6[o$6])) {
				const i$7 = t$6[o$6].length;
				let r$7 = "", a$6 = "";
				for (let l$6 = 0; l$6 < i$7; l$6++) {
					const i$8 = t$6[o$6][l$6];
					if (void 0 === i$8);
					else if (null === i$8) "?" === o$6[0] ? s$6 += this.indentate(e$6) + "<" + o$6 + "?" + this.tagEndChar : s$6 += this.indentate(e$6) + "<" + o$6 + "/" + this.tagEndChar;
					else if ("object" == typeof i$8) if (this.options.oneListGroup) {
						const t$7 = this.j2x(i$8, e$6 + 1, n$5.concat(o$6));
						r$7 += t$7.val, this.options.attributesGroupName && i$8.hasOwnProperty(this.options.attributesGroupName) && (a$6 += t$7.attrStr);
					} else r$7 += this.processTextOrObjNode(i$8, o$6, e$6, n$5);
					else if (this.options.oneListGroup) {
						let t$7 = this.options.tagValueProcessor(o$6, i$8);
						t$7 = this.replaceEntitiesValue(t$7), r$7 += t$7;
					} else r$7 += this.buildTextValNode(i$8, o$6, "", e$6);
				}
				this.options.oneListGroup && (r$7 = this.buildObjectNode(r$7, o$6, a$6, e$6)), s$6 += r$7;
			} else if (this.options.attributesGroupName && o$6 === this.options.attributesGroupName) {
				const e$7 = Object.keys(t$6[o$6]), n$6 = e$7.length;
				for (let s$7 = 0; s$7 < n$6; s$7++) i$6 += this.buildAttrPairStr(e$7[s$7], "" + t$6[o$6][e$7[s$7]]);
			} else s$6 += this.processTextOrObjNode(t$6[o$6], o$6, e$6, n$5);
			return {
				attrStr: i$6,
				val: s$6
			};
		}, ft.prototype.buildAttrPairStr = function(t$6, e$6) {
			return e$6 = this.options.attributeValueProcessor(t$6, "" + e$6), e$6 = this.replaceEntitiesValue(e$6), this.options.suppressBooleanAttributes && "true" === e$6 ? " " + t$6 : " " + t$6 + "=\"" + e$6 + "\"";
		}, ft.prototype.buildObjectNode = function(t$6, e$6, n$5, i$6) {
			if ("" === t$6) return "?" === e$6[0] ? this.indentate(i$6) + "<" + e$6 + n$5 + "?" + this.tagEndChar : this.indentate(i$6) + "<" + e$6 + n$5 + this.closeTag(e$6) + this.tagEndChar;
			{
				let s$6 = "</" + e$6 + this.tagEndChar, r$6 = "";
				return "?" === e$6[0] && (r$6 = "?", s$6 = ""), !n$5 && "" !== n$5 || -1 !== t$6.indexOf("<") ? !1 !== this.options.commentPropName && e$6 === this.options.commentPropName && 0 === r$6.length ? this.indentate(i$6) + `\x3c!--${t$6}--\x3e` + this.newLine : this.indentate(i$6) + "<" + e$6 + n$5 + r$6 + this.tagEndChar + t$6 + this.indentate(i$6) + s$6 : this.indentate(i$6) + "<" + e$6 + n$5 + r$6 + ">" + t$6 + s$6;
			}
		}, ft.prototype.closeTag = function(t$6) {
			let e$6 = "";
			return -1 !== this.options.unpairedTags.indexOf(t$6) ? this.options.suppressUnpairedNode || (e$6 = "/") : e$6 = this.options.suppressEmptyNode ? "/" : `></${t$6}`, e$6;
		}, ft.prototype.buildTextValNode = function(t$6, e$6, n$5, i$6) {
			if (!1 !== this.options.cdataPropName && e$6 === this.options.cdataPropName) return this.indentate(i$6) + `<![CDATA[${t$6}]]>` + this.newLine;
			if (!1 !== this.options.commentPropName && e$6 === this.options.commentPropName) return this.indentate(i$6) + `\x3c!--${t$6}--\x3e` + this.newLine;
			if ("?" === e$6[0]) return this.indentate(i$6) + "<" + e$6 + n$5 + "?" + this.tagEndChar;
			{
				let s$6 = this.options.tagValueProcessor(e$6, t$6);
				return s$6 = this.replaceEntitiesValue(s$6), "" === s$6 ? this.indentate(i$6) + "<" + e$6 + n$5 + this.closeTag(e$6) + this.tagEndChar : this.indentate(i$6) + "<" + e$6 + n$5 + ">" + s$6 + "</" + e$6 + this.tagEndChar;
			}
		}, ft.prototype.replaceEntitiesValue = function(t$6) {
			if (t$6 && t$6.length > 0 && this.options.processEntities) for (let e$6 = 0; e$6 < this.options.entities.length; e$6++) {
				const n$5 = this.options.entities[e$6];
				t$6 = t$6.replace(n$5.regex, n$5.val);
			}
			return t$6;
		};
		const mt = { validate: a$5 };
		module.exports = e$5;
	})();
}));

//#endregion
//#region node_modules/@aws-sdk/xml-builder/dist-cjs/xml-parser.js
var require_xml_parser = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.parseXML = parseXML$2;
	const parser = new (require_fxp()).XMLParser({
		attributeNamePrefix: "",
		htmlEntities: true,
		ignoreAttributes: false,
		ignoreDeclaration: true,
		parseTagValue: false,
		trimValues: false,
		tagValueProcessor: (_, val) => val.trim() === "" && val.includes("\n") ? "" : void 0
	});
	parser.addEntity("#xD", "\r");
	parser.addEntity("#10", "\n");
	function parseXML$2(xmlString) {
		return parser.parse(xmlString, true);
	}
}));

//#endregion
//#region node_modules/@aws-sdk/xml-builder/dist-cjs/index.js
var require_dist_cjs$27 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var xmlParser = require_xml_parser();
	function escapeAttribute(value) {
		return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
	}
	function escapeElement(value) {
		return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
	}
	var XmlText$1 = class {
		value;
		constructor(value) {
			this.value = value;
		}
		toString() {
			return escapeElement("" + this.value);
		}
	};
	var XmlNode$1 = class XmlNode$1 {
		name;
		children;
		attributes = {};
		static of(name, childText, withName) {
			const node = new XmlNode$1(name);
			if (childText !== void 0) node.addChildNode(new XmlText$1(childText));
			if (withName !== void 0) node.withName(withName);
			return node;
		}
		constructor(name, children = []) {
			this.name = name;
			this.children = children;
		}
		withName(name) {
			this.name = name;
			return this;
		}
		addAttribute(name, value) {
			this.attributes[name] = value;
			return this;
		}
		addChildNode(child$1) {
			this.children.push(child$1);
			return this;
		}
		removeAttribute(name) {
			delete this.attributes[name];
			return this;
		}
		n(name) {
			this.name = name;
			return this;
		}
		c(child$1) {
			this.children.push(child$1);
			return this;
		}
		a(name, value) {
			if (value != null) this.attributes[name] = value;
			return this;
		}
		cc(input, field, withName = field) {
			if (input[field] != null) {
				const node = XmlNode$1.of(field, input[field]).withName(withName);
				this.c(node);
			}
		}
		l(input, listName, memberName, valueProvider) {
			if (input[listName] != null) valueProvider().map((node) => {
				node.withName(memberName);
				this.c(node);
			});
		}
		lc(input, listName, memberName, valueProvider) {
			if (input[listName] != null) {
				const nodes = valueProvider();
				const containerNode = new XmlNode$1(memberName);
				nodes.map((node) => {
					containerNode.c(node);
				});
				this.c(containerNode);
			}
		}
		toString() {
			const hasChildren = Boolean(this.children.length);
			let xmlText = `<${this.name}`;
			const attributes = this.attributes;
			for (const attributeName of Object.keys(attributes)) {
				const attribute = attributes[attributeName];
				if (attribute != null) xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
			}
			return xmlText += !hasChildren ? "/>" : `>${this.children.map((c$5) => c$5.toString()).join("")}</${this.name}>`;
		}
	};
	Object.defineProperty(exports, "parseXML", {
		enumerable: true,
		get: function() {
			return xmlParser.parseXML;
		}
	});
	exports.XmlNode = XmlNode$1;
	exports.XmlText = XmlText$1;
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeDeserializer.js
var import_dist_cjs$113, import_dist_cjs$114, import_dist_cjs$115, XmlShapeDeserializer;
var init_XmlShapeDeserializer = __esmMin((() => {
	import_dist_cjs$113 = require_dist_cjs$27();
	init_protocols$1();
	init_schema();
	import_dist_cjs$114 = require_dist_cjs$28();
	import_dist_cjs$115 = require_dist_cjs$44();
	init_ConfigurableSerdeContext();
	XmlShapeDeserializer = class extends SerdeContextConfig {
		settings;
		stringDeserializer;
		constructor(settings) {
			super();
			this.settings = settings;
			this.stringDeserializer = new FromStringShapeDeserializer(settings);
		}
		setSerdeContext(serdeContext) {
			this.serdeContext = serdeContext;
			this.stringDeserializer.setSerdeContext(serdeContext);
		}
		read(schema$3, bytes, key) {
			const ns = NormalizedSchema.of(schema$3);
			const memberSchemas = ns.getMemberSchemas();
			if (ns.isStructSchema() && ns.isMemberSchema() && !!Object.values(memberSchemas).find((memberNs) => {
				return !!memberNs.getMemberTraits().eventPayload;
			})) {
				const output = {};
				const memberName = Object.keys(memberSchemas)[0];
				if (memberSchemas[memberName].isBlobSchema()) output[memberName] = bytes;
				else output[memberName] = this.read(memberSchemas[memberName], bytes);
				return output;
			}
			const xmlString = (this.serdeContext?.utf8Encoder ?? import_dist_cjs$115.toUtf8)(bytes);
			const parsedObject = this.parseXml(xmlString);
			return this.readSchema(schema$3, key ? parsedObject[key] : parsedObject);
		}
		readSchema(_schema, value) {
			const ns = NormalizedSchema.of(_schema);
			if (ns.isUnitSchema()) return;
			const traits = ns.getMergedTraits();
			if (ns.isListSchema() && !Array.isArray(value)) return this.readSchema(ns, [value]);
			if (value == null) return value;
			if (typeof value === "object") {
				const sparse = !!traits.sparse;
				const flat = !!traits.xmlFlattened;
				if (ns.isListSchema()) {
					const listValue = ns.getValueSchema();
					const buffer$4 = [];
					const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
					const source = flat ? value : (value[0] ?? value)[sourceKey];
					const sourceArray = Array.isArray(source) ? source : [source];
					for (const v$5 of sourceArray) if (v$5 != null || sparse) buffer$4.push(this.readSchema(listValue, v$5));
					return buffer$4;
				}
				const buffer$3 = {};
				if (ns.isMapSchema()) {
					const keyNs = ns.getKeySchema();
					const memberNs = ns.getValueSchema();
					let entries;
					if (flat) entries = Array.isArray(value) ? value : [value];
					else entries = Array.isArray(value.entry) ? value.entry : [value.entry];
					const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
					const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
					for (const entry of entries) {
						const key = entry[keyProperty];
						const value$1 = entry[valueProperty];
						if (value$1 != null || sparse) buffer$3[key] = this.readSchema(memberNs, value$1);
					}
					return buffer$3;
				}
				if (ns.isStructSchema()) {
					for (const [memberName, memberSchema] of ns.structIterator()) {
						const memberTraits = memberSchema.getMergedTraits();
						const xmlObjectKey = !memberTraits.httpPayload ? memberSchema.getMemberTraits().xmlName ?? memberName : memberTraits.xmlName ?? memberSchema.getName();
						if (value[xmlObjectKey] != null) buffer$3[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
					}
					return buffer$3;
				}
				if (ns.isDocumentSchema()) return value;
				throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
			}
			if (ns.isListSchema()) return [];
			if (ns.isMapSchema() || ns.isStructSchema()) return {};
			return this.stringDeserializer.read(ns, value);
		}
		parseXml(xml) {
			if (xml.length) {
				let parsedObj;
				try {
					parsedObj = (0, import_dist_cjs$113.parseXML)(xml);
				} catch (e$5) {
					if (e$5 && typeof e$5 === "object") Object.defineProperty(e$5, "$responseBodyText", { value: xml });
					throw e$5;
				}
				const textNodeName = "#text";
				const key = Object.keys(parsedObj)[0];
				const parsedObjToReturn = parsedObj[key];
				if (parsedObjToReturn[textNodeName]) {
					parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
					delete parsedObjToReturn[textNodeName];
				}
				return (0, import_dist_cjs$114.getValueFromTextNode)(parsedObjToReturn);
			}
			return {};
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/QueryShapeSerializer.js
var import_dist_cjs$111, import_dist_cjs$112, QueryShapeSerializer;
var init_QueryShapeSerializer = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_serde();
	import_dist_cjs$111 = require_dist_cjs$28();
	import_dist_cjs$112 = require_dist_cjs$43();
	init_ConfigurableSerdeContext();
	init_structIterator();
	QueryShapeSerializer = class extends SerdeContextConfig {
		settings;
		buffer;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		write(schema$3, value, prefix = "") {
			if (this.buffer === void 0) this.buffer = "";
			const ns = NormalizedSchema.of(schema$3);
			if (prefix && !prefix.endsWith(".")) prefix += ".";
			if (ns.isBlobSchema()) {
				if (typeof value === "string" || value instanceof Uint8Array) {
					this.writeKey(prefix);
					this.writeValue((this.serdeContext?.base64Encoder ?? import_dist_cjs$112.toBase64)(value));
				}
			} else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
				if (value != null) {
					this.writeKey(prefix);
					this.writeValue(String(value));
				} else if (ns.isIdempotencyToken()) {
					this.writeKey(prefix);
					this.writeValue((0, import_dist_cjs$143.v4)());
				}
			} else if (ns.isBigIntegerSchema()) {
				if (value != null) {
					this.writeKey(prefix);
					this.writeValue(String(value));
				}
			} else if (ns.isBigDecimalSchema()) {
				if (value != null) {
					this.writeKey(prefix);
					this.writeValue(value instanceof NumericValue ? value.string : String(value));
				}
			} else if (ns.isTimestampSchema()) {
				if (value instanceof Date) {
					this.writeKey(prefix);
					switch (determineTimestampFormat(ns, this.settings)) {
						case 5:
							this.writeValue(value.toISOString().replace(".000Z", "Z"));
							break;
						case 6:
							this.writeValue((0, import_dist_cjs$111.dateToUtcString)(value));
							break;
						case 7:
							this.writeValue(String(value.getTime() / 1e3));
							break;
					}
				}
			} else if (ns.isDocumentSchema()) throw new Error(`@aws-sdk/core/protocols - QuerySerializer unsupported document type ${ns.getName(true)}`);
			else if (ns.isListSchema()) {
				if (Array.isArray(value)) if (value.length === 0) {
					if (this.settings.serializeEmptyLists) {
						this.writeKey(prefix);
						this.writeValue("");
					}
				} else {
					const member$1 = ns.getValueSchema();
					const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
					let i$5 = 1;
					for (const item of value) {
						if (item == null) continue;
						const suffix = this.getKey("member", member$1.getMergedTraits().xmlName);
						const key = flat ? `${prefix}${i$5}` : `${prefix}${suffix}.${i$5}`;
						this.write(member$1, item, key);
						++i$5;
					}
				}
			} else if (ns.isMapSchema()) {
				if (value && typeof value === "object") {
					const keySchema = ns.getKeySchema();
					const memberSchema = ns.getValueSchema();
					const flat = ns.getMergedTraits().xmlFlattened;
					let i$5 = 1;
					for (const [k$5, v$5] of Object.entries(value)) {
						if (v$5 == null) continue;
						const keySuffix = this.getKey("key", keySchema.getMergedTraits().xmlName);
						const key = flat ? `${prefix}${i$5}.${keySuffix}` : `${prefix}entry.${i$5}.${keySuffix}`;
						const valueSuffix = this.getKey("value", memberSchema.getMergedTraits().xmlName);
						const valueKey = flat ? `${prefix}${i$5}.${valueSuffix}` : `${prefix}entry.${i$5}.${valueSuffix}`;
						this.write(keySchema, k$5, key);
						this.write(memberSchema, v$5, valueKey);
						++i$5;
					}
				}
			} else if (ns.isStructSchema()) {
				if (value && typeof value === "object") for (const [memberName, member$1] of serializingStructIterator(ns, value)) {
					if (value[memberName] == null && !member$1.isIdempotencyToken()) continue;
					const suffix = this.getKey(memberName, member$1.getMergedTraits().xmlName);
					const key = `${prefix}${suffix}`;
					this.write(member$1, value[memberName], key);
				}
			} else if (ns.isUnitSchema()) {} else throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
		}
		flush() {
			if (this.buffer === void 0) throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
			const str = this.buffer;
			delete this.buffer;
			return str;
		}
		getKey(memberName, xmlName) {
			const key = xmlName ?? memberName;
			if (this.settings.capitalizeKeys) return key[0].toUpperCase() + key.slice(1);
			return key;
		}
		writeKey(key) {
			if (key.endsWith(".")) key = key.slice(0, key.length - 1);
			this.buffer += `&${extendedEncodeURIComponent(key)}=`;
		}
		writeValue(value) {
			this.buffer += extendedEncodeURIComponent(value);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsQueryProtocol.js
var AwsQueryProtocol;
var init_AwsQueryProtocol = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_ProtocolLib();
	init_XmlShapeDeserializer();
	init_QueryShapeSerializer();
	AwsQueryProtocol = class extends RpcProtocol {
		options;
		serializer;
		deserializer;
		mixin = new ProtocolLib();
		constructor(options) {
			super({ defaultNamespace: options.defaultNamespace });
			this.options = options;
			const settings = {
				timestampFormat: {
					useTrait: true,
					default: 5
				},
				httpBindings: false,
				xmlNamespace: options.xmlNamespace,
				serviceNamespace: options.defaultNamespace,
				serializeEmptyLists: true
			};
			this.serializer = new QueryShapeSerializer(settings);
			this.deserializer = new XmlShapeDeserializer(settings);
		}
		getShapeId() {
			return "aws.protocols#awsQuery";
		}
		setSerdeContext(serdeContext) {
			this.serializer.setSerdeContext(serdeContext);
			this.deserializer.setSerdeContext(serdeContext);
		}
		getPayloadCodec() {
			throw new Error("AWSQuery protocol has no payload codec.");
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			if (!request$1.path.endsWith("/")) request$1.path += "/";
			Object.assign(request$1.headers, { "content-type": `application/x-www-form-urlencoded` });
			if (deref(operationSchema.input) === "unit" || !request$1.body) request$1.body = "";
			request$1.body = `Action=${operationSchema.name.split("#")[1] ?? operationSchema.name}&Version=${this.options.version}` + request$1.body;
			if (request$1.body.endsWith("&")) request$1.body = request$1.body.slice(-1);
			return request$1;
		}
		async deserializeResponse(operationSchema, context, response) {
			const deserializer = this.deserializer;
			const ns = NormalizedSchema.of(operationSchema.output);
			const dataObject = {};
			if (response.statusCode >= 300) {
				const bytes$1 = await collectBody(response.body, context);
				if (bytes$1.byteLength > 0) Object.assign(dataObject, await deserializer.read(15, bytes$1));
				await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
			}
			for (const header in response.headers) {
				const value = response.headers[header];
				delete response.headers[header];
				response.headers[header.toLowerCase()] = value;
			}
			const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
			const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : void 0;
			const bytes = await collectBody(response.body, context);
			if (bytes.byteLength > 0) Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
			return {
				$metadata: this.deserializeMetadata(response),
				...dataObject
			};
		}
		useNestedResult() {
			return true;
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
			const errorData = this.loadQueryError(dataObject);
			const message = this.loadQueryErrorMessage(dataObject);
			errorData.message = message;
			errorData.Error = {
				Type: errorData.Type,
				Code: errorData.Code,
				Message: message
			};
			const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, (registry, errorName) => {
				try {
					return registry.getSchema(errorName);
				} catch (e$5) {
					return registry.find((schema$3) => NormalizedSchema.of(schema$3).getMergedTraits().awsQueryError?.[0] === errorName);
				}
			});
			const ns = NormalizedSchema.of(errorSchema);
			const exception = new ((TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema)) ?? Error)(message);
			const output = { Error: errorData.Error };
			for (const [name, member$1] of ns.structIterator()) {
				const target = member$1.getMergedTraits().xmlName ?? name;
				const value = errorData[target] ?? dataObject[target];
				output[name] = this.deserializer.readSchema(member$1, value);
			}
			throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output), dataObject);
		}
		loadQueryErrorCode(output, data$1) {
			const code = (data$1.Errors?.[0]?.Error ?? data$1.Errors?.Error ?? data$1.Error)?.Code;
			if (code !== void 0) return code;
			if (output.statusCode == 404) return "NotFound";
		}
		loadQueryError(data$1) {
			return data$1.Errors?.[0]?.Error ?? data$1.Errors?.Error ?? data$1.Error;
		}
		loadQueryErrorMessage(data$1) {
			const errorData = this.loadQueryError(data$1);
			return errorData?.message ?? errorData?.Message ?? data$1.message ?? data$1.Message ?? "Unknown";
		}
		getDefaultContentType() {
			return "application/x-www-form-urlencoded";
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/query/AwsEc2QueryProtocol.js
var AwsEc2QueryProtocol;
var init_AwsEc2QueryProtocol = __esmMin((() => {
	init_AwsQueryProtocol();
	AwsEc2QueryProtocol = class extends AwsQueryProtocol {
		options;
		constructor(options) {
			super(options);
			this.options = options;
			Object.assign(this.serializer.settings, {
				capitalizeKeys: true,
				flattenLists: true,
				serializeEmptyLists: false
			});
		}
		useNestedResult() {
			return false;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/parseXmlBody.js
var import_dist_cjs$109, import_dist_cjs$110, parseXmlBody, parseXmlErrorBody, loadRestXmlErrorCode;
var init_parseXmlBody = __esmMin((() => {
	import_dist_cjs$109 = require_dist_cjs$27();
	import_dist_cjs$110 = require_dist_cjs$28();
	init_common();
	parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
		if (encoded.length) {
			let parsedObj;
			try {
				parsedObj = (0, import_dist_cjs$109.parseXML)(encoded);
			} catch (e$5) {
				if (e$5 && typeof e$5 === "object") Object.defineProperty(e$5, "$responseBodyText", { value: encoded });
				throw e$5;
			}
			const textNodeName = "#text";
			const key = Object.keys(parsedObj)[0];
			const parsedObjToReturn = parsedObj[key];
			if (parsedObjToReturn[textNodeName]) {
				parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
				delete parsedObjToReturn[textNodeName];
			}
			return (0, import_dist_cjs$110.getValueFromTextNode)(parsedObjToReturn);
		}
		return {};
	});
	parseXmlErrorBody = async (errorBody, context) => {
		const value = await parseXmlBody(errorBody, context);
		if (value.Error) value.Error.message = value.Error.message ?? value.Error.Message;
		return value;
	};
	loadRestXmlErrorCode = (output, data$1) => {
		if (data$1?.Error?.Code !== void 0) return data$1.Error.Code;
		if (data$1?.Code !== void 0) return data$1.Code;
		if (output.statusCode == 404) return "NotFound";
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlShapeSerializer.js
var import_dist_cjs$106, import_dist_cjs$107, import_dist_cjs$108, XmlShapeSerializer;
var init_XmlShapeSerializer = __esmMin((() => {
	import_dist_cjs$106 = require_dist_cjs$27();
	init_protocols$1();
	init_schema();
	init_serde();
	import_dist_cjs$107 = require_dist_cjs$28();
	import_dist_cjs$108 = require_dist_cjs$43();
	init_ConfigurableSerdeContext();
	init_structIterator();
	XmlShapeSerializer = class extends SerdeContextConfig {
		settings;
		stringBuffer;
		byteBuffer;
		buffer;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		write(schema$3, value) {
			const ns = NormalizedSchema.of(schema$3);
			if (ns.isStringSchema() && typeof value === "string") this.stringBuffer = value;
			else if (ns.isBlobSchema()) this.byteBuffer = "byteLength" in value ? value : (this.serdeContext?.base64Decoder ?? import_dist_cjs$108.fromBase64)(value);
			else {
				this.buffer = this.writeStruct(ns, value, void 0);
				const traits = ns.getMergedTraits();
				if (traits.httpPayload && !traits.xmlName) this.buffer.withName(ns.getName());
			}
		}
		flush() {
			if (this.byteBuffer !== void 0) {
				const bytes = this.byteBuffer;
				delete this.byteBuffer;
				return bytes;
			}
			if (this.stringBuffer !== void 0) {
				const str = this.stringBuffer;
				delete this.stringBuffer;
				return str;
			}
			const buffer$3 = this.buffer;
			if (this.settings.xmlNamespace) {
				if (!buffer$3?.attributes?.["xmlns"]) buffer$3.addAttribute("xmlns", this.settings.xmlNamespace);
			}
			delete this.buffer;
			return buffer$3.toString();
		}
		writeStruct(ns, value, parentXmlns) {
			const traits = ns.getMergedTraits();
			const name = ns.isMemberSchema() && !traits.httpPayload ? ns.getMemberTraits().xmlName ?? ns.getMemberName() : traits.xmlName ?? ns.getName();
			if (!name || !ns.isStructSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
			const structXmlNode = import_dist_cjs$106.XmlNode.of(name);
			const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
			for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {
				const val = value[memberName];
				if (val != null || memberSchema.isIdempotencyToken()) {
					if (memberSchema.getMergedTraits().xmlAttribute) {
						structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
						continue;
					}
					if (memberSchema.isListSchema()) this.writeList(memberSchema, val, structXmlNode, xmlns);
					else if (memberSchema.isMapSchema()) this.writeMap(memberSchema, val, structXmlNode, xmlns);
					else if (memberSchema.isStructSchema()) structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
					else {
						const memberNode = import_dist_cjs$106.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
						this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
						structXmlNode.addChildNode(memberNode);
					}
				}
			}
			if (xmlns) structXmlNode.addAttribute(xmlnsAttr, xmlns);
			return structXmlNode;
		}
		writeList(listMember, array, container, parentXmlns) {
			if (!listMember.isMemberSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
			const listTraits = listMember.getMergedTraits();
			const listValueSchema = listMember.getValueSchema();
			const listValueTraits = listValueSchema.getMergedTraits();
			const sparse = !!listValueTraits.sparse;
			const flat = !!listTraits.xmlFlattened;
			const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
			const writeItem = (container$1, value) => {
				if (listValueSchema.isListSchema()) this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container$1, xmlns);
				else if (listValueSchema.isMapSchema()) this.writeMap(listValueSchema, value, container$1, xmlns);
				else if (listValueSchema.isStructSchema()) {
					const struct$1 = this.writeStruct(listValueSchema, value, xmlns);
					container$1.addChildNode(struct$1.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
				} else {
					const listItemNode = import_dist_cjs$106.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
					this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
					container$1.addChildNode(listItemNode);
				}
			};
			if (flat) {
				for (const value of array) if (sparse || value != null) writeItem(container, value);
			} else {
				const listNode = import_dist_cjs$106.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
				if (xmlns) listNode.addAttribute(xmlnsAttr, xmlns);
				for (const value of array) if (sparse || value != null) writeItem(listNode, value);
				container.addChildNode(listNode);
			}
		}
		writeMap(mapMember, map$2, container, parentXmlns, containerIsMap = false) {
			if (!mapMember.isMemberSchema()) throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
			const mapTraits = mapMember.getMergedTraits();
			const mapKeySchema = mapMember.getKeySchema();
			const keyTag = mapKeySchema.getMergedTraits().xmlName ?? "key";
			const mapValueSchema = mapMember.getValueSchema();
			const mapValueTraits = mapValueSchema.getMergedTraits();
			const valueTag = mapValueTraits.xmlName ?? "value";
			const sparse = !!mapValueTraits.sparse;
			const flat = !!mapTraits.xmlFlattened;
			const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
			const addKeyValue = (entry, key, val) => {
				const keyNode = import_dist_cjs$106.XmlNode.of(keyTag, key);
				const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
				if (keyXmlns) keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
				entry.addChildNode(keyNode);
				let valueNode = import_dist_cjs$106.XmlNode.of(valueTag);
				if (mapValueSchema.isListSchema()) this.writeList(mapValueSchema, val, valueNode, xmlns);
				else if (mapValueSchema.isMapSchema()) this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
				else if (mapValueSchema.isStructSchema()) valueNode = this.writeStruct(mapValueSchema, val, xmlns);
				else this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
				entry.addChildNode(valueNode);
			};
			if (flat) {
				for (const [key, val] of Object.entries(map$2)) if (sparse || val != null) {
					const entry = import_dist_cjs$106.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
					addKeyValue(entry, key, val);
					container.addChildNode(entry);
				}
			} else {
				let mapNode;
				if (!containerIsMap) {
					mapNode = import_dist_cjs$106.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
					if (xmlns) mapNode.addAttribute(xmlnsAttr, xmlns);
					container.addChildNode(mapNode);
				}
				for (const [key, val] of Object.entries(map$2)) if (sparse || val != null) {
					const entry = import_dist_cjs$106.XmlNode.of("entry");
					addKeyValue(entry, key, val);
					(containerIsMap ? container : mapNode).addChildNode(entry);
				}
			}
		}
		writeSimple(_schema, value) {
			if (null === value) throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
			const ns = NormalizedSchema.of(_schema);
			let nodeContents = null;
			if (value && typeof value === "object") if (ns.isBlobSchema()) nodeContents = (this.serdeContext?.base64Encoder ?? import_dist_cjs$108.toBase64)(value);
			else if (ns.isTimestampSchema() && value instanceof Date) switch (determineTimestampFormat(ns, this.settings)) {
				case 5:
					nodeContents = value.toISOString().replace(".000Z", "Z");
					break;
				case 6:
					nodeContents = (0, import_dist_cjs$107.dateToUtcString)(value);
					break;
				case 7:
					nodeContents = String(value.getTime() / 1e3);
					break;
				default:
					console.warn("Missing timestamp format, using http date", value);
					nodeContents = (0, import_dist_cjs$107.dateToUtcString)(value);
					break;
			}
			else if (ns.isBigDecimalSchema() && value) {
				if (value instanceof NumericValue) return value.string;
				return String(value);
			} else if (ns.isMapSchema() || ns.isListSchema()) throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
			else throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
			if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) nodeContents = String(value);
			if (ns.isStringSchema()) if (value === void 0 && ns.isIdempotencyToken()) nodeContents = (0, import_dist_cjs$143.v4)();
			else nodeContents = String(value);
			if (nodeContents === null) throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
			return nodeContents;
		}
		writeSimpleInto(_schema, value, into, parentXmlns) {
			const nodeContents = this.writeSimple(_schema, value);
			const ns = NormalizedSchema.of(_schema);
			const content = new import_dist_cjs$106.XmlText(nodeContents);
			const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
			if (xmlns) into.addAttribute(xmlnsAttr, xmlns);
			into.addChildNode(content);
		}
		getXmlnsAttribute(ns, parentXmlns) {
			const [prefix, xmlns] = ns.getMergedTraits().xmlNamespace ?? [];
			if (xmlns && xmlns !== parentXmlns) return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
			return [void 0, void 0];
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/XmlCodec.js
var XmlCodec;
var init_XmlCodec = __esmMin((() => {
	init_ConfigurableSerdeContext();
	init_XmlShapeDeserializer();
	init_XmlShapeSerializer();
	XmlCodec = class extends SerdeContextConfig {
		settings;
		constructor(settings) {
			super();
			this.settings = settings;
		}
		createSerializer() {
			const serializer = new XmlShapeSerializer(this.settings);
			serializer.setSerdeContext(this.serdeContext);
			return serializer;
		}
		createDeserializer() {
			const deserializer = new XmlShapeDeserializer(this.settings);
			deserializer.setSerdeContext(this.serdeContext);
			return deserializer;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/xml/AwsRestXmlProtocol.js
var AwsRestXmlProtocol;
var init_AwsRestXmlProtocol = __esmMin((() => {
	init_protocols$1();
	init_schema();
	init_ProtocolLib();
	init_parseXmlBody();
	init_XmlCodec();
	AwsRestXmlProtocol = class extends HttpBindingProtocol {
		codec;
		serializer;
		deserializer;
		mixin = new ProtocolLib();
		constructor(options) {
			super(options);
			const settings = {
				timestampFormat: {
					useTrait: true,
					default: 5
				},
				httpBindings: true,
				xmlNamespace: options.xmlNamespace,
				serviceNamespace: options.defaultNamespace
			};
			this.codec = new XmlCodec(settings);
			this.serializer = new HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
			this.deserializer = new HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
		}
		getPayloadCodec() {
			return this.codec;
		}
		getShapeId() {
			return "aws.protocols#restXml";
		}
		async serializeRequest(operationSchema, input, context) {
			const request$1 = await super.serializeRequest(operationSchema, input, context);
			const inputSchema = NormalizedSchema.of(operationSchema.input);
			if (!request$1.headers["content-type"]) {
				const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
				if (contentType) request$1.headers["content-type"] = contentType;
			}
			if (request$1.headers["content-type"] === this.getDefaultContentType()) {
				if (typeof request$1.body === "string") request$1.body = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + request$1.body;
			}
			return request$1;
		}
		async deserializeResponse(operationSchema, context, response) {
			return super.deserializeResponse(operationSchema, context, response);
		}
		async handleError(operationSchema, context, response, dataObject, metadata) {
			const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
			const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
			const ns = NormalizedSchema.of(errorSchema);
			const message = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
			const exception = new ((TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema)) ?? Error)(message);
			await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
			const output = {};
			for (const [name, member$1] of ns.structIterator()) {
				const target = member$1.getMergedTraits().xmlName ?? name;
				const value = dataObject.Error?.[target] ?? dataObject[target];
				output[name] = this.codec.createDeserializer().readSchema(member$1, value);
			}
			throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
				$fault: ns.getMergedTraits().error,
				message
			}, output), dataObject);
		}
		getDefaultContentType() {
			return "application/xml";
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/submodules/protocols/index.js
var protocols_exports = /* @__PURE__ */ __export({
	AwsEc2QueryProtocol: () => AwsEc2QueryProtocol,
	AwsJson1_0Protocol: () => AwsJson1_0Protocol,
	AwsJson1_1Protocol: () => AwsJson1_1Protocol,
	AwsJsonRpcProtocol: () => AwsJsonRpcProtocol,
	AwsQueryProtocol: () => AwsQueryProtocol,
	AwsRestJsonProtocol: () => AwsRestJsonProtocol,
	AwsRestXmlProtocol: () => AwsRestXmlProtocol,
	AwsSmithyRpcV2CborProtocol: () => AwsSmithyRpcV2CborProtocol,
	JsonCodec: () => JsonCodec,
	JsonShapeDeserializer: () => JsonShapeDeserializer,
	JsonShapeSerializer: () => JsonShapeSerializer,
	XmlCodec: () => XmlCodec,
	XmlShapeDeserializer: () => XmlShapeDeserializer,
	XmlShapeSerializer: () => XmlShapeSerializer,
	_toBool: () => _toBool,
	_toNum: () => _toNum,
	_toStr: () => _toStr,
	awsExpectUnion: () => awsExpectUnion,
	loadRestJsonErrorCode: () => loadRestJsonErrorCode,
	loadRestXmlErrorCode: () => loadRestXmlErrorCode,
	parseJsonBody: () => parseJsonBody,
	parseJsonErrorBody: () => parseJsonErrorBody,
	parseXmlBody: () => parseXmlBody,
	parseXmlErrorBody: () => parseXmlErrorBody
});
var init_protocols = __esmMin((() => {
	init_AwsSmithyRpcV2CborProtocol();
	init_coercing_serializers();
	init_AwsJson1_0Protocol();
	init_AwsJson1_1Protocol();
	init_AwsJsonRpcProtocol();
	init_AwsRestJsonProtocol();
	init_JsonCodec();
	init_JsonShapeDeserializer();
	init_JsonShapeSerializer();
	init_awsExpectUnion();
	init_parseJsonBody();
	init_AwsEc2QueryProtocol();
	init_AwsQueryProtocol();
	init_AwsRestXmlProtocol();
	init_XmlCodec();
	init_XmlShapeDeserializer();
	init_XmlShapeSerializer();
	init_parseXmlBody();
}));

//#endregion
//#region node_modules/@aws-sdk/core/dist-es/index.js
var dist_es_exports = /* @__PURE__ */ __export({
	AWSSDKSigV4Signer: () => AWSSDKSigV4Signer,
	AwsEc2QueryProtocol: () => AwsEc2QueryProtocol,
	AwsJson1_0Protocol: () => AwsJson1_0Protocol,
	AwsJson1_1Protocol: () => AwsJson1_1Protocol,
	AwsJsonRpcProtocol: () => AwsJsonRpcProtocol,
	AwsQueryProtocol: () => AwsQueryProtocol,
	AwsRestJsonProtocol: () => AwsRestJsonProtocol,
	AwsRestXmlProtocol: () => AwsRestXmlProtocol,
	AwsSdkSigV4ASigner: () => AwsSdkSigV4ASigner,
	AwsSdkSigV4Signer: () => AwsSdkSigV4Signer,
	AwsSmithyRpcV2CborProtocol: () => AwsSmithyRpcV2CborProtocol,
	JsonCodec: () => JsonCodec,
	JsonShapeDeserializer: () => JsonShapeDeserializer,
	JsonShapeSerializer: () => JsonShapeSerializer,
	NODE_AUTH_SCHEME_PREFERENCE_OPTIONS: () => NODE_AUTH_SCHEME_PREFERENCE_OPTIONS,
	NODE_SIGV4A_CONFIG_OPTIONS: () => NODE_SIGV4A_CONFIG_OPTIONS,
	XmlCodec: () => XmlCodec,
	XmlShapeDeserializer: () => XmlShapeDeserializer,
	XmlShapeSerializer: () => XmlShapeSerializer,
	_toBool: () => _toBool,
	_toNum: () => _toNum,
	_toStr: () => _toStr,
	awsExpectUnion: () => awsExpectUnion,
	emitWarningIfUnsupportedVersion: () => emitWarningIfUnsupportedVersion,
	getBearerTokenEnvKey: () => getBearerTokenEnvKey,
	loadRestJsonErrorCode: () => loadRestJsonErrorCode,
	loadRestXmlErrorCode: () => loadRestXmlErrorCode,
	parseJsonBody: () => parseJsonBody,
	parseJsonErrorBody: () => parseJsonErrorBody,
	parseXmlBody: () => parseXmlBody,
	parseXmlErrorBody: () => parseXmlErrorBody,
	resolveAWSSDKSigV4Config: () => resolveAWSSDKSigV4Config,
	resolveAwsSdkSigV4AConfig: () => resolveAwsSdkSigV4AConfig,
	resolveAwsSdkSigV4Config: () => resolveAwsSdkSigV4Config,
	setCredentialFeature: () => setCredentialFeature,
	setFeature: () => setFeature,
	setTokenFeature: () => setTokenFeature,
	state: () => state,
	validateSigningProperties: () => validateSigningProperties
});
var init_dist_es = __esmMin((() => {
	init_client();
	init_httpAuthSchemes();
	init_protocols();
}));

//#endregion
//#region node_modules/@aws-sdk/middleware-user-agent/dist-cjs/index.js
var require_dist_cjs$26 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var core$3 = (init_dist_es$1(), __toCommonJS(dist_es_exports$1));
	var utilEndpoints$1 = require_dist_cjs$32();
	var protocolHttp$5 = require_dist_cjs$52();
	var core$1$1 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const DEFAULT_UA_APP_ID = void 0;
	function isValidUserAgentAppId(appId) {
		if (appId === void 0) return true;
		return typeof appId === "string" && appId.length <= 50;
	}
	function resolveUserAgentConfig$3(input) {
		const normalizedAppIdProvider = core$3.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
		const { customUserAgent } = input;
		return Object.assign(input, {
			customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
			userAgentAppId: async () => {
				const appId = await normalizedAppIdProvider();
				if (!isValidUserAgentAppId(appId)) {
					const logger$1 = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
					if (typeof appId !== "string") logger$1?.warn("userAgentAppId must be a string or undefined.");
					else if (appId.length > 50) logger$1?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
				}
				return appId;
			}
		});
	}
	const ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
	async function checkFeatures(context, config, args) {
		if (args.request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") core$1$1.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
		if (typeof config.retryStrategy === "function") {
			const retryStrategy = await config.retryStrategy();
			if (typeof retryStrategy.acquireInitialRetryToken === "function") if (retryStrategy.constructor?.name?.includes("Adaptive")) core$1$1.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
			else core$1$1.setFeature(context, "RETRY_MODE_STANDARD", "E");
			else core$1$1.setFeature(context, "RETRY_MODE_LEGACY", "D");
		}
		if (typeof config.accountIdEndpointMode === "function") {
			const endpointV2 = context.endpointV2;
			if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) core$1$1.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
			switch (await config.accountIdEndpointMode?.()) {
				case "disabled":
					core$1$1.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
					break;
				case "preferred":
					core$1$1.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
					break;
				case "required":
					core$1$1.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
					break;
			}
		}
		const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
		if (identity?.$source) {
			const credentials = identity;
			if (credentials.accountId) core$1$1.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
			for (const [key, value] of Object.entries(credentials.$source ?? {})) core$1$1.setFeature(context, key, value);
		}
	}
	const USER_AGENT = "user-agent";
	const X_AMZ_USER_AGENT = "x-amz-user-agent";
	const SPACE = " ";
	const UA_NAME_SEPARATOR = "/";
	const UA_NAME_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w]/g;
	const UA_VALUE_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w#]/g;
	const UA_ESCAPE_CHAR = "-";
	const BYTE_LIMIT = 1024;
	function encodeFeatures(features) {
		let buffer$3 = "";
		for (const key in features) {
			const val = features[key];
			if (buffer$3.length + val.length + 1 <= BYTE_LIMIT) {
				if (buffer$3.length) buffer$3 += "," + val;
				else buffer$3 += val;
				continue;
			}
			break;
		}
		return buffer$3;
	}
	const userAgentMiddleware = (options) => (next, context) => async (args) => {
		const { request: request$1 } = args;
		if (!protocolHttp$5.HttpRequest.isInstance(request$1)) return next(args);
		const { headers } = request$1;
		const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
		const defaultUserAgent$1 = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
		await checkFeatures(context, options, args);
		const awsContext = context;
		defaultUserAgent$1.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
		const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
		const appId = await options.userAgentAppId();
		if (appId) defaultUserAgent$1.push(escapeUserAgent([`app`, `${appId}`]));
		const prefix = utilEndpoints$1.getUserAgentPrefix();
		const sdkUserAgentValue = (prefix ? [prefix] : []).concat([
			...defaultUserAgent$1,
			...userAgent,
			...customUserAgent
		]).join(SPACE);
		const normalUAValue = [...defaultUserAgent$1.filter((section) => section.startsWith("aws-sdk-")), ...customUserAgent].join(SPACE);
		if (options.runtime !== "browser") {
			if (normalUAValue) headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT] ? `${headers[USER_AGENT]} ${normalUAValue}` : normalUAValue;
			headers[USER_AGENT] = sdkUserAgentValue;
		} else headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
		return next({
			...args,
			request: request$1
		});
	};
	const escapeUserAgent = (userAgentPair) => {
		const name = userAgentPair[0].split(UA_NAME_SEPARATOR).map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR);
		const version$1 = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
		const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
		const prefix = name.substring(0, prefixSeparatorIndex);
		let uaName = name.substring(prefixSeparatorIndex + 1);
		if (prefix === "api") uaName = uaName.toLowerCase();
		return [
			prefix,
			uaName,
			version$1
		].filter((item) => item && item.length > 0).reduce((acc, item, index) => {
			switch (index) {
				case 0: return item;
				case 1: return `${acc}/${item}`;
				default: return `${acc}#${item}`;
			}
		}, "");
	};
	const getUserAgentMiddlewareOptions = {
		name: "getUserAgentMiddleware",
		step: "build",
		priority: "low",
		tags: ["SET_USER_AGENT", "USER_AGENT"],
		override: true
	};
	const getUserAgentPlugin$3 = (config) => ({ applyToStack: (clientStack) => {
		clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
	} });
	exports.DEFAULT_UA_APP_ID = DEFAULT_UA_APP_ID;
	exports.getUserAgentMiddlewareOptions = getUserAgentMiddlewareOptions;
	exports.getUserAgentPlugin = getUserAgentPlugin$3;
	exports.resolveUserAgentConfig = resolveUserAgentConfig$3;
	exports.userAgentMiddleware = userAgentMiddleware;
}));

//#endregion
//#region node_modules/@smithy/util-config-provider/dist-cjs/index.js
var require_dist_cjs$25 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const booleanSelector = (obj, key, type) => {
		if (!(key in obj)) return void 0;
		if (obj[key] === "true") return true;
		if (obj[key] === "false") return false;
		throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
	};
	const numberSelector = (obj, key, type) => {
		if (!(key in obj)) return void 0;
		const numberValue = parseInt(obj[key], 10);
		if (Number.isNaN(numberValue)) throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
		return numberValue;
	};
	exports.SelectorType = void 0;
	(function(SelectorType) {
		SelectorType["ENV"] = "env";
		SelectorType["CONFIG"] = "shared config entry";
	})(exports.SelectorType || (exports.SelectorType = {}));
	exports.booleanSelector = booleanSelector;
	exports.numberSelector = numberSelector;
}));

//#endregion
//#region node_modules/@smithy/config-resolver/dist-cjs/index.js
var require_dist_cjs$24 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilConfigProvider = require_dist_cjs$25();
	var utilMiddleware$2 = require_dist_cjs$48();
	var utilEndpoints = require_dist_cjs$35();
	const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
	const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
	const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
	const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.ENV),
		configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
		default: false
	};
	const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
	const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
	const DEFAULT_USE_FIPS_ENDPOINT = false;
	const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.ENV),
		configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
		default: false
	};
	const resolveCustomEndpointsConfig = (input) => {
		const { tls: tls$2, endpoint, urlParser: urlParser$3, useDualstackEndpoint } = input;
		return Object.assign(input, {
			tls: tls$2 ?? true,
			endpoint: utilMiddleware$2.normalizeProvider(typeof endpoint === "string" ? urlParser$3(endpoint) : endpoint),
			isCustomEndpoint: true,
			useDualstackEndpoint: utilMiddleware$2.normalizeProvider(useDualstackEndpoint ?? false)
		});
	};
	const getEndpointFromRegion = async (input) => {
		const { tls: tls$2 = true } = input;
		const region = await input.region();
		if (!(/* @__PURE__ */ new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/)).test(region)) throw new Error("Invalid region in client config");
		const useDualstackEndpoint = await input.useDualstackEndpoint();
		const useFipsEndpoint = await input.useFipsEndpoint();
		const { hostname } = await input.regionInfoProvider(region, {
			useDualstackEndpoint,
			useFipsEndpoint
		}) ?? {};
		if (!hostname) throw new Error("Cannot resolve hostname from client config");
		return input.urlParser(`${tls$2 ? "https:" : "http:"}//${hostname}`);
	};
	const resolveEndpointsConfig = (input) => {
		const useDualstackEndpoint = utilMiddleware$2.normalizeProvider(input.useDualstackEndpoint ?? false);
		const { endpoint, useFipsEndpoint, urlParser: urlParser$3, tls: tls$2 } = input;
		return Object.assign(input, {
			tls: tls$2 ?? true,
			endpoint: endpoint ? utilMiddleware$2.normalizeProvider(typeof endpoint === "string" ? urlParser$3(endpoint) : endpoint) : () => getEndpointFromRegion({
				...input,
				useDualstackEndpoint,
				useFipsEndpoint
			}),
			isCustomEndpoint: !!endpoint,
			useDualstackEndpoint
		});
	};
	const REGION_ENV_NAME = "AWS_REGION";
	const REGION_INI_NAME = "region";
	const NODE_REGION_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => env[REGION_ENV_NAME],
		configFileSelector: (profile) => profile[REGION_INI_NAME],
		default: () => {
			throw new Error("Region is missing");
		}
	};
	const NODE_REGION_CONFIG_FILE_OPTIONS$3 = { preferredFile: "credentials" };
	const validRegions = /* @__PURE__ */ new Set();
	const checkRegion = (region, check = utilEndpoints.isValidHostLabel) => {
		if (!validRegions.has(region) && !check(region)) if (region === "*") console.warn(`@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.`);
		else throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
		else validRegions.add(region);
	};
	const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
	const getRealRegion = (region) => isFipsRegion(region) ? ["fips-aws-global", "aws-fips"].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
	const resolveRegionConfig$3 = (input) => {
		const { region, useFipsEndpoint } = input;
		if (!region) throw new Error("Region is missing");
		return Object.assign(input, {
			region: async () => {
				const realRegion = getRealRegion(typeof region === "function" ? await region() : region);
				checkRegion(realRegion);
				return realRegion;
			},
			useFipsEndpoint: async () => {
				if (isFipsRegion(typeof region === "string" ? region : await region())) return true;
				return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
			}
		});
	};
	const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;
	const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : void 0;
	const getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";
	const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
		if (signingRegion) return signingRegion;
		else if (useFipsEndpoint) {
			const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
			const regionRegexmatchArray = hostname.match(regionRegexJs);
			if (regionRegexmatchArray) return regionRegexmatchArray[0].slice(1, -1);
		}
	};
	const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash }) => {
		const partition$1 = getResolvedPartition(region, { partitionHash });
		const resolvedRegion = region in regionHash ? region : partitionHash[partition$1]?.endpoint ?? region;
		const hostnameOptions = {
			useFipsEndpoint,
			useDualstackEndpoint
		};
		const hostname = getResolvedHostname(resolvedRegion, {
			regionHostname: getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions),
			partitionHostname: getHostnameFromVariants(partitionHash[partition$1]?.variants, hostnameOptions)
		});
		if (hostname === void 0) throw new Error(`Endpoint resolution failed for: [object Object]`);
		const signingRegion = getResolvedSigningRegion(hostname, {
			signingRegion: regionHash[resolvedRegion]?.signingRegion,
			regionRegex: partitionHash[partition$1].regionRegex,
			useFipsEndpoint
		});
		return {
			partition: partition$1,
			signingService,
			hostname,
			...signingRegion && { signingRegion },
			...regionHash[resolvedRegion]?.signingService && { signingService: regionHash[resolvedRegion].signingService }
		};
	};
	exports.CONFIG_USE_DUALSTACK_ENDPOINT = CONFIG_USE_DUALSTACK_ENDPOINT;
	exports.CONFIG_USE_FIPS_ENDPOINT = CONFIG_USE_FIPS_ENDPOINT;
	exports.DEFAULT_USE_DUALSTACK_ENDPOINT = DEFAULT_USE_DUALSTACK_ENDPOINT;
	exports.DEFAULT_USE_FIPS_ENDPOINT = DEFAULT_USE_FIPS_ENDPOINT;
	exports.ENV_USE_DUALSTACK_ENDPOINT = ENV_USE_DUALSTACK_ENDPOINT;
	exports.ENV_USE_FIPS_ENDPOINT = ENV_USE_FIPS_ENDPOINT;
	exports.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS$3;
	exports.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS$3;
	exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS$3;
	exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS$3;
	exports.REGION_ENV_NAME = REGION_ENV_NAME;
	exports.REGION_INI_NAME = REGION_INI_NAME;
	exports.getRegionInfo = getRegionInfo;
	exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
	exports.resolveEndpointsConfig = resolveEndpointsConfig;
	exports.resolveRegionConfig = resolveRegionConfig$3;
}));

//#endregion
//#region node_modules/@smithy/middleware-content-length/dist-cjs/index.js
var require_dist_cjs$23 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var protocolHttp$4 = require_dist_cjs$52();
	const CONTENT_LENGTH_HEADER = "content-length";
	function contentLengthMiddleware(bodyLengthChecker) {
		return (next) => async (args) => {
			const request$1 = args.request;
			if (protocolHttp$4.HttpRequest.isInstance(request$1)) {
				const { body, headers } = request$1;
				if (body && Object.keys(headers).map((str) => str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) try {
					const length = bodyLengthChecker(body);
					request$1.headers = {
						...request$1.headers,
						[CONTENT_LENGTH_HEADER]: String(length)
					};
				} catch (error$2) {}
			}
			return next({
				...args,
				request: request$1
			});
		};
	}
	const contentLengthMiddlewareOptions = {
		step: "build",
		tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
		name: "contentLengthMiddleware",
		override: true
	};
	const getContentLengthPlugin$3 = (options) => ({ applyToStack: (clientStack) => {
		clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
	} });
	exports.contentLengthMiddleware = contentLengthMiddleware;
	exports.contentLengthMiddlewareOptions = contentLengthMiddlewareOptions;
	exports.getContentLengthPlugin = getContentLengthPlugin$3;
}));

//#endregion
//#region node_modules/@smithy/shared-ini-file-loader/dist-cjs/getHomeDir.js
var require_getHomeDir = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getHomeDir = void 0;
	const os_1 = __require("os");
	const path_1$1 = __require("path");
	const homeDirCache = {};
	const getHomeDirCacheKey = () => {
		if (process && process.geteuid) return `${process.geteuid()}`;
		return "DEFAULT";
	};
	const getHomeDir$1 = () => {
		const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1$1.sep}` } = process.env;
		if (HOME) return HOME;
		if (USERPROFILE) return USERPROFILE;
		if (HOMEPATH) return `${HOMEDRIVE}${HOMEPATH}`;
		const homeDirCacheKey = getHomeDirCacheKey();
		if (!homeDirCache[homeDirCacheKey]) homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
		return homeDirCache[homeDirCacheKey];
	};
	exports.getHomeDir = getHomeDir$1;
}));

//#endregion
//#region node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFilepath.js
var require_getSSOTokenFilepath = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getSSOTokenFilepath = void 0;
	const crypto_1 = __require("crypto");
	const path_1 = __require("path");
	const getHomeDir_1 = require_getHomeDir();
	const getSSOTokenFilepath$1 = (id) => {
		const cacheName = (0, crypto_1.createHash)("sha1").update(id).digest("hex");
		return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
	};
	exports.getSSOTokenFilepath = getSSOTokenFilepath$1;
}));

//#endregion
//#region node_modules/@smithy/shared-ini-file-loader/dist-cjs/getSSOTokenFromFile.js
var require_getSSOTokenFromFile = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getSSOTokenFromFile = exports.tokenIntercept = void 0;
	const promises_1$2 = __require("fs/promises");
	const getSSOTokenFilepath_1 = require_getSSOTokenFilepath();
	exports.tokenIntercept = {};
	const getSSOTokenFromFile$1 = async (id) => {
		if (exports.tokenIntercept[id]) return exports.tokenIntercept[id];
		const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
		const ssoTokenText = await (0, promises_1$2.readFile)(ssoTokenFilepath, "utf8");
		return JSON.parse(ssoTokenText);
	};
	exports.getSSOTokenFromFile = getSSOTokenFromFile$1;
}));

//#endregion
//#region node_modules/@smithy/shared-ini-file-loader/dist-cjs/readFile.js
var require_readFile = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.readFile = exports.fileIntercept = exports.filePromises = void 0;
	const promises_1$1 = __require("node:fs/promises");
	exports.filePromises = {};
	exports.fileIntercept = {};
	const readFile$1 = (path$6, options) => {
		if (exports.fileIntercept[path$6] !== void 0) return exports.fileIntercept[path$6];
		if (!exports.filePromises[path$6] || options?.ignoreCache) exports.filePromises[path$6] = (0, promises_1$1.readFile)(path$6, "utf8");
		return exports.filePromises[path$6];
	};
	exports.readFile = readFile$1;
}));

//#endregion
//#region node_modules/@smithy/shared-ini-file-loader/dist-cjs/index.js
var require_dist_cjs$22 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var getHomeDir = require_getHomeDir();
	var getSSOTokenFilepath = require_getSSOTokenFilepath();
	var getSSOTokenFromFile = require_getSSOTokenFromFile();
	var path = __require("path");
	var types = require_dist_cjs$53();
	var readFile = require_readFile();
	const ENV_PROFILE = "AWS_PROFILE";
	const DEFAULT_PROFILE = "default";
	const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;
	const CONFIG_PREFIX_SEPARATOR = ".";
	const getConfigData = (data$1) => Object.entries(data$1).filter(([key]) => {
		const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
		if (indexOfSeparator === -1) return false;
		return Object.values(types.IniSectionType).includes(key.substring(0, indexOfSeparator));
	}).reduce((acc, [key, value]) => {
		const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
		const updatedKey = key.substring(0, indexOfSeparator) === types.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
		acc[updatedKey] = value;
		return acc;
	}, { ...data$1.default && { default: data$1.default } });
	const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
	const getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "config");
	const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
	const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "credentials");
	const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
	const profileNameBlockList = ["__proto__", "profile __proto__"];
	const parseIni = (iniData) => {
		const map$2 = {};
		let currentSection;
		let currentSubSection;
		for (const iniLine of iniData.split(/\r?\n/)) {
			const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
			if (trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]") {
				currentSection = void 0;
				currentSubSection = void 0;
				const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
				const matches = prefixKeyRegex.exec(sectionName);
				if (matches) {
					const [, prefix, , name] = matches;
					if (Object.values(types.IniSectionType).includes(prefix)) currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
				} else currentSection = sectionName;
				if (profileNameBlockList.includes(sectionName)) throw new Error(`Found invalid profile name "${sectionName}"`);
			} else if (currentSection) {
				const indexOfEqualsSign = trimmedLine.indexOf("=");
				if (![0, -1].includes(indexOfEqualsSign)) {
					const [name, value] = [trimmedLine.substring(0, indexOfEqualsSign).trim(), trimmedLine.substring(indexOfEqualsSign + 1).trim()];
					if (value === "") currentSubSection = name;
					else {
						if (currentSubSection && iniLine.trimStart() === iniLine) currentSubSection = void 0;
						map$2[currentSection] = map$2[currentSection] || {};
						const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
						map$2[currentSection][key] = value;
					}
				}
			}
		}
		return map$2;
	};
	const swallowError$1 = () => ({});
	const loadSharedConfigFiles = async (init = {}) => {
		const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
		const homeDir = getHomeDir.getHomeDir();
		const relativeHomeDirPrefix = "~/";
		let resolvedFilepath = filepath;
		if (filepath.startsWith(relativeHomeDirPrefix)) resolvedFilepath = path.join(homeDir, filepath.slice(2));
		let resolvedConfigFilepath = configFilepath;
		if (configFilepath.startsWith(relativeHomeDirPrefix)) resolvedConfigFilepath = path.join(homeDir, configFilepath.slice(2));
		const parsedFiles = await Promise.all([readFile.readFile(resolvedConfigFilepath, { ignoreCache: init.ignoreCache }).then(parseIni).then(getConfigData).catch(swallowError$1), readFile.readFile(resolvedFilepath, { ignoreCache: init.ignoreCache }).then(parseIni).catch(swallowError$1)]);
		return {
			configFile: parsedFiles[0],
			credentialsFile: parsedFiles[1]
		};
	};
	const getSsoSessionData = (data$1) => Object.entries(data$1).filter(([key]) => key.startsWith(types.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR)).reduce((acc, [key, value]) => ({
		...acc,
		[key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value
	}), {});
	const swallowError = () => ({});
	const loadSsoSessionData = async (init = {}) => readFile.readFile(init.configFilepath ?? getConfigFilepath()).then(parseIni).then(getSsoSessionData).catch(swallowError);
	const mergeConfigFiles = (...files) => {
		const merged = {};
		for (const file of files) for (const [key, values] of Object.entries(file)) if (merged[key] !== void 0) Object.assign(merged[key], values);
		else merged[key] = values;
		return merged;
	};
	const parseKnownFiles = async (init) => {
		const parsedFiles = await loadSharedConfigFiles(init);
		return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
	};
	const externalDataInterceptor = {
		getFileRecord() {
			return readFile.fileIntercept;
		},
		interceptFile(path$6, contents) {
			readFile.fileIntercept[path$6] = Promise.resolve(contents);
		},
		getTokenRecord() {
			return getSSOTokenFromFile.tokenIntercept;
		},
		interceptToken(id, contents) {
			getSSOTokenFromFile.tokenIntercept[id] = contents;
		}
	};
	Object.defineProperty(exports, "getSSOTokenFromFile", {
		enumerable: true,
		get: function() {
			return getSSOTokenFromFile.getSSOTokenFromFile;
		}
	});
	Object.defineProperty(exports, "readFile", {
		enumerable: true,
		get: function() {
			return readFile.readFile;
		}
	});
	exports.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
	exports.DEFAULT_PROFILE = DEFAULT_PROFILE;
	exports.ENV_PROFILE = ENV_PROFILE;
	exports.externalDataInterceptor = externalDataInterceptor;
	exports.getProfileName = getProfileName;
	exports.loadSharedConfigFiles = loadSharedConfigFiles;
	exports.loadSsoSessionData = loadSsoSessionData;
	exports.parseKnownFiles = parseKnownFiles;
	Object.keys(getHomeDir).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return getHomeDir[k$5];
			}
		});
	});
	Object.keys(getSSOTokenFilepath).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return getSSOTokenFilepath[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@smithy/node-config-provider/dist-cjs/index.js
var require_dist_cjs$21 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var propertyProvider$9 = require_dist_cjs$31();
	var sharedIniFileLoader$6 = require_dist_cjs$22();
	function getSelectorName(functionString) {
		try {
			const constants$1 = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
			constants$1.delete("CONFIG");
			constants$1.delete("CONFIG_PREFIX_SEPARATOR");
			constants$1.delete("ENV");
			return [...constants$1].join(", ");
		} catch (e$5) {
			return functionString;
		}
	}
	const fromEnv$1 = (envVarSelector, options) => async () => {
		try {
			const config = envVarSelector(process.env, options);
			if (config === void 0) throw new Error();
			return config;
		} catch (e$5) {
			throw new propertyProvider$9.CredentialsProviderError(e$5.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: options?.logger });
		}
	};
	const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
		const profile = sharedIniFileLoader$6.getProfileName(init);
		const { configFile, credentialsFile } = await sharedIniFileLoader$6.loadSharedConfigFiles(init);
		const profileFromCredentials = credentialsFile[profile] || {};
		const profileFromConfig = configFile[profile] || {};
		const mergedProfile = preferredFile === "config" ? {
			...profileFromCredentials,
			...profileFromConfig
		} : {
			...profileFromConfig,
			...profileFromCredentials
		};
		try {
			const configValue = configSelector(mergedProfile, preferredFile === "config" ? configFile : credentialsFile);
			if (configValue === void 0) throw new Error();
			return configValue;
		} catch (e$5) {
			throw new propertyProvider$9.CredentialsProviderError(e$5.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
		}
	};
	const isFunction = (func) => typeof func === "function";
	const fromStatic$1 = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : propertyProvider$9.fromStatic(defaultValue);
	const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => {
		const { signingName, logger: logger$1 } = configuration;
		const envOptions = {
			signingName,
			logger: logger$1
		};
		return propertyProvider$9.memoize(propertyProvider$9.chain(fromEnv$1(environmentVariableSelector, envOptions), fromSharedConfigFiles(configFileSelector, configuration), fromStatic$1(defaultValue)));
	};
	exports.loadConfig = loadConfig;
}));

//#endregion
//#region node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointUrlConfig.js
var require_getEndpointUrlConfig = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getEndpointUrlConfig = void 0;
	const shared_ini_file_loader_1$1 = require_dist_cjs$22();
	const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
	const CONFIG_ENDPOINT_URL = "endpoint_url";
	const getEndpointUrlConfig = (serviceId) => ({
		environmentVariableSelector: (env) => {
			const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceId.split(" ").map((w$5) => w$5.toUpperCase())].join("_")];
			if (serviceEndpointUrl) return serviceEndpointUrl;
			const endpointUrl = env[ENV_ENDPOINT_URL];
			if (endpointUrl) return endpointUrl;
		},
		configFileSelector: (profile, config) => {
			if (config && profile.services) {
				const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1$1.CONFIG_PREFIX_SEPARATOR)];
				if (servicesSection) {
					const endpointUrl$1 = servicesSection[[serviceId.split(" ").map((w$5) => w$5.toLowerCase()).join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1$1.CONFIG_PREFIX_SEPARATOR)];
					if (endpointUrl$1) return endpointUrl$1;
				}
			}
			const endpointUrl = profile[CONFIG_ENDPOINT_URL];
			if (endpointUrl) return endpointUrl;
		},
		default: void 0
	});
	exports.getEndpointUrlConfig = getEndpointUrlConfig;
}));

//#endregion
//#region node_modules/@smithy/middleware-endpoint/dist-cjs/adaptors/getEndpointFromConfig.js
var require_getEndpointFromConfig = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getEndpointFromConfig = void 0;
	const node_config_provider_1$3 = require_dist_cjs$21();
	const getEndpointUrlConfig_1 = require_getEndpointUrlConfig();
	const getEndpointFromConfig$1 = async (serviceId) => (0, node_config_provider_1$3.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId ?? ""))();
	exports.getEndpointFromConfig = getEndpointFromConfig$1;
}));

//#endregion
//#region node_modules/@smithy/middleware-endpoint/dist-cjs/index.js
var require_dist_cjs$20 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var getEndpointFromConfig = require_getEndpointFromConfig();
	var urlParser$1 = require_dist_cjs$33();
	var core$2 = (init_dist_es$1(), __toCommonJS(dist_es_exports$1));
	var utilMiddleware$1 = require_dist_cjs$48();
	var middlewareSerde = require_dist_cjs$47();
	const resolveParamsForS3 = async (endpointParams) => {
		const bucket = endpointParams?.Bucket || "";
		if (typeof endpointParams.Bucket === "string") endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
		if (isArnBucketName(bucket)) {
			if (endpointParams.ForcePathStyle === true) throw new Error("Path-style addressing cannot be used with ARN buckets");
		} else if (!isDnsCompatibleBucketName(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) endpointParams.ForcePathStyle = true;
		if (endpointParams.DisableMultiRegionAccessPoints) {
			endpointParams.disableMultiRegionAccessPoints = true;
			endpointParams.DisableMRAP = true;
		}
		return endpointParams;
	};
	const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
	const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
	const DOTS_PATTERN = /\.\./;
	const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
	const isArnBucketName = (bucketName) => {
		const [arn, partition$1, service, , , bucket] = bucketName.split(":");
		const isArn = arn === "arn" && bucketName.split(":").length >= 6;
		const isValidArn = Boolean(isArn && partition$1 && service && bucket);
		if (isArn && !isValidArn) throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
		return isValidArn;
	};
	const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config) => {
		const configProvider = async () => {
			const configValue = config[configKey] ?? config[canonicalEndpointParamKey];
			if (typeof configValue === "function") return configValue();
			return configValue;
		};
		if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") return async () => {
			const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
			return credentials?.credentialScope ?? credentials?.CredentialScope;
		};
		if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") return async () => {
			const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
			return credentials?.accountId ?? credentials?.AccountId;
		};
		if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") return async () => {
			if (config.isCustomEndpoint === false) return;
			const endpoint = await configProvider();
			if (endpoint && typeof endpoint === "object") {
				if ("url" in endpoint) return endpoint.url.href;
				if ("hostname" in endpoint) {
					const { protocol, hostname, port, path: path$6 } = endpoint;
					return `${protocol}//${hostname}${port ? ":" + port : ""}${path$6}`;
				}
			}
			return endpoint;
		};
		return configProvider;
	};
	const toEndpointV1 = (endpoint) => {
		if (typeof endpoint === "object") {
			if ("url" in endpoint) return urlParser$1.parseUrl(endpoint.url);
			return endpoint;
		}
		return urlParser$1.parseUrl(endpoint);
	};
	const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
		if (!clientConfig.isCustomEndpoint) {
			let endpointFromConfig;
			if (clientConfig.serviceConfiguredEndpoint) endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
			else endpointFromConfig = await getEndpointFromConfig.getEndpointFromConfig(clientConfig.serviceId);
			if (endpointFromConfig) {
				clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
				clientConfig.isCustomEndpoint = true;
			}
		}
		const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
		if (typeof clientConfig.endpointProvider !== "function") throw new Error("config.endpointProvider is not set.");
		return clientConfig.endpointProvider(endpointParams, context);
	};
	const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
		const endpointParams = {};
		const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
		for (const [name, instruction] of Object.entries(instructions)) switch (instruction.type) {
			case "staticContextParams":
				endpointParams[name] = instruction.value;
				break;
			case "contextParams":
				endpointParams[name] = commandInput[instruction.name];
				break;
			case "clientContextParams":
			case "builtInParams":
				endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig)();
				break;
			case "operationContextParams":
				endpointParams[name] = instruction.get(commandInput);
				break;
			default: throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
		}
		if (Object.keys(instructions).length === 0) Object.assign(endpointParams, clientConfig);
		if (String(clientConfig.serviceId).toLowerCase() === "s3") await resolveParamsForS3(endpointParams);
		return endpointParams;
	};
	const endpointMiddleware = ({ config, instructions }) => {
		return (next, context) => async (args) => {
			if (config.isCustomEndpoint) core$2.setFeature(context, "ENDPOINT_OVERRIDE", "N");
			const endpoint = await getEndpointFromInstructions(args.input, { getEndpointParameterInstructions() {
				return instructions;
			} }, { ...config }, context);
			context.endpointV2 = endpoint;
			context.authSchemes = endpoint.properties?.authSchemes;
			const authScheme = context.authSchemes?.[0];
			if (authScheme) {
				context["signing_region"] = authScheme.signingRegion;
				context["signing_service"] = authScheme.signingName;
				const httpAuthOption = utilMiddleware$1.getSmithyContext(context)?.selectedHttpAuthScheme?.httpAuthOption;
				if (httpAuthOption) httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
					signing_region: authScheme.signingRegion,
					signingRegion: authScheme.signingRegion,
					signing_service: authScheme.signingName,
					signingName: authScheme.signingName,
					signingRegionSet: authScheme.signingRegionSet
				}, authScheme.properties);
			}
			return next({ ...args });
		};
	};
	const endpointMiddlewareOptions = {
		step: "serialize",
		tags: [
			"ENDPOINT_PARAMETERS",
			"ENDPOINT_V2",
			"ENDPOINT"
		],
		name: "endpointV2Middleware",
		override: true,
		relation: "before",
		toMiddleware: middlewareSerde.serializerMiddlewareOption.name
	};
	const getEndpointPlugin$4 = (config, instructions) => ({ applyToStack: (clientStack) => {
		clientStack.addRelativeTo(endpointMiddleware({
			config,
			instructions
		}), endpointMiddlewareOptions);
	} });
	const resolveEndpointConfig$3 = (input) => {
		const tls$2 = input.tls ?? true;
		const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
		const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await utilMiddleware$1.normalizeProvider(endpoint)()) : void 0;
		const isCustomEndpoint = !!endpoint;
		const resolvedConfig = Object.assign(input, {
			endpoint: customEndpointProvider,
			tls: tls$2,
			isCustomEndpoint,
			useDualstackEndpoint: utilMiddleware$1.normalizeProvider(useDualstackEndpoint ?? false),
			useFipsEndpoint: utilMiddleware$1.normalizeProvider(useFipsEndpoint ?? false)
		});
		let configuredEndpointPromise = void 0;
		resolvedConfig.serviceConfiguredEndpoint = async () => {
			if (input.serviceId && !configuredEndpointPromise) configuredEndpointPromise = getEndpointFromConfig.getEndpointFromConfig(input.serviceId);
			return configuredEndpointPromise;
		};
		return resolvedConfig;
	};
	const resolveEndpointRequiredConfig = (input) => {
		const { endpoint } = input;
		if (endpoint === void 0) input.endpoint = async () => {
			throw new Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.");
		};
		return input;
	};
	exports.endpointMiddleware = endpointMiddleware;
	exports.endpointMiddlewareOptions = endpointMiddlewareOptions;
	exports.getEndpointFromInstructions = getEndpointFromInstructions;
	exports.getEndpointPlugin = getEndpointPlugin$4;
	exports.resolveEndpointConfig = resolveEndpointConfig$3;
	exports.resolveEndpointRequiredConfig = resolveEndpointRequiredConfig;
	exports.resolveParams = resolveParams;
	exports.toEndpointV1 = toEndpointV1;
}));

//#endregion
//#region node_modules/@smithy/service-error-classification/dist-cjs/index.js
var require_dist_cjs$19 = /* @__PURE__ */ __commonJSMin(((exports) => {
	const CLOCK_SKEW_ERROR_CODES = [
		"AuthFailure",
		"InvalidSignatureException",
		"RequestExpired",
		"RequestInTheFuture",
		"RequestTimeTooSkewed",
		"SignatureDoesNotMatch"
	];
	const THROTTLING_ERROR_CODES = [
		"BandwidthLimitExceeded",
		"EC2ThrottledException",
		"LimitExceededException",
		"PriorRequestNotComplete",
		"ProvisionedThroughputExceededException",
		"RequestLimitExceeded",
		"RequestThrottled",
		"RequestThrottledException",
		"SlowDown",
		"ThrottledException",
		"Throttling",
		"ThrottlingException",
		"TooManyRequestsException",
		"TransactionInProgressException"
	];
	const TRANSIENT_ERROR_CODES = [
		"TimeoutError",
		"RequestTimeout",
		"RequestTimeoutException"
	];
	const TRANSIENT_ERROR_STATUS_CODES = [
		500,
		502,
		503,
		504
	];
	const NODEJS_TIMEOUT_ERROR_CODES = [
		"ECONNRESET",
		"ECONNREFUSED",
		"EPIPE",
		"ETIMEDOUT"
	];
	const NODEJS_NETWORK_ERROR_CODES = [
		"EHOSTUNREACH",
		"ENETUNREACH",
		"ENOTFOUND"
	];
	const isRetryableByTrait = (error$2) => error$2?.$retryable !== void 0;
	const isClockSkewError = (error$2) => CLOCK_SKEW_ERROR_CODES.includes(error$2.name);
	const isClockSkewCorrectedError = (error$2) => error$2.$metadata?.clockSkewCorrected;
	const isBrowserNetworkError = (error$2) => {
		const errorMessages = new Set([
			"Failed to fetch",
			"NetworkError when attempting to fetch resource",
			"The Internet connection appears to be offline",
			"Load failed",
			"Network request failed"
		]);
		if (!(error$2 && error$2 instanceof TypeError)) return false;
		return errorMessages.has(error$2.message);
	};
	const isThrottlingError = (error$2) => error$2.$metadata?.httpStatusCode === 429 || THROTTLING_ERROR_CODES.includes(error$2.name) || error$2.$retryable?.throttling == true;
	const isTransientError = (error$2, depth = 0) => isRetryableByTrait(error$2) || isClockSkewCorrectedError(error$2) || TRANSIENT_ERROR_CODES.includes(error$2.name) || NODEJS_TIMEOUT_ERROR_CODES.includes(error$2?.code || "") || NODEJS_NETWORK_ERROR_CODES.includes(error$2?.code || "") || TRANSIENT_ERROR_STATUS_CODES.includes(error$2.$metadata?.httpStatusCode || 0) || isBrowserNetworkError(error$2) || error$2.cause !== void 0 && depth <= 10 && isTransientError(error$2.cause, depth + 1);
	const isServerError = (error$2) => {
		if (error$2.$metadata?.httpStatusCode !== void 0) {
			const statusCode = error$2.$metadata.httpStatusCode;
			if (500 <= statusCode && statusCode <= 599 && !isTransientError(error$2)) return true;
			return false;
		}
		return false;
	};
	exports.isBrowserNetworkError = isBrowserNetworkError;
	exports.isClockSkewCorrectedError = isClockSkewCorrectedError;
	exports.isClockSkewError = isClockSkewError;
	exports.isRetryableByTrait = isRetryableByTrait;
	exports.isServerError = isServerError;
	exports.isThrottlingError = isThrottlingError;
	exports.isTransientError = isTransientError;
}));

//#endregion
//#region node_modules/@smithy/util-retry/dist-cjs/index.js
var require_dist_cjs$18 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var serviceErrorClassification$1 = require_dist_cjs$19();
	exports.RETRY_MODES = void 0;
	(function(RETRY_MODES) {
		RETRY_MODES["STANDARD"] = "standard";
		RETRY_MODES["ADAPTIVE"] = "adaptive";
	})(exports.RETRY_MODES || (exports.RETRY_MODES = {}));
	const DEFAULT_MAX_ATTEMPTS = 3;
	const DEFAULT_RETRY_MODE$3 = exports.RETRY_MODES.STANDARD;
	var DefaultRateLimiter = class DefaultRateLimiter {
		static setTimeoutFn = setTimeout;
		beta;
		minCapacity;
		minFillRate;
		scaleConstant;
		smooth;
		currentCapacity = 0;
		enabled = false;
		lastMaxRate = 0;
		measuredTxRate = 0;
		requestCount = 0;
		fillRate;
		lastThrottleTime;
		lastTimestamp = 0;
		lastTxRateBucket;
		maxCapacity;
		timeWindow = 0;
		constructor(options) {
			this.beta = options?.beta ?? .7;
			this.minCapacity = options?.minCapacity ?? 1;
			this.minFillRate = options?.minFillRate ?? .5;
			this.scaleConstant = options?.scaleConstant ?? .4;
			this.smooth = options?.smooth ?? .8;
			this.lastThrottleTime = this.getCurrentTimeInSeconds();
			this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
			this.fillRate = this.minFillRate;
			this.maxCapacity = this.minCapacity;
		}
		getCurrentTimeInSeconds() {
			return Date.now() / 1e3;
		}
		async getSendToken() {
			return this.acquireTokenBucket(1);
		}
		async acquireTokenBucket(amount) {
			if (!this.enabled) return;
			this.refillTokenBucket();
			if (amount > this.currentCapacity) {
				const delay = (amount - this.currentCapacity) / this.fillRate * 1e3;
				await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));
			}
			this.currentCapacity = this.currentCapacity - amount;
		}
		refillTokenBucket() {
			const timestamp = this.getCurrentTimeInSeconds();
			if (!this.lastTimestamp) {
				this.lastTimestamp = timestamp;
				return;
			}
			const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
			this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
			this.lastTimestamp = timestamp;
		}
		updateClientSendingRate(response) {
			let calculatedRate;
			this.updateMeasuredRate();
			if (serviceErrorClassification$1.isThrottlingError(response)) {
				const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
				this.lastMaxRate = rateToUse;
				this.calculateTimeWindow();
				this.lastThrottleTime = this.getCurrentTimeInSeconds();
				calculatedRate = this.cubicThrottle(rateToUse);
				this.enableTokenBucket();
			} else {
				this.calculateTimeWindow();
				calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
			}
			const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
			this.updateTokenBucketRate(newRate);
		}
		calculateTimeWindow() {
			this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
		}
		cubicThrottle(rateToUse) {
			return this.getPrecise(rateToUse * this.beta);
		}
		cubicSuccess(timestamp) {
			return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
		}
		enableTokenBucket() {
			this.enabled = true;
		}
		updateTokenBucketRate(newRate) {
			this.refillTokenBucket();
			this.fillRate = Math.max(newRate, this.minFillRate);
			this.maxCapacity = Math.max(newRate, this.minCapacity);
			this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
		}
		updateMeasuredRate() {
			const t$5 = this.getCurrentTimeInSeconds();
			const timeBucket = Math.floor(t$5 * 2) / 2;
			this.requestCount++;
			if (timeBucket > this.lastTxRateBucket) {
				const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
				this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
				this.requestCount = 0;
				this.lastTxRateBucket = timeBucket;
			}
		}
		getPrecise(num) {
			return parseFloat(num.toFixed(8));
		}
	};
	const DEFAULT_RETRY_DELAY_BASE = 100;
	const MAXIMUM_RETRY_DELAY = 20 * 1e3;
	const THROTTLING_RETRY_DELAY_BASE = 500;
	const INITIAL_RETRY_TOKENS = 500;
	const RETRY_COST = 5;
	const TIMEOUT_RETRY_COST = 10;
	const NO_RETRY_INCREMENT = 1;
	const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
	const REQUEST_HEADER = "amz-sdk-request";
	const getDefaultRetryBackoffStrategy = () => {
		let delayBase = DEFAULT_RETRY_DELAY_BASE;
		const computeNextBackoffDelay = (attempts) => {
			return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
		};
		const setDelayBase = (delay) => {
			delayBase = delay;
		};
		return {
			computeNextBackoffDelay,
			setDelayBase
		};
	};
	const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost }) => {
		const getRetryCount = () => retryCount;
		const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
		const getRetryCost = () => retryCost;
		return {
			getRetryCount,
			getRetryDelay,
			getRetryCost
		};
	};
	var StandardRetryStrategy$1 = class {
		maxAttempts;
		mode = exports.RETRY_MODES.STANDARD;
		capacity = INITIAL_RETRY_TOKENS;
		retryBackoffStrategy = getDefaultRetryBackoffStrategy();
		maxAttemptsProvider;
		constructor(maxAttempts) {
			this.maxAttempts = maxAttempts;
			this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
		}
		async acquireInitialRetryToken(retryTokenScope) {
			return createDefaultRetryToken({
				retryDelay: DEFAULT_RETRY_DELAY_BASE,
				retryCount: 0
			});
		}
		async refreshRetryTokenForRetry(token, errorInfo) {
			const maxAttempts = await this.getMaxAttempts();
			if (this.shouldRetry(token, errorInfo, maxAttempts)) {
				const errorType = errorInfo.errorType;
				this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
				const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
				const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
				const capacityCost = this.getCapacityCost(errorType);
				this.capacity -= capacityCost;
				return createDefaultRetryToken({
					retryDelay,
					retryCount: token.getRetryCount() + 1,
					retryCost: capacityCost
				});
			}
			throw new Error("No retry token available");
		}
		recordSuccess(token) {
			this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
		}
		getCapacity() {
			return this.capacity;
		}
		async getMaxAttempts() {
			try {
				return await this.maxAttemptsProvider();
			} catch (error$2) {
				console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
				return DEFAULT_MAX_ATTEMPTS;
			}
		}
		shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
			return tokenToRenew.getRetryCount() + 1 < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
		}
		getCapacityCost(errorType) {
			return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
		}
		isRetryableError(errorType) {
			return errorType === "THROTTLING" || errorType === "TRANSIENT";
		}
	};
	var AdaptiveRetryStrategy$1 = class {
		maxAttemptsProvider;
		rateLimiter;
		standardRetryStrategy;
		mode = exports.RETRY_MODES.ADAPTIVE;
		constructor(maxAttemptsProvider, options) {
			this.maxAttemptsProvider = maxAttemptsProvider;
			const { rateLimiter } = options ?? {};
			this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
			this.standardRetryStrategy = new StandardRetryStrategy$1(maxAttemptsProvider);
		}
		async acquireInitialRetryToken(retryTokenScope) {
			await this.rateLimiter.getSendToken();
			return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
		}
		async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
			this.rateLimiter.updateClientSendingRate(errorInfo);
			return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
		}
		recordSuccess(token) {
			this.rateLimiter.updateClientSendingRate({});
			this.standardRetryStrategy.recordSuccess(token);
		}
	};
	var ConfiguredRetryStrategy = class extends StandardRetryStrategy$1 {
		computeNextBackoffDelay;
		constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
			super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
			if (typeof computeNextBackoffDelay === "number") this.computeNextBackoffDelay = () => computeNextBackoffDelay;
			else this.computeNextBackoffDelay = computeNextBackoffDelay;
		}
		async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
			const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
			token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
			return token;
		}
	};
	exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy$1;
	exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
	exports.DEFAULT_MAX_ATTEMPTS = DEFAULT_MAX_ATTEMPTS;
	exports.DEFAULT_RETRY_DELAY_BASE = DEFAULT_RETRY_DELAY_BASE;
	exports.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE$3;
	exports.DefaultRateLimiter = DefaultRateLimiter;
	exports.INITIAL_RETRY_TOKENS = INITIAL_RETRY_TOKENS;
	exports.INVOCATION_ID_HEADER = INVOCATION_ID_HEADER;
	exports.MAXIMUM_RETRY_DELAY = MAXIMUM_RETRY_DELAY;
	exports.NO_RETRY_INCREMENT = NO_RETRY_INCREMENT;
	exports.REQUEST_HEADER = REQUEST_HEADER;
	exports.RETRY_COST = RETRY_COST;
	exports.StandardRetryStrategy = StandardRetryStrategy$1;
	exports.THROTTLING_RETRY_DELAY_BASE = THROTTLING_RETRY_DELAY_BASE;
	exports.TIMEOUT_RETRY_COST = TIMEOUT_RETRY_COST;
}));

//#endregion
//#region node_modules/@smithy/middleware-retry/dist-cjs/isStreamingPayload/isStreamingPayload.js
var require_isStreamingPayload = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isStreamingPayload = void 0;
	const stream_1 = __require("stream");
	const isStreamingPayload$1 = (request$1) => request$1?.body instanceof stream_1.Readable || typeof ReadableStream !== "undefined" && request$1?.body instanceof ReadableStream;
	exports.isStreamingPayload = isStreamingPayload$1;
}));

//#endregion
//#region node_modules/@smithy/middleware-retry/dist-cjs/index.js
var require_dist_cjs$17 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilRetry = require_dist_cjs$18();
	var protocolHttp$3 = require_dist_cjs$52();
	var serviceErrorClassification = require_dist_cjs$19();
	var uuid = require_dist_cjs$36();
	var utilMiddleware = require_dist_cjs$48();
	var smithyClient$2 = require_dist_cjs$28();
	var isStreamingPayload = require_isStreamingPayload();
	const getDefaultRetryQuota = (initialRetryTokens, options) => {
		const MAX_CAPACITY = initialRetryTokens;
		const noRetryIncrement = utilRetry.NO_RETRY_INCREMENT;
		const retryCost = utilRetry.RETRY_COST;
		const timeoutRetryCost = utilRetry.TIMEOUT_RETRY_COST;
		let availableCapacity = initialRetryTokens;
		const getCapacityAmount = (error$2) => error$2.name === "TimeoutError" ? timeoutRetryCost : retryCost;
		const hasRetryTokens = (error$2) => getCapacityAmount(error$2) <= availableCapacity;
		const retrieveRetryTokens = (error$2) => {
			if (!hasRetryTokens(error$2)) throw new Error("No retry token available");
			const capacityAmount = getCapacityAmount(error$2);
			availableCapacity -= capacityAmount;
			return capacityAmount;
		};
		const releaseRetryTokens = (capacityReleaseAmount) => {
			availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
			availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
		};
		return Object.freeze({
			hasRetryTokens,
			retrieveRetryTokens,
			releaseRetryTokens
		});
	};
	const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(utilRetry.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
	const defaultRetryDecider = (error$2) => {
		if (!error$2) return false;
		return serviceErrorClassification.isRetryableByTrait(error$2) || serviceErrorClassification.isClockSkewError(error$2) || serviceErrorClassification.isThrottlingError(error$2) || serviceErrorClassification.isTransientError(error$2);
	};
	const asSdkError = (error$2) => {
		if (error$2 instanceof Error) return error$2;
		if (error$2 instanceof Object) return Object.assign(/* @__PURE__ */ new Error(), error$2);
		if (typeof error$2 === "string") return new Error(error$2);
		return /* @__PURE__ */ new Error(`AWS SDK error wrapper for ${error$2}`);
	};
	var StandardRetryStrategy = class {
		maxAttemptsProvider;
		retryDecider;
		delayDecider;
		retryQuota;
		mode = utilRetry.RETRY_MODES.STANDARD;
		constructor(maxAttemptsProvider, options) {
			this.maxAttemptsProvider = maxAttemptsProvider;
			this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
			this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
			this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(utilRetry.INITIAL_RETRY_TOKENS);
		}
		shouldRetry(error$2, attempts, maxAttempts) {
			return attempts < maxAttempts && this.retryDecider(error$2) && this.retryQuota.hasRetryTokens(error$2);
		}
		async getMaxAttempts() {
			let maxAttempts;
			try {
				maxAttempts = await this.maxAttemptsProvider();
			} catch (error$2) {
				maxAttempts = utilRetry.DEFAULT_MAX_ATTEMPTS;
			}
			return maxAttempts;
		}
		async retry(next, args, options) {
			let retryTokenAmount;
			let attempts = 0;
			let totalDelay = 0;
			const maxAttempts = await this.getMaxAttempts();
			const { request: request$1 } = args;
			if (protocolHttp$3.HttpRequest.isInstance(request$1)) request$1.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
			while (true) try {
				if (protocolHttp$3.HttpRequest.isInstance(request$1)) request$1.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
				if (options?.beforeRequest) await options.beforeRequest();
				const { response, output } = await next(args);
				if (options?.afterRequest) options.afterRequest(response);
				this.retryQuota.releaseRetryTokens(retryTokenAmount);
				output.$metadata.attempts = attempts + 1;
				output.$metadata.totalRetryDelay = totalDelay;
				return {
					response,
					output
				};
			} catch (e$5) {
				const err = asSdkError(e$5);
				attempts++;
				if (this.shouldRetry(err, attempts, maxAttempts)) {
					retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
					const delayFromDecider = this.delayDecider(serviceErrorClassification.isThrottlingError(err) ? utilRetry.THROTTLING_RETRY_DELAY_BASE : utilRetry.DEFAULT_RETRY_DELAY_BASE, attempts);
					const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
					const delay = Math.max(delayFromResponse || 0, delayFromDecider);
					totalDelay += delay;
					await new Promise((resolve) => setTimeout(resolve, delay));
					continue;
				}
				if (!err.$metadata) err.$metadata = {};
				err.$metadata.attempts = attempts;
				err.$metadata.totalRetryDelay = totalDelay;
				throw err;
			}
		}
	};
	const getDelayFromRetryAfterHeader = (response) => {
		if (!protocolHttp$3.HttpResponse.isInstance(response)) return;
		const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
		if (!retryAfterHeaderName) return;
		const retryAfter = response.headers[retryAfterHeaderName];
		const retryAfterSeconds = Number(retryAfter);
		if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1e3;
		return new Date(retryAfter).getTime() - Date.now();
	};
	var AdaptiveRetryStrategy = class extends StandardRetryStrategy {
		rateLimiter;
		constructor(maxAttemptsProvider, options) {
			const { rateLimiter, ...superOptions } = options ?? {};
			super(maxAttemptsProvider, superOptions);
			this.rateLimiter = rateLimiter ?? new utilRetry.DefaultRateLimiter();
			this.mode = utilRetry.RETRY_MODES.ADAPTIVE;
		}
		async retry(next, args) {
			return super.retry(next, args, {
				beforeRequest: async () => {
					return this.rateLimiter.getSendToken();
				},
				afterRequest: (response) => {
					this.rateLimiter.updateClientSendingRate(response);
				}
			});
		}
	};
	const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
	const CONFIG_MAX_ATTEMPTS = "max_attempts";
	const NODE_MAX_ATTEMPT_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => {
			const value = env[ENV_MAX_ATTEMPTS];
			if (!value) return void 0;
			const maxAttempt = parseInt(value);
			if (Number.isNaN(maxAttempt)) throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
			return maxAttempt;
		},
		configFileSelector: (profile) => {
			const value = profile[CONFIG_MAX_ATTEMPTS];
			if (!value) return void 0;
			const maxAttempt = parseInt(value);
			if (Number.isNaN(maxAttempt)) throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
			return maxAttempt;
		},
		default: utilRetry.DEFAULT_MAX_ATTEMPTS
	};
	const resolveRetryConfig$3 = (input) => {
		const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
		const maxAttempts = utilMiddleware.normalizeProvider(_maxAttempts ?? utilRetry.DEFAULT_MAX_ATTEMPTS);
		return Object.assign(input, {
			maxAttempts,
			retryStrategy: async () => {
				if (retryStrategy) return retryStrategy;
				if (await utilMiddleware.normalizeProvider(_retryMode)() === utilRetry.RETRY_MODES.ADAPTIVE) return new utilRetry.AdaptiveRetryStrategy(maxAttempts);
				return new utilRetry.StandardRetryStrategy(maxAttempts);
			}
		});
	};
	const ENV_RETRY_MODE = "AWS_RETRY_MODE";
	const CONFIG_RETRY_MODE = "retry_mode";
	const NODE_RETRY_MODE_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
		configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
		default: utilRetry.DEFAULT_RETRY_MODE
	};
	const omitRetryHeadersMiddleware = () => (next) => async (args) => {
		const { request: request$1 } = args;
		if (protocolHttp$3.HttpRequest.isInstance(request$1)) {
			delete request$1.headers[utilRetry.INVOCATION_ID_HEADER];
			delete request$1.headers[utilRetry.REQUEST_HEADER];
		}
		return next(args);
	};
	const omitRetryHeadersMiddlewareOptions = {
		name: "omitRetryHeadersMiddleware",
		tags: [
			"RETRY",
			"HEADERS",
			"OMIT_RETRY_HEADERS"
		],
		relation: "before",
		toMiddleware: "awsAuthMiddleware",
		override: true
	};
	const getOmitRetryHeadersPlugin = (options) => ({ applyToStack: (clientStack) => {
		clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
	} });
	const retryMiddleware = (options) => (next, context) => async (args) => {
		let retryStrategy = await options.retryStrategy();
		const maxAttempts = await options.maxAttempts();
		if (isRetryStrategyV2(retryStrategy)) {
			retryStrategy = retryStrategy;
			let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
			let lastError = /* @__PURE__ */ new Error();
			let attempts = 0;
			let totalRetryDelay = 0;
			const { request: request$1 } = args;
			const isRequest = protocolHttp$3.HttpRequest.isInstance(request$1);
			if (isRequest) request$1.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
			while (true) try {
				if (isRequest) request$1.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
				const { response, output } = await next(args);
				retryStrategy.recordSuccess(retryToken);
				output.$metadata.attempts = attempts + 1;
				output.$metadata.totalRetryDelay = totalRetryDelay;
				return {
					response,
					output
				};
			} catch (e$5) {
				const retryErrorInfo = getRetryErrorInfo(e$5);
				lastError = asSdkError(e$5);
				if (isRequest && isStreamingPayload.isStreamingPayload(request$1)) {
					(context.logger instanceof smithyClient$2.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
					throw lastError;
				}
				try {
					retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
				} catch (refreshError) {
					if (!lastError.$metadata) lastError.$metadata = {};
					lastError.$metadata.attempts = attempts + 1;
					lastError.$metadata.totalRetryDelay = totalRetryDelay;
					throw lastError;
				}
				attempts = retryToken.getRetryCount();
				const delay = retryToken.getRetryDelay();
				totalRetryDelay += delay;
				await new Promise((resolve) => setTimeout(resolve, delay));
			}
		} else {
			retryStrategy = retryStrategy;
			if (retryStrategy?.mode) context.userAgent = [...context.userAgent || [], ["cfg/retry-mode", retryStrategy.mode]];
			return retryStrategy.retry(next, args);
		}
	};
	const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
	const getRetryErrorInfo = (error$2) => {
		const errorInfo = {
			error: error$2,
			errorType: getRetryErrorType(error$2)
		};
		const retryAfterHint = getRetryAfterHint(error$2.$response);
		if (retryAfterHint) errorInfo.retryAfterHint = retryAfterHint;
		return errorInfo;
	};
	const getRetryErrorType = (error$2) => {
		if (serviceErrorClassification.isThrottlingError(error$2)) return "THROTTLING";
		if (serviceErrorClassification.isTransientError(error$2)) return "TRANSIENT";
		if (serviceErrorClassification.isServerError(error$2)) return "SERVER_ERROR";
		return "CLIENT_ERROR";
	};
	const retryMiddlewareOptions = {
		name: "retryMiddleware",
		tags: ["RETRY"],
		step: "finalizeRequest",
		priority: "high",
		override: true
	};
	const getRetryPlugin$3 = (options) => ({ applyToStack: (clientStack) => {
		clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
	} });
	const getRetryAfterHint = (response) => {
		if (!protocolHttp$3.HttpResponse.isInstance(response)) return;
		const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
		if (!retryAfterHeaderName) return;
		const retryAfter = response.headers[retryAfterHeaderName];
		const retryAfterSeconds = Number(retryAfter);
		if (!Number.isNaN(retryAfterSeconds)) return /* @__PURE__ */ new Date(retryAfterSeconds * 1e3);
		return new Date(retryAfter);
	};
	exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
	exports.CONFIG_MAX_ATTEMPTS = CONFIG_MAX_ATTEMPTS;
	exports.CONFIG_RETRY_MODE = CONFIG_RETRY_MODE;
	exports.ENV_MAX_ATTEMPTS = ENV_MAX_ATTEMPTS;
	exports.ENV_RETRY_MODE = ENV_RETRY_MODE;
	exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS$3;
	exports.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS$3;
	exports.StandardRetryStrategy = StandardRetryStrategy;
	exports.defaultDelayDecider = defaultDelayDecider;
	exports.defaultRetryDecider = defaultRetryDecider;
	exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
	exports.getRetryAfterHint = getRetryAfterHint;
	exports.getRetryPlugin = getRetryPlugin$3;
	exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
	exports.omitRetryHeadersMiddlewareOptions = omitRetryHeadersMiddlewareOptions;
	exports.resolveRetryConfig = resolveRetryConfig$3;
	exports.retryMiddleware = retryMiddleware;
	exports.retryMiddlewareOptions = retryMiddlewareOptions;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveHttpAuthSchemeConfig = exports.defaultSecretsManagerHttpAuthSchemeProvider = exports.defaultSecretsManagerHttpAuthSchemeParametersProvider = void 0;
	const core_1$5 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const util_middleware_1$1 = require_dist_cjs$48();
	const defaultSecretsManagerHttpAuthSchemeParametersProvider = async (config, context, input) => {
		return {
			operation: (0, util_middleware_1$1.getSmithyContext)(context).operation,
			region: await (0, util_middleware_1$1.normalizeProvider)(config.region)() || (() => {
				throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
			})()
		};
	};
	exports.defaultSecretsManagerHttpAuthSchemeParametersProvider = defaultSecretsManagerHttpAuthSchemeParametersProvider;
	function createAwsAuthSigv4HttpAuthOption$4(authParameters) {
		return {
			schemeId: "aws.auth#sigv4",
			signingProperties: {
				name: "secretsmanager",
				region: authParameters.region
			},
			propertiesExtractor: (config, context) => ({ signingProperties: {
				config,
				context
			} })
		};
	}
	const defaultSecretsManagerHttpAuthSchemeProvider = (authParameters) => {
		const options = [];
		switch (authParameters.operation) {
			default: options.push(createAwsAuthSigv4HttpAuthOption$4(authParameters));
		}
		return options;
	};
	exports.defaultSecretsManagerHttpAuthSchemeProvider = defaultSecretsManagerHttpAuthSchemeProvider;
	const resolveHttpAuthSchemeConfig$4 = (config) => {
		const config_0 = (0, core_1$5.resolveAwsSdkSigV4Config)(config);
		return Object.assign(config_0, { authSchemePreference: (0, util_middleware_1$1.normalizeProvider)(config.authSchemePreference ?? []) });
	};
	exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig$4;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/package.json
var require_package$1 = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"name": "@aws-sdk/client-secrets-manager",
		"description": "AWS SDK for JavaScript Secrets Manager Client for Node.js, Browser and React Native",
		"version": "3.940.0",
		"scripts": {
			"build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			"build:cjs": "node ../../scripts/compilation/inline client-secrets-manager",
			"build:es": "tsc -p tsconfig.es.json",
			"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
			"build:types": "tsc -p tsconfig.types.json",
			"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
			"clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
			"extract:docs": "api-extractor run --local",
			"generate:client": "node ../../scripts/generate-clients/single-service --solo secrets-manager"
		},
		"main": "./dist-cjs/index.js",
		"types": "./dist-types/index.d.ts",
		"module": "./dist-es/index.js",
		"sideEffects": false,
		"dependencies": {
			"@aws-crypto/sha256-browser": "5.2.0",
			"@aws-crypto/sha256-js": "5.2.0",
			"@aws-sdk/core": "3.940.0",
			"@aws-sdk/credential-provider-node": "3.940.0",
			"@aws-sdk/middleware-host-header": "3.936.0",
			"@aws-sdk/middleware-logger": "3.936.0",
			"@aws-sdk/middleware-recursion-detection": "3.936.0",
			"@aws-sdk/middleware-user-agent": "3.940.0",
			"@aws-sdk/region-config-resolver": "3.936.0",
			"@aws-sdk/types": "3.936.0",
			"@aws-sdk/util-endpoints": "3.936.0",
			"@aws-sdk/util-user-agent-browser": "3.936.0",
			"@aws-sdk/util-user-agent-node": "3.940.0",
			"@smithy/config-resolver": "^4.4.3",
			"@smithy/core": "^3.18.5",
			"@smithy/fetch-http-handler": "^5.3.6",
			"@smithy/hash-node": "^4.2.5",
			"@smithy/invalid-dependency": "^4.2.5",
			"@smithy/middleware-content-length": "^4.2.5",
			"@smithy/middleware-endpoint": "^4.3.12",
			"@smithy/middleware-retry": "^4.4.12",
			"@smithy/middleware-serde": "^4.2.6",
			"@smithy/middleware-stack": "^4.2.5",
			"@smithy/node-config-provider": "^4.3.5",
			"@smithy/node-http-handler": "^4.4.5",
			"@smithy/protocol-http": "^5.3.5",
			"@smithy/smithy-client": "^4.9.8",
			"@smithy/types": "^4.9.0",
			"@smithy/url-parser": "^4.2.5",
			"@smithy/util-base64": "^4.3.0",
			"@smithy/util-body-length-browser": "^4.2.0",
			"@smithy/util-body-length-node": "^4.2.1",
			"@smithy/util-defaults-mode-browser": "^4.3.11",
			"@smithy/util-defaults-mode-node": "^4.2.14",
			"@smithy/util-endpoints": "^3.2.5",
			"@smithy/util-middleware": "^4.2.5",
			"@smithy/util-retry": "^4.2.5",
			"@smithy/util-utf8": "^4.2.0",
			"tslib": "^2.6.2"
		},
		"devDependencies": {
			"@tsconfig/node18": "18.2.4",
			"@types/node": "^18.19.69",
			"concurrently": "7.0.0",
			"downlevel-dts": "0.10.1",
			"rimraf": "3.0.2",
			"typescript": "~5.8.3"
		},
		"engines": { "node": ">=18.0.0" },
		"typesVersions": { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
		"files": ["dist-*/**"],
		"author": {
			"name": "AWS SDK for JavaScript Team",
			"url": "https://aws.amazon.com/javascript/"
		},
		"license": "Apache-2.0",
		"browser": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
		"react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" },
		"homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-secrets-manager",
		"repository": {
			"type": "git",
			"url": "https://github.com/aws/aws-sdk-js-v3.git",
			"directory": "clients/client-secrets-manager"
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-env/dist-cjs/index.js
var require_dist_cjs$16 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var client$5 = (init_client(), __toCommonJS(client_exports));
	var propertyProvider$8 = require_dist_cjs$31();
	const ENV_KEY = "AWS_ACCESS_KEY_ID";
	const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
	const ENV_SESSION = "AWS_SESSION_TOKEN";
	const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
	const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
	const ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
	const fromEnv = (init) => async () => {
		init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
		const accessKeyId = process.env[ENV_KEY];
		const secretAccessKey = process.env[ENV_SECRET];
		const sessionToken = process.env[ENV_SESSION];
		const expiry = process.env[ENV_EXPIRATION];
		const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
		const accountId = process.env[ENV_ACCOUNT_ID];
		if (accessKeyId && secretAccessKey) {
			const credentials = {
				accessKeyId,
				secretAccessKey,
				...sessionToken && { sessionToken },
				...expiry && { expiration: new Date(expiry) },
				...credentialScope && { credentialScope },
				...accountId && { accountId }
			};
			client$5.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
			return credentials;
		}
		throw new propertyProvider$8.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
	};
	exports.ENV_ACCOUNT_ID = ENV_ACCOUNT_ID;
	exports.ENV_CREDENTIAL_SCOPE = ENV_CREDENTIAL_SCOPE;
	exports.ENV_EXPIRATION = ENV_EXPIRATION;
	exports.ENV_KEY = ENV_KEY;
	exports.ENV_SECRET = ENV_SECRET;
	exports.ENV_SESSION = ENV_SESSION;
	exports.fromEnv = fromEnv;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-node/dist-cjs/index.js
var require_dist_cjs$15 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var credentialProviderEnv = require_dist_cjs$16();
	var propertyProvider$7 = require_dist_cjs$31();
	var sharedIniFileLoader$5 = require_dist_cjs$22();
	const ENV_IMDS_DISABLED$1 = "AWS_EC2_METADATA_DISABLED";
	const remoteProvider = async (init) => {
		const { ENV_CMDS_FULL_URI: ENV_CMDS_FULL_URI$1, ENV_CMDS_RELATIVE_URI: ENV_CMDS_RELATIVE_URI$1, fromContainerMetadata: fromContainerMetadata$1, fromInstanceMetadata: fromInstanceMetadata$1 } = await import("./dist-cjs-C7rSq7e4.js").then(__toDynamicImportESM());
		if (process.env[ENV_CMDS_RELATIVE_URI$1] || process.env[ENV_CMDS_FULL_URI$1]) {
			init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
			const { fromHttp: fromHttp$1 } = await import("./dist-cjs-CAYs523S.js").then(__toDynamicImportESM());
			return propertyProvider$7.chain(fromHttp$1(init), fromContainerMetadata$1(init));
		}
		if (process.env[ENV_IMDS_DISABLED$1] && process.env[ENV_IMDS_DISABLED$1] !== "false") return async () => {
			throw new propertyProvider$7.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
		};
		init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
		return fromInstanceMetadata$1(init);
	};
	function memoizeChain(providers, treatAsExpired) {
		const chain$1 = internalCreateChain(providers);
		let activeLock;
		let passiveLock;
		let credentials;
		const provider = async (options) => {
			if (options?.forceRefresh) return await chain$1(options);
			if (credentials?.expiration) {
				if (credentials?.expiration?.getTime() < Date.now()) credentials = void 0;
			}
			if (activeLock) await activeLock;
			else if (!credentials || treatAsExpired?.(credentials)) if (credentials) {
				if (!passiveLock) passiveLock = chain$1(options).then((c$5) => {
					credentials = c$5;
					passiveLock = void 0;
				});
			} else {
				activeLock = chain$1(options).then((c$5) => {
					credentials = c$5;
					activeLock = void 0;
				});
				return provider(options);
			}
			return credentials;
		};
		return provider;
	}
	const internalCreateChain = (providers) => async (awsIdentityProperties) => {
		let lastProviderError;
		for (const provider of providers) try {
			return await provider(awsIdentityProperties);
		} catch (err) {
			lastProviderError = err;
			if (err?.tryNextLink) continue;
			throw err;
		}
		throw lastProviderError;
	};
	let multipleCredentialSourceWarningEmitted = false;
	const defaultProvider = (init = {}) => memoizeChain([
		async () => {
			if (init.profile ?? process.env[sharedIniFileLoader$5.ENV_PROFILE]) {
				if (process.env[credentialProviderEnv.ENV_KEY] && process.env[credentialProviderEnv.ENV_SECRET]) {
					if (!multipleCredentialSourceWarningEmitted) {
						(init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger" ? init.logger.warn.bind(init.logger) : console.warn)(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
						multipleCredentialSourceWarningEmitted = true;
					}
				}
				throw new propertyProvider$7.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
					logger: init.logger,
					tryNextLink: true
				});
			}
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
			return credentialProviderEnv.fromEnv(init)();
		},
		async (awsIdentityProperties) => {
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
			const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
			if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) throw new propertyProvider$7.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
			const { fromSSO: fromSSO$1 } = await import("./dist-cjs-B-aR1-8U.js").then(__toDynamicImportESM());
			return fromSSO$1(init)(awsIdentityProperties);
		},
		async (awsIdentityProperties) => {
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
			const { fromIni: fromIni$1 } = await import("./dist-cjs-D1OAWGFD.js").then(__toDynamicImportESM());
			return fromIni$1(init)(awsIdentityProperties);
		},
		async (awsIdentityProperties) => {
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
			const { fromProcess: fromProcess$1 } = await import("./dist-cjs-DfSXziVD.js").then(__toDynamicImportESM());
			return fromProcess$1(init)(awsIdentityProperties);
		},
		async (awsIdentityProperties) => {
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
			const { fromTokenFile: fromTokenFile$2 } = await import("./dist-cjs-MwJhby-q.js").then(__toDynamicImportESM());
			return fromTokenFile$2(init)(awsIdentityProperties);
		},
		async () => {
			init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
			return (await remoteProvider(init))();
		},
		async () => {
			throw new propertyProvider$7.CredentialsProviderError("Could not load credentials from any providers", {
				tryNextLink: false,
				logger: init.logger
			});
		}
	], credentialsTreatedAsExpired);
	const credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== void 0;
	const credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== void 0 && credentials.expiration.getTime() - Date.now() < 3e5;
	exports.credentialsTreatedAsExpired = credentialsTreatedAsExpired;
	exports.credentialsWillNeedRefresh = credentialsWillNeedRefresh;
	exports.defaultProvider = defaultProvider;
}));

//#endregion
//#region node_modules/@aws-sdk/util-user-agent-node/dist-cjs/index.js
var require_dist_cjs$14 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var os = __require("os");
	var process$1 = __require("process");
	var middlewareUserAgent$2 = require_dist_cjs$26();
	const crtAvailability = { isCrtAvailable: false };
	const isCrtAvailable = () => {
		if (crtAvailability.isCrtAvailable) return ["md/crt-avail"];
		return null;
	};
	const createDefaultUserAgentProvider$3 = ({ serviceId, clientVersion }) => {
		return async (config) => {
			const sections = [
				["aws-sdk-js", clientVersion],
				["ua", "2.1"],
				[`os/${os.platform()}`, os.release()],
				["lang/js"],
				["md/nodejs", `${process$1.versions.node}`]
			];
			const crtAvailable = isCrtAvailable();
			if (crtAvailable) sections.push(crtAvailable);
			if (serviceId) sections.push([`api/${serviceId}`, clientVersion]);
			if (process$1.env.AWS_EXECUTION_ENV) sections.push([`exec-env/${process$1.env.AWS_EXECUTION_ENV}`]);
			const appId = await config?.userAgentAppId?.();
			return appId ? [...sections, [`app/${appId}`]] : [...sections];
		};
	};
	const defaultUserAgent = createDefaultUserAgentProvider$3;
	const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
	const UA_APP_ID_INI_NAME = "sdk_ua_app_id";
	const UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
	const NODE_APP_ID_CONFIG_OPTIONS$3 = {
		environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
		configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
		default: middlewareUserAgent$2.DEFAULT_UA_APP_ID
	};
	exports.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS$3;
	exports.UA_APP_ID_ENV_NAME = UA_APP_ID_ENV_NAME;
	exports.UA_APP_ID_INI_NAME = UA_APP_ID_INI_NAME;
	exports.createDefaultUserAgentProvider = createDefaultUserAgentProvider$3;
	exports.crtAvailability = crtAvailability;
	exports.defaultUserAgent = defaultUserAgent;
}));

//#endregion
//#region node_modules/@smithy/hash-node/dist-cjs/index.js
var require_dist_cjs$13 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var utilBufferFrom = require_dist_cjs$45();
	var utilUtf8 = require_dist_cjs$44();
	var buffer$1 = __require("buffer");
	var crypto$1 = __require("crypto");
	var Hash$3 = class {
		algorithmIdentifier;
		secret;
		hash;
		constructor(algorithmIdentifier, secret) {
			this.algorithmIdentifier = algorithmIdentifier;
			this.secret = secret;
			this.reset();
		}
		update(toHash, encoding) {
			this.hash.update(utilUtf8.toUint8Array(castSourceData(toHash, encoding)));
		}
		digest() {
			return Promise.resolve(this.hash.digest());
		}
		reset() {
			this.hash = this.secret ? crypto$1.createHmac(this.algorithmIdentifier, castSourceData(this.secret)) : crypto$1.createHash(this.algorithmIdentifier);
		}
	};
	function castSourceData(toCast, encoding) {
		if (buffer$1.Buffer.isBuffer(toCast)) return toCast;
		if (typeof toCast === "string") return utilBufferFrom.fromString(toCast, encoding);
		if (ArrayBuffer.isView(toCast)) return utilBufferFrom.fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
		return utilBufferFrom.fromArrayBuffer(toCast);
	}
	exports.Hash = Hash$3;
}));

//#endregion
//#region node_modules/@smithy/util-body-length-node/dist-cjs/index.js
var require_dist_cjs$12 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var node_fs$1 = __require("node:fs");
	const calculateBodyLength$3 = (body) => {
		if (!body) return 0;
		if (typeof body === "string") return Buffer.byteLength(body);
		else if (typeof body.byteLength === "number") return body.byteLength;
		else if (typeof body.size === "number") return body.size;
		else if (typeof body.start === "number" && typeof body.end === "number") return body.end + 1 - body.start;
		else if (body instanceof node_fs$1.ReadStream) {
			if (body.path != null) return node_fs$1.lstatSync(body.path).size;
			else if (typeof body.fd === "number") return node_fs$1.fstatSync(body.fd).size;
		}
		throw new Error(`Body Length computation failed for ${body}`);
	};
	exports.calculateBodyLength = calculateBodyLength$3;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/ruleset.js
var require_ruleset$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ruleSet = void 0;
	const y$1 = "required", z$1 = "fn", A$1 = "argv", B$1 = "ref", C$1 = "properties", D$1 = "headers";
	const a$4 = true, b$4 = "isSet", c$4 = "booleanEquals", d$4 = "error", e$4 = "endpoint", f$4 = "tree", g$4 = "PartitionResult", h$4 = "stringEquals", i$4 = {
		[y$1]: false,
		"type": "string"
	}, j$4 = {
		[y$1]: true,
		"default": false,
		"type": "boolean"
	}, k$4 = { [B$1]: "Endpoint" }, l$4 = {
		[z$1]: c$4,
		[A$1]: [{ [B$1]: "UseFIPS" }, true]
	}, m$4 = {
		[z$1]: c$4,
		[A$1]: [{ [B$1]: "UseDualStack" }, true]
	}, n$4 = {}, o$4 = {
		[z$1]: "getAttr",
		[A$1]: [{ [B$1]: g$4 }, "supportsFIPS"]
	}, p$4 = {
		[z$1]: c$4,
		[A$1]: [true, {
			[z$1]: "getAttr",
			[A$1]: [{ [B$1]: g$4 }, "supportsDualStack"]
		}]
	}, q$4 = {
		[z$1]: "getAttr",
		[A$1]: [{ [B$1]: g$4 }, "name"]
	}, r$4 = {
		"url": "https://secretsmanager-fips.{Region}.amazonaws.com",
		[C$1]: {},
		[D$1]: {}
	}, s$4 = {
		"url": "https://secretsmanager.{Region}.amazonaws.com",
		[C$1]: {},
		[D$1]: {}
	}, t$4 = [l$4], u$4 = [m$4], v$4 = [{ [B$1]: "Region" }], w$4 = [{
		[z$1]: h$4,
		[A$1]: ["aws", q$4]
	}], x$4 = [{
		[z$1]: h$4,
		[A$1]: ["aws-us-gov", q$4]
	}];
	const _data$4 = {
		version: "1.0",
		parameters: {
			Region: i$4,
			UseDualStack: j$4,
			UseFIPS: j$4,
			Endpoint: i$4
		},
		rules: [
			{
				conditions: [{
					[z$1]: b$4,
					[A$1]: [k$4]
				}],
				rules: [
					{
						conditions: t$4,
						error: "Invalid Configuration: FIPS and custom endpoint are not supported",
						type: d$4
					},
					{
						conditions: u$4,
						error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
						type: d$4
					},
					{
						endpoint: {
							url: k$4,
							[C$1]: n$4,
							[D$1]: n$4
						},
						type: e$4
					}
				],
				type: f$4
			},
			{
				conditions: [{
					[z$1]: b$4,
					[A$1]: v$4
				}],
				rules: [{
					conditions: [{
						[z$1]: "aws.partition",
						[A$1]: v$4,
						assign: g$4
					}],
					rules: [
						{
							conditions: [l$4, m$4],
							rules: [{
								conditions: [{
									[z$1]: c$4,
									[A$1]: [a$4, o$4]
								}, p$4],
								rules: [
									{
										conditions: w$4,
										endpoint: r$4,
										type: e$4
									},
									{
										conditions: x$4,
										endpoint: r$4,
										type: e$4
									},
									{
										endpoint: {
											url: "https://secretsmanager-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
											[C$1]: n$4,
											[D$1]: n$4
										},
										type: e$4
									}
								],
								type: f$4
							}, {
								error: "FIPS and DualStack are enabled, but this partition does not support one or both",
								type: d$4
							}],
							type: f$4
						},
						{
							conditions: t$4,
							rules: [{
								conditions: [{
									[z$1]: c$4,
									[A$1]: [o$4, a$4]
								}],
								rules: [{
									endpoint: {
										url: "https://secretsmanager-fips.{Region}.{PartitionResult#dnsSuffix}",
										[C$1]: n$4,
										[D$1]: n$4
									},
									type: e$4
								}],
								type: f$4
							}, {
								error: "FIPS is enabled but this partition does not support FIPS",
								type: d$4
							}],
							type: f$4
						},
						{
							conditions: u$4,
							rules: [{
								conditions: [p$4],
								rules: [
									{
										conditions: w$4,
										endpoint: s$4,
										type: e$4
									},
									{
										conditions: [{
											[z$1]: h$4,
											[A$1]: ["aws-cn", q$4]
										}],
										endpoint: {
											url: "https://secretsmanager.{Region}.amazonaws.com.cn",
											[C$1]: n$4,
											[D$1]: n$4
										},
										type: e$4
									},
									{
										conditions: x$4,
										endpoint: s$4,
										type: e$4
									},
									{
										endpoint: {
											url: "https://secretsmanager.{Region}.{PartitionResult#dualStackDnsSuffix}",
											[C$1]: n$4,
											[D$1]: n$4
										},
										type: e$4
									}
								],
								type: f$4
							}, {
								error: "DualStack is enabled but this partition does not support DualStack",
								type: d$4
							}],
							type: f$4
						},
						{
							endpoint: {
								url: "https://secretsmanager.{Region}.{PartitionResult#dnsSuffix}",
								[C$1]: n$4,
								[D$1]: n$4
							},
							type: e$4
						}
					],
					type: f$4
				}],
				type: f$4
			},
			{
				error: "Invalid Configuration: Missing Region",
				type: d$4
			}
		]
	};
	exports.ruleSet = _data$4;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultEndpointResolver = void 0;
	const util_endpoints_1$1 = require_dist_cjs$32();
	const util_endpoints_2$1 = require_dist_cjs$35();
	const ruleset_1$1 = require_ruleset$1();
	const cache$4 = new util_endpoints_2$1.EndpointCache({
		size: 50,
		params: [
			"Endpoint",
			"Region",
			"UseDualStack",
			"UseFIPS"
		]
	});
	const defaultEndpointResolver$4 = (endpointParams, context = {}) => {
		return cache$4.get(endpointParams, () => (0, util_endpoints_2$1.resolveEndpoint)(ruleset_1$1.ruleSet, {
			endpointParams,
			logger: context.logger
		}));
	};
	exports.defaultEndpointResolver = defaultEndpointResolver$4;
	util_endpoints_2$1.customEndpointFunctions.aws = util_endpoints_1$1.awsEndpointFunctions;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRuntimeConfig = void 0;
	const core_1$4 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const protocols_1$1 = (init_protocols(), __toCommonJS(protocols_exports));
	const smithy_client_1$4 = require_dist_cjs$28();
	const url_parser_1$1 = require_dist_cjs$33();
	const util_base64_1$1 = require_dist_cjs$43();
	const util_utf8_1$1 = require_dist_cjs$44();
	const httpAuthSchemeProvider_1$1 = require_httpAuthSchemeProvider$1();
	const endpointResolver_1$1 = require_endpointResolver$1();
	const getRuntimeConfig$9 = (config) => {
		return {
			apiVersion: "2017-10-17",
			base64Decoder: config?.base64Decoder ?? util_base64_1$1.fromBase64,
			base64Encoder: config?.base64Encoder ?? util_base64_1$1.toBase64,
			disableHostPrefix: config?.disableHostPrefix ?? false,
			endpointProvider: config?.endpointProvider ?? endpointResolver_1$1.defaultEndpointResolver,
			extensions: config?.extensions ?? [],
			httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1$1.defaultSecretsManagerHttpAuthSchemeProvider,
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
				signer: new core_1$4.AwsSdkSigV4Signer()
			}],
			logger: config?.logger ?? new smithy_client_1$4.NoOpLogger(),
			protocol: config?.protocol ?? new protocols_1$1.AwsJson1_1Protocol({
				defaultNamespace: "com.amazonaws.secretsmanager",
				serviceTarget: "secretsmanager",
				awsQueryCompatible: false
			}),
			serviceId: config?.serviceId ?? "Secrets Manager",
			urlParser: config?.urlParser ?? url_parser_1$1.parseUrl,
			utf8Decoder: config?.utf8Decoder ?? util_utf8_1$1.fromUtf8,
			utf8Encoder: config?.utf8Encoder ?? util_utf8_1$1.toUtf8
		};
	};
	exports.getRuntimeConfig = getRuntimeConfig$9;
}));

//#endregion
//#region node_modules/@smithy/util-defaults-mode-node/dist-cjs/index.js
var require_dist_cjs$11 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var configResolver$3 = require_dist_cjs$24();
	var nodeConfigProvider$1 = require_dist_cjs$21();
	var propertyProvider$6 = require_dist_cjs$31();
	const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
	const AWS_REGION_ENV = "AWS_REGION";
	const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
	const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
	const DEFAULTS_MODE_OPTIONS = [
		"in-region",
		"cross-region",
		"mobile",
		"standard",
		"legacy"
	];
	const IMDS_REGION_PATH = "/latest/meta-data/placement/region";
	const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
	const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
	const NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
		environmentVariableSelector: (env) => {
			return env[AWS_DEFAULTS_MODE_ENV];
		},
		configFileSelector: (profile) => {
			return profile[AWS_DEFAULTS_MODE_CONFIG];
		},
		default: "legacy"
	};
	const resolveDefaultsModeConfig$3 = ({ region = nodeConfigProvider$1.loadConfig(configResolver$3.NODE_REGION_CONFIG_OPTIONS), defaultsMode = nodeConfigProvider$1.loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {}) => propertyProvider$6.memoize(async () => {
		const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
		switch (mode?.toLowerCase()) {
			case "auto": return resolveNodeDefaultsModeAuto(region);
			case "in-region":
			case "cross-region":
			case "mobile":
			case "standard":
			case "legacy": return Promise.resolve(mode?.toLocaleLowerCase());
			case void 0: return Promise.resolve("legacy");
			default: throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
		}
	});
	const resolveNodeDefaultsModeAuto = async (clientRegion) => {
		if (clientRegion) {
			const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
			const inferredRegion = await inferPhysicalRegion();
			if (!inferredRegion) return "standard";
			if (resolvedRegion === inferredRegion) return "in-region";
			else return "cross-region";
		}
		return "standard";
	};
	const inferPhysicalRegion = async () => {
		if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
		if (!process.env[ENV_IMDS_DISABLED]) try {
			const { getInstanceMetadataEndpoint: getInstanceMetadataEndpoint$1, httpRequest: httpRequest$1 } = await import("./dist-cjs-C7rSq7e4.js").then(__toDynamicImportESM());
			return (await httpRequest$1({
				...await getInstanceMetadataEndpoint$1(),
				path: IMDS_REGION_PATH
			})).toString();
		} catch (e$5) {}
	};
	exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig$3;
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/runtimeConfig.js
var require_runtimeConfig$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRuntimeConfig = void 0;
	const package_json_1$1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault(require_package$1());
	const core_1$3 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const credential_provider_node_1 = require_dist_cjs$15();
	const util_user_agent_node_1$1 = require_dist_cjs$14();
	const config_resolver_1$2 = require_dist_cjs$24();
	const hash_node_1$1 = require_dist_cjs$13();
	const middleware_retry_1$1 = require_dist_cjs$17();
	const node_config_provider_1$2 = require_dist_cjs$21();
	const node_http_handler_1$2 = require_dist_cjs$40();
	const util_body_length_node_1$1 = require_dist_cjs$12();
	const util_retry_1$1 = require_dist_cjs$18();
	const runtimeConfig_shared_1$1 = require_runtimeConfig_shared$1();
	const smithy_client_1$3 = require_dist_cjs$28();
	const util_defaults_mode_node_1$1 = require_dist_cjs$11();
	const smithy_client_2$1 = require_dist_cjs$28();
	const getRuntimeConfig$8 = (config) => {
		(0, smithy_client_2$1.emitWarningIfUnsupportedVersion)(process.version);
		const defaultsMode = (0, util_defaults_mode_node_1$1.resolveDefaultsModeConfig)(config);
		const defaultConfigProvider = () => defaultsMode().then(smithy_client_1$3.loadConfigsForDefaultMode);
		const clientSharedValues = (0, runtimeConfig_shared_1$1.getRuntimeConfig)(config);
		(0, core_1$3.emitWarningIfUnsupportedVersion)(process.version);
		const loaderConfig = {
			profile: config?.profile,
			logger: clientSharedValues.logger
		};
		return {
			...clientSharedValues,
			...config,
			runtime: "node",
			defaultsMode,
			authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1$2.loadConfig)(core_1$3.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
			bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1$1.calculateBodyLength,
			credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_1.defaultProvider,
			defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1$1.createDefaultUserAgentProvider)({
				serviceId: clientSharedValues.serviceId,
				clientVersion: package_json_1$1.default.version
			}),
			maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1$2.loadConfig)(middleware_retry_1$1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
			region: config?.region ?? (0, node_config_provider_1$2.loadConfig)(config_resolver_1$2.NODE_REGION_CONFIG_OPTIONS, {
				...config_resolver_1$2.NODE_REGION_CONFIG_FILE_OPTIONS,
				...loaderConfig
			}),
			requestHandler: node_http_handler_1$2.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
			retryMode: config?.retryMode ?? (0, node_config_provider_1$2.loadConfig)({
				...middleware_retry_1$1.NODE_RETRY_MODE_CONFIG_OPTIONS,
				default: async () => (await defaultConfigProvider()).retryMode || util_retry_1$1.DEFAULT_RETRY_MODE
			}, config),
			sha256: config?.sha256 ?? hash_node_1$1.Hash.bind(null, "sha256"),
			streamCollector: config?.streamCollector ?? node_http_handler_1$2.streamCollector,
			useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1$2.loadConfig)(config_resolver_1$2.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1$2.loadConfig)(config_resolver_1$2.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1$2.loadConfig)(util_user_agent_node_1$1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
		};
	};
	exports.getRuntimeConfig = getRuntimeConfig$8;
}));

//#endregion
//#region node_modules/@aws-sdk/region-config-resolver/dist-cjs/regionConfig/stsRegionDefaultResolver.js
var require_stsRegionDefaultResolver = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.warning = void 0;
	exports.stsRegionDefaultResolver = stsRegionDefaultResolver$2;
	const config_resolver_1$1 = require_dist_cjs$24();
	const node_config_provider_1$1 = require_dist_cjs$21();
	function stsRegionDefaultResolver$2(loaderConfig = {}) {
		return (0, node_config_provider_1$1.loadConfig)({
			...config_resolver_1$1.NODE_REGION_CONFIG_OPTIONS,
			async default() {
				if (!exports.warning.silence) console.warn("@aws-sdk - WARN - default STS region of us-east-1 used. See @aws-sdk/credential-providers README and set a region explicitly.");
				return "us-east-1";
			}
		}, {
			...config_resolver_1$1.NODE_REGION_CONFIG_FILE_OPTIONS,
			...loaderConfig
		});
	}
	exports.warning = { silence: false };
}));

//#endregion
//#region node_modules/@aws-sdk/region-config-resolver/dist-cjs/index.js
var require_dist_cjs$10 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var configResolver$2 = require_dist_cjs$24();
	var stsRegionDefaultResolver$1 = require_stsRegionDefaultResolver();
	const getAwsRegionExtensionConfiguration$3 = (runtimeConfig$2) => {
		return {
			setRegion(region) {
				runtimeConfig$2.region = region;
			},
			region() {
				return runtimeConfig$2.region;
			}
		};
	};
	const resolveAwsRegionExtensionConfiguration$3 = (awsRegionExtensionConfiguration) => {
		return { region: awsRegionExtensionConfiguration.region() };
	};
	Object.defineProperty(exports, "NODE_REGION_CONFIG_FILE_OPTIONS", {
		enumerable: true,
		get: function() {
			return configResolver$2.NODE_REGION_CONFIG_FILE_OPTIONS;
		}
	});
	Object.defineProperty(exports, "NODE_REGION_CONFIG_OPTIONS", {
		enumerable: true,
		get: function() {
			return configResolver$2.NODE_REGION_CONFIG_OPTIONS;
		}
	});
	Object.defineProperty(exports, "REGION_ENV_NAME", {
		enumerable: true,
		get: function() {
			return configResolver$2.REGION_ENV_NAME;
		}
	});
	Object.defineProperty(exports, "REGION_INI_NAME", {
		enumerable: true,
		get: function() {
			return configResolver$2.REGION_INI_NAME;
		}
	});
	Object.defineProperty(exports, "resolveRegionConfig", {
		enumerable: true,
		get: function() {
			return configResolver$2.resolveRegionConfig;
		}
	});
	exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration$3;
	exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration$3;
	Object.keys(stsRegionDefaultResolver$1).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return stsRegionDefaultResolver$1[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@aws-sdk/client-secrets-manager/dist-cjs/index.js
var require_dist_cjs$9 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var middlewareHostHeader$1 = require_dist_cjs$51();
	var middlewareLogger$1 = require_dist_cjs$50();
	var middlewareRecursionDetection$1 = require_dist_cjs$49();
	var middlewareUserAgent$1 = require_dist_cjs$26();
	var configResolver$1 = require_dist_cjs$24();
	var core$1 = (init_dist_es$1(), __toCommonJS(dist_es_exports$1));
	var schema$1 = (init_schema(), __toCommonJS(schema_exports));
	var middlewareContentLength$1 = require_dist_cjs$23();
	var middlewareEndpoint$1 = require_dist_cjs$20();
	var middlewareRetry$1 = require_dist_cjs$17();
	var smithyClient$1 = require_dist_cjs$28();
	var httpAuthSchemeProvider$1 = require_httpAuthSchemeProvider$1();
	var runtimeConfig$1 = require_runtimeConfig$1();
	var regionConfigResolver$1 = require_dist_cjs$10();
	var protocolHttp$2 = require_dist_cjs$52();
	const resolveClientEndpointParameters$4 = (options) => {
		return Object.assign(options, {
			useDualstackEndpoint: options.useDualstackEndpoint ?? false,
			useFipsEndpoint: options.useFipsEndpoint ?? false,
			defaultSigningName: "secretsmanager"
		});
	};
	const commonParams$4 = {
		UseFIPS: {
			type: "builtInParams",
			name: "useFipsEndpoint"
		},
		Endpoint: {
			type: "builtInParams",
			name: "endpoint"
		},
		Region: {
			type: "builtInParams",
			name: "region"
		},
		UseDualStack: {
			type: "builtInParams",
			name: "useDualstackEndpoint"
		}
	};
	const getHttpAuthExtensionConfiguration$4 = (runtimeConfig$2) => {
		const _httpAuthSchemes = runtimeConfig$2.httpAuthSchemes;
		let _httpAuthSchemeProvider = runtimeConfig$2.httpAuthSchemeProvider;
		let _credentials = runtimeConfig$2.credentials;
		return {
			setHttpAuthScheme(httpAuthScheme) {
				const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
				if (index === -1) _httpAuthSchemes.push(httpAuthScheme);
				else _httpAuthSchemes.splice(index, 1, httpAuthScheme);
			},
			httpAuthSchemes() {
				return _httpAuthSchemes;
			},
			setHttpAuthSchemeProvider(httpAuthSchemeProvider$2) {
				_httpAuthSchemeProvider = httpAuthSchemeProvider$2;
			},
			httpAuthSchemeProvider() {
				return _httpAuthSchemeProvider;
			},
			setCredentials(credentials) {
				_credentials = credentials;
			},
			credentials() {
				return _credentials;
			}
		};
	};
	const resolveHttpAuthRuntimeConfig$4 = (config) => {
		return {
			httpAuthSchemes: config.httpAuthSchemes(),
			httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
			credentials: config.credentials()
		};
	};
	const resolveRuntimeExtensions$4 = (runtimeConfig$2, extensions) => {
		const extensionConfiguration = Object.assign(regionConfigResolver$1.getAwsRegionExtensionConfiguration(runtimeConfig$2), smithyClient$1.getDefaultExtensionConfiguration(runtimeConfig$2), protocolHttp$2.getHttpHandlerExtensionConfiguration(runtimeConfig$2), getHttpAuthExtensionConfiguration$4(runtimeConfig$2));
		extensions.forEach((extension) => extension.configure(extensionConfiguration));
		return Object.assign(runtimeConfig$2, regionConfigResolver$1.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient$1.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp$2.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig$4(extensionConfiguration));
	};
	var SecretsManagerClient = class extends smithyClient$1.Client {
		config;
		constructor(...[configuration]) {
			const _config_0 = runtimeConfig$1.getRuntimeConfig(configuration || {});
			super(_config_0);
			this.initConfig = _config_0;
			const _config_1 = resolveClientEndpointParameters$4(_config_0);
			const _config_2 = middlewareUserAgent$1.resolveUserAgentConfig(_config_1);
			const _config_3 = middlewareRetry$1.resolveRetryConfig(_config_2);
			const _config_4 = configResolver$1.resolveRegionConfig(_config_3);
			const _config_5 = middlewareHostHeader$1.resolveHostHeaderConfig(_config_4);
			const _config_6 = middlewareEndpoint$1.resolveEndpointConfig(_config_5);
			this.config = resolveRuntimeExtensions$4(httpAuthSchemeProvider$1.resolveHttpAuthSchemeConfig(_config_6), configuration?.extensions || []);
			this.middlewareStack.use(schema$1.getSchemaSerdePlugin(this.config));
			this.middlewareStack.use(middlewareUserAgent$1.getUserAgentPlugin(this.config));
			this.middlewareStack.use(middlewareRetry$1.getRetryPlugin(this.config));
			this.middlewareStack.use(middlewareContentLength$1.getContentLengthPlugin(this.config));
			this.middlewareStack.use(middlewareHostHeader$1.getHostHeaderPlugin(this.config));
			this.middlewareStack.use(middlewareLogger$1.getLoggerPlugin(this.config));
			this.middlewareStack.use(middlewareRecursionDetection$1.getRecursionDetectionPlugin(this.config));
			this.middlewareStack.use(core$1.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
				httpAuthSchemeParametersProvider: httpAuthSchemeProvider$1.defaultSecretsManagerHttpAuthSchemeParametersProvider,
				identityProviderConfigProvider: async (config) => new core$1.DefaultIdentityProviderConfig({ "aws.auth#sigv4": config.credentials })
			}));
			this.middlewareStack.use(core$1.getHttpSigningPlugin(this.config));
		}
		destroy() {
			super.destroy();
		}
	};
	let SecretsManagerServiceException$1 = class SecretsManagerServiceException$2 extends smithyClient$1.ServiceException {
		constructor(options) {
			super(options);
			Object.setPrototypeOf(this, SecretsManagerServiceException$2.prototype);
		}
	};
	let DecryptionFailure$1 = class DecryptionFailure$2 extends SecretsManagerServiceException$1 {
		name = "DecryptionFailure";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "DecryptionFailure",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, DecryptionFailure$2.prototype);
			this.Message = opts.Message;
		}
	};
	let InternalServiceError$1 = class InternalServiceError$2 extends SecretsManagerServiceException$1 {
		name = "InternalServiceError";
		$fault = "server";
		Message;
		constructor(opts) {
			super({
				name: "InternalServiceError",
				$fault: "server",
				...opts
			});
			Object.setPrototypeOf(this, InternalServiceError$2.prototype);
			this.Message = opts.Message;
		}
	};
	let InvalidNextTokenException$1 = class InvalidNextTokenException$2 extends SecretsManagerServiceException$1 {
		name = "InvalidNextTokenException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "InvalidNextTokenException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidNextTokenException$2.prototype);
			this.Message = opts.Message;
		}
	};
	let InvalidParameterException$1 = class InvalidParameterException$2 extends SecretsManagerServiceException$1 {
		name = "InvalidParameterException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "InvalidParameterException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidParameterException$2.prototype);
			this.Message = opts.Message;
		}
	};
	let InvalidRequestException$1$2 = class InvalidRequestException$4 extends SecretsManagerServiceException$1 {
		name = "InvalidRequestException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "InvalidRequestException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidRequestException$4.prototype);
			this.Message = opts.Message;
		}
	};
	let ResourceNotFoundException$1$1 = class ResourceNotFoundException$3 extends SecretsManagerServiceException$1 {
		name = "ResourceNotFoundException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "ResourceNotFoundException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ResourceNotFoundException$3.prototype);
			this.Message = opts.Message;
		}
	};
	let EncryptionFailure$1 = class EncryptionFailure$2 extends SecretsManagerServiceException$1 {
		name = "EncryptionFailure";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "EncryptionFailure",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, EncryptionFailure$2.prototype);
			this.Message = opts.Message;
		}
	};
	let LimitExceededException$1 = class LimitExceededException$2 extends SecretsManagerServiceException$1 {
		name = "LimitExceededException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "LimitExceededException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, LimitExceededException$2.prototype);
			this.Message = opts.Message;
		}
	};
	let MalformedPolicyDocumentException$1$1 = class MalformedPolicyDocumentException$3 extends SecretsManagerServiceException$1 {
		name = "MalformedPolicyDocumentException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "MalformedPolicyDocumentException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, MalformedPolicyDocumentException$3.prototype);
			this.Message = opts.Message;
		}
	};
	let PreconditionNotMetException$1 = class PreconditionNotMetException$2 extends SecretsManagerServiceException$1 {
		name = "PreconditionNotMetException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "PreconditionNotMetException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, PreconditionNotMetException$2.prototype);
			this.Message = opts.Message;
		}
	};
	let ResourceExistsException$1 = class ResourceExistsException$2 extends SecretsManagerServiceException$1 {
		name = "ResourceExistsException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "ResourceExistsException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ResourceExistsException$2.prototype);
			this.Message = opts.Message;
		}
	};
	let PublicPolicyException$1 = class PublicPolicyException$2 extends SecretsManagerServiceException$1 {
		name = "PublicPolicyException";
		$fault = "client";
		Message;
		constructor(opts) {
			super({
				name: "PublicPolicyException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, PublicPolicyException$2.prototype);
			this.Message = opts.Message;
		}
	};
	const _AAD = "AutomaticallyAfterDays";
	const _APIELT = "APIErrorListType";
	const _APIET = "APIErrorType";
	const _ARN = "ARN";
	const _ARR$1 = "AddReplicaRegions";
	const _ARRLT = "AddReplicaRegionListType";
	const _BGSV = "BatchGetSecretValue";
	const _BGSVR = "BatchGetSecretValueRequest";
	const _BGSVRa = "BatchGetSecretValueResponse";
	const _BPP = "BlockPublicPolicy";
	const _CD = "CreatedDate";
	const _CN = "CheckName";
	const _CRS = "CancelRotateSecret";
	const _CRSR = "CancelRotateSecretRequest";
	const _CRSRa = "CancelRotateSecretResponse";
	const _CRT = "ClientRequestToken";
	const _CS$1 = "CreateSecret";
	const _CSR = "CreateSecretRequest";
	const _CSRr = "CreateSecretResponse";
	const _D = "Description";
	const _DD = "DeletionDate";
	const _DDe = "DeletedDate";
	const _DF = "DecryptionFailure";
	const _DRP = "DeleteResourcePolicy";
	const _DRPR = "DeleteResourcePolicyRequest";
	const _DRPRe = "DeleteResourcePolicyResponse";
	const _DS$1 = "DeleteSecret";
	const _DSR = "DeleteSecretRequest";
	const _DSRe = "DeleteSecretResponse";
	const _DSRes = "DescribeSecretRequest";
	const _DSResc = "DescribeSecretResponse";
	const _DSe = "DescribeSecret";
	const _Du = "Duration";
	const _E$1 = "Errors";
	const _EC = "ErrorCode";
	const _ECx = "ExcludeCharacters";
	const _EF = "EncryptionFailure";
	const _EL = "ExcludeLowercase";
	const _EM = "ErrorMessage";
	const _EN = "ExcludeNumbers";
	const _EP = "ExcludePunctuation";
	const _ESRM = "ExternalSecretRotationMetadata";
	const _ESRMI = "ExternalSecretRotationMetadataItem";
	const _ESRMT = "ExternalSecretRotationMetadataType";
	const _ESRRA = "ExternalSecretRotationRoleArn";
	const _EU = "ExcludeUppercase";
	const _F = "Filters";
	const _FDWR = "ForceDeleteWithoutRecovery";
	const _FLT = "FiltersListType";
	const _FORS = "ForceOverwriteReplicaSecret";
	const _Fi = "Filter";
	const _GRP = "GetRandomPassword";
	const _GRPR = "GetRandomPasswordRequest";
	const _GRPRe = "GetRandomPasswordResponse";
	const _GRPRet = "GetResourcePolicyRequest";
	const _GRPRete = "GetResourcePolicyResponse";
	const _GRPe = "GetResourcePolicy";
	const _GSV = "GetSecretValue";
	const _GSVR = "GetSecretValueRequest";
	const _GSVRe = "GetSecretValueResponse";
	const _ID = "IncludeDeprecated";
	const _INTE = "InvalidNextTokenException";
	const _IPD = "IncludePlannedDeletion";
	const _IPE = "InvalidParameterException";
	const _IRE$2 = "InvalidRequestException";
	const _IS = "IncludeSpace";
	const _ISE$2 = "InternalServiceError";
	const _K$1 = "Key";
	const _KKI = "KmsKeyId";
	const _KKIm = "KmsKeyIds";
	const _LAD = "LastAccessedDate";
	const _LCD = "LastChangedDate";
	const _LEE = "LimitExceededException";
	const _LRD = "LastRotatedDate";
	const _LS = "ListSecrets";
	const _LSR = "ListSecretsRequest";
	const _LSRi = "ListSecretsResponse";
	const _LSVI = "ListSecretVersionIds";
	const _LSVIR = "ListSecretVersionIdsRequest";
	const _LSVIRi = "ListSecretVersionIdsResponse";
	const _M = "Message";
	const _MPDE$1 = "MalformedPolicyDocumentException";
	const _MR = "MaxResults";
	const _MTVI = "MoveToVersionId";
	const _N = "Name";
	const _NRD = "NextRotationDate";
	const _NT = "NextToken";
	const _OS = "OwningService";
	const _PL = "PasswordLength";
	const _PNME = "PreconditionNotMetException";
	const _PPE = "PublicPolicyException";
	const _PR = "PrimaryRegion";
	const _PRP = "PutResourcePolicy";
	const _PRPR = "PutResourcePolicyRequest";
	const _PRPRu = "PutResourcePolicyResponse";
	const _PSV = "PutSecretValue";
	const _PSVR = "PutSecretValueRequest";
	const _PSVRu = "PutSecretValueResponse";
	const _PVP = "PolicyValidationPassed";
	const _R = "Region";
	const _RE = "RotationEnabled";
	const _REE = "ResourceExistsException";
	const _REIT = "RequireEachIncludedType";
	const _RFVI = "RemoveFromVersionId";
	const _RI$1 = "RotateImmediately";
	const _RLARN = "RotationLambdaARN";
	const _RNFE$1 = "ResourceNotFoundException";
	const _RP = "RandomPassword";
	const _RPT = "RandomPasswordType";
	const _RPe = "ResourcePolicy";
	const _RR = "RotationRules";
	const _RRFR = "RemoveRegionsFromReplication";
	const _RRFRR = "RemoveRegionsFromReplicationRequest";
	const _RRFRRe = "RemoveRegionsFromReplicationResponse";
	const _RRR = "RemoveReplicaRegions";
	const _RRT = "ReplicaRegionType";
	const _RRTo = "RotationRulesType";
	const _RS = "ReplicationStatus";
	const _RSLT = "ReplicationStatusListType";
	const _RSR = "RestoreSecretRequest";
	const _RSRe = "RestoreSecretResponse";
	const _RSRo = "RotateSecretRequest";
	const _RSRot = "RotateSecretResponse";
	const _RST = "ReplicationStatusType";
	const _RSTR = "ReplicateSecretToRegions";
	const _RSTRR = "ReplicateSecretToRegionsRequest";
	const _RSTRRe = "ReplicateSecretToRegionsResponse";
	const _RSe = "RestoreSecret";
	const _RSo = "RotateSecret";
	const _RT$2 = "RotationToken";
	const _RTT = "RotationTokenType";
	const _RWID = "RecoveryWindowInDays";
	const _S = "Status";
	const _SB = "SecretBinary";
	const _SBT = "SecretBinaryType";
	const _SE = "ScheduleExpression";
	const _SI$1 = "SecretId";
	const _SIL = "SecretIdList";
	const _SL = "SecretList";
	const _SLE = "SecretListEntry";
	const _SLT = "SecretListType";
	const _SM = "StatusMessage";
	const _SO = "SortOrder";
	const _SRTR = "StopReplicationToReplica";
	const _SRTRR = "StopReplicationToReplicaRequest";
	const _SRTRRt = "StopReplicationToReplicaResponse";
	const _SS = "SecretString";
	const _SST = "SecretStringType";
	const _SV = "SecretValues";
	const _SVE = "SecretValueEntry";
	const _SVLE = "SecretVersionsListEntry";
	const _SVLT = "SecretVersionsListType";
	const _SVT = "SecretValuesType";
	const _SVTS = "SecretVersionsToStages";
	const _SVTSMT = "SecretVersionsToStagesMapType";
	const _T$1 = "Tags";
	const _TK = "TagKeys";
	const _TLT = "TagListType";
	const _TR = "TagResource";
	const _TRR = "TagResourceRequest";
	const _Ta$1 = "Tag";
	const _Ty = "Type";
	const _UR = "UntagResource";
	const _URR = "UntagResourceRequest";
	const _US = "UpdateSecret";
	const _USR = "UpdateSecretRequest";
	const _USRp = "UpdateSecretResponse";
	const _USVS = "UpdateSecretVersionStage";
	const _USVSR = "UpdateSecretVersionStageRequest";
	const _USVSRp = "UpdateSecretVersionStageResponse";
	const _V$1 = "Value";
	const _VE$1 = "ValidationErrors";
	const _VEE = "ValidationErrorsEntry";
	const _VET = "ValidationErrorsType";
	const _VI = "VersionId";
	const _VITS = "VersionIdsToStages";
	const _VRP = "ValidateResourcePolicy";
	const _VRPR = "ValidateResourcePolicyRequest";
	const _VRPRa = "ValidateResourcePolicyResponse";
	const _VS = "VersionStage";
	const _VSe = "VersionStages";
	const _Va = "Values";
	const _Ve = "Versions";
	const _c$4 = "client";
	const _e$4 = "error";
	const _s$4 = "server";
	const _sm$2 = "smithy.ts.sdk.synthetic.com.amazonaws.secretsmanager";
	const n0$4 = "com.amazonaws.secretsmanager";
	var RandomPasswordType = [
		0,
		n0$4,
		_RPT,
		8,
		0
	];
	var RotationTokenType = [
		0,
		n0$4,
		_RTT,
		8,
		0
	];
	var SecretBinaryType = [
		0,
		n0$4,
		_SBT,
		8,
		21
	];
	var SecretStringType = [
		0,
		n0$4,
		_SST,
		8,
		0
	];
	var APIErrorType = [
		3,
		n0$4,
		_APIET,
		0,
		[
			_SI$1,
			_EC,
			_M
		],
		[
			0,
			0,
			0
		]
	];
	var BatchGetSecretValueRequest = [
		3,
		n0$4,
		_BGSVR,
		0,
		[
			_SIL,
			_F,
			_MR,
			_NT
		],
		[
			64,
			() => FiltersListType,
			1,
			0
		]
	];
	var BatchGetSecretValueResponse = [
		3,
		n0$4,
		_BGSVRa,
		0,
		[
			_SV,
			_NT,
			_E$1
		],
		[
			[() => SecretValuesType, 0],
			0,
			() => APIErrorListType
		]
	];
	var CancelRotateSecretRequest = [
		3,
		n0$4,
		_CRSR,
		0,
		[_SI$1],
		[0]
	];
	var CancelRotateSecretResponse = [
		3,
		n0$4,
		_CRSRa,
		0,
		[
			_ARN,
			_N,
			_VI
		],
		[
			0,
			0,
			0
		]
	];
	var CreateSecretRequest = [
		3,
		n0$4,
		_CSR,
		0,
		[
			_N,
			_CRT,
			_D,
			_KKI,
			_SB,
			_SS,
			_T$1,
			_ARR$1,
			_FORS,
			_Ty
		],
		[
			0,
			[0, 4],
			0,
			0,
			[() => SecretBinaryType, 0],
			[() => SecretStringType, 0],
			() => TagListType,
			() => AddReplicaRegionListType,
			2,
			0
		]
	];
	var CreateSecretResponse = [
		3,
		n0$4,
		_CSRr,
		0,
		[
			_ARN,
			_N,
			_VI,
			_RS
		],
		[
			0,
			0,
			0,
			() => ReplicationStatusListType
		]
	];
	var DecryptionFailure = [
		-3,
		n0$4,
		_DF,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(DecryptionFailure, DecryptionFailure$1);
	var DeleteResourcePolicyRequest = [
		3,
		n0$4,
		_DRPR,
		0,
		[_SI$1],
		[0]
	];
	var DeleteResourcePolicyResponse = [
		3,
		n0$4,
		_DRPRe,
		0,
		[_ARN, _N],
		[0, 0]
	];
	var DeleteSecretRequest = [
		3,
		n0$4,
		_DSR,
		0,
		[
			_SI$1,
			_RWID,
			_FDWR
		],
		[
			0,
			1,
			2
		]
	];
	var DeleteSecretResponse = [
		3,
		n0$4,
		_DSRe,
		0,
		[
			_ARN,
			_N,
			_DD
		],
		[
			0,
			0,
			4
		]
	];
	var DescribeSecretRequest = [
		3,
		n0$4,
		_DSRes,
		0,
		[_SI$1],
		[0]
	];
	var DescribeSecretResponse = [
		3,
		n0$4,
		_DSResc,
		0,
		[
			_ARN,
			_N,
			_Ty,
			_D,
			_KKI,
			_RE,
			_RLARN,
			_RR,
			_ESRM,
			_ESRRA,
			_LRD,
			_LCD,
			_LAD,
			_DDe,
			_NRD,
			_T$1,
			_VITS,
			_OS,
			_CD,
			_PR,
			_RS
		],
		[
			0,
			0,
			0,
			0,
			0,
			2,
			0,
			() => RotationRulesType,
			() => ExternalSecretRotationMetadataType,
			0,
			4,
			4,
			4,
			4,
			4,
			() => TagListType,
			[
				2,
				n0$4,
				_SVTSMT,
				0,
				0,
				64
			],
			0,
			4,
			0,
			() => ReplicationStatusListType
		]
	];
	var EncryptionFailure = [
		-3,
		n0$4,
		_EF,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(EncryptionFailure, EncryptionFailure$1);
	var ExternalSecretRotationMetadataItem = [
		3,
		n0$4,
		_ESRMI,
		0,
		[_K$1, _V$1],
		[0, 0]
	];
	var Filter = [
		3,
		n0$4,
		_Fi,
		0,
		[_K$1, _Va],
		[0, 64]
	];
	var GetRandomPasswordRequest = [
		3,
		n0$4,
		_GRPR,
		0,
		[
			_PL,
			_ECx,
			_EN,
			_EP,
			_EU,
			_EL,
			_IS,
			_REIT
		],
		[
			1,
			0,
			2,
			2,
			2,
			2,
			2,
			2
		]
	];
	var GetRandomPasswordResponse = [
		3,
		n0$4,
		_GRPRe,
		0,
		[_RP],
		[[() => RandomPasswordType, 0]]
	];
	var GetResourcePolicyRequest = [
		3,
		n0$4,
		_GRPRet,
		0,
		[_SI$1],
		[0]
	];
	var GetResourcePolicyResponse = [
		3,
		n0$4,
		_GRPRete,
		0,
		[
			_ARN,
			_N,
			_RPe
		],
		[
			0,
			0,
			0
		]
	];
	var GetSecretValueRequest = [
		3,
		n0$4,
		_GSVR,
		0,
		[
			_SI$1,
			_VI,
			_VS
		],
		[
			0,
			0,
			0
		]
	];
	var GetSecretValueResponse = [
		3,
		n0$4,
		_GSVRe,
		0,
		[
			_ARN,
			_N,
			_VI,
			_SB,
			_SS,
			_VSe,
			_CD
		],
		[
			0,
			0,
			0,
			[() => SecretBinaryType, 0],
			[() => SecretStringType, 0],
			64,
			4
		]
	];
	var InternalServiceError = [
		-3,
		n0$4,
		_ISE$2,
		{ [_e$4]: _s$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(InternalServiceError, InternalServiceError$1);
	var InvalidNextTokenException = [
		-3,
		n0$4,
		_INTE,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(InvalidNextTokenException, InvalidNextTokenException$1);
	var InvalidParameterException = [
		-3,
		n0$4,
		_IPE,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(InvalidParameterException, InvalidParameterException$1);
	var InvalidRequestException$3 = [
		-3,
		n0$4,
		_IRE$2,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(InvalidRequestException$3, InvalidRequestException$1$2);
	var LimitExceededException = [
		-3,
		n0$4,
		_LEE,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(LimitExceededException, LimitExceededException$1);
	var ListSecretsRequest = [
		3,
		n0$4,
		_LSR,
		0,
		[
			_IPD,
			_MR,
			_NT,
			_F,
			_SO
		],
		[
			2,
			1,
			0,
			() => FiltersListType,
			0
		]
	];
	var ListSecretsResponse = [
		3,
		n0$4,
		_LSRi,
		0,
		[_SL, _NT],
		[() => SecretListType, 0]
	];
	var ListSecretVersionIdsRequest = [
		3,
		n0$4,
		_LSVIR,
		0,
		[
			_SI$1,
			_MR,
			_NT,
			_ID
		],
		[
			0,
			1,
			0,
			2
		]
	];
	var ListSecretVersionIdsResponse = [
		3,
		n0$4,
		_LSVIRi,
		0,
		[
			_Ve,
			_NT,
			_ARN,
			_N
		],
		[
			() => SecretVersionsListType,
			0,
			0,
			0
		]
	];
	var MalformedPolicyDocumentException$2 = [
		-3,
		n0$4,
		_MPDE$1,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(MalformedPolicyDocumentException$2, MalformedPolicyDocumentException$1$1);
	var PreconditionNotMetException = [
		-3,
		n0$4,
		_PNME,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(PreconditionNotMetException, PreconditionNotMetException$1);
	var PublicPolicyException = [
		-3,
		n0$4,
		_PPE,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(PublicPolicyException, PublicPolicyException$1);
	var PutResourcePolicyRequest = [
		3,
		n0$4,
		_PRPR,
		0,
		[
			_SI$1,
			_RPe,
			_BPP
		],
		[
			0,
			0,
			2
		]
	];
	var PutResourcePolicyResponse = [
		3,
		n0$4,
		_PRPRu,
		0,
		[_ARN, _N],
		[0, 0]
	];
	var PutSecretValueRequest = [
		3,
		n0$4,
		_PSVR,
		0,
		[
			_SI$1,
			_CRT,
			_SB,
			_SS,
			_VSe,
			_RT$2
		],
		[
			0,
			[0, 4],
			[() => SecretBinaryType, 0],
			[() => SecretStringType, 0],
			64,
			[() => RotationTokenType, 0]
		]
	];
	var PutSecretValueResponse = [
		3,
		n0$4,
		_PSVRu,
		0,
		[
			_ARN,
			_N,
			_VI,
			_VSe
		],
		[
			0,
			0,
			0,
			64
		]
	];
	var RemoveRegionsFromReplicationRequest = [
		3,
		n0$4,
		_RRFRR,
		0,
		[_SI$1, _RRR],
		[0, 64]
	];
	var RemoveRegionsFromReplicationResponse = [
		3,
		n0$4,
		_RRFRRe,
		0,
		[_ARN, _RS],
		[0, () => ReplicationStatusListType]
	];
	var ReplicaRegionType = [
		3,
		n0$4,
		_RRT,
		0,
		[_R, _KKI],
		[0, 0]
	];
	var ReplicateSecretToRegionsRequest = [
		3,
		n0$4,
		_RSTRR,
		0,
		[
			_SI$1,
			_ARR$1,
			_FORS
		],
		[
			0,
			() => AddReplicaRegionListType,
			2
		]
	];
	var ReplicateSecretToRegionsResponse = [
		3,
		n0$4,
		_RSTRRe,
		0,
		[_ARN, _RS],
		[0, () => ReplicationStatusListType]
	];
	var ReplicationStatusType = [
		3,
		n0$4,
		_RST,
		0,
		[
			_R,
			_KKI,
			_S,
			_SM,
			_LAD
		],
		[
			0,
			0,
			0,
			0,
			4
		]
	];
	var ResourceExistsException = [
		-3,
		n0$4,
		_REE,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(ResourceExistsException, ResourceExistsException$1);
	var ResourceNotFoundException$2 = [
		-3,
		n0$4,
		_RNFE$1,
		{ [_e$4]: _c$4 },
		[_M],
		[0]
	];
	schema$1.TypeRegistry.for(n0$4).registerError(ResourceNotFoundException$2, ResourceNotFoundException$1$1);
	var RestoreSecretRequest = [
		3,
		n0$4,
		_RSR,
		0,
		[_SI$1],
		[0]
	];
	var RestoreSecretResponse = [
		3,
		n0$4,
		_RSRe,
		0,
		[_ARN, _N],
		[0, 0]
	];
	var RotateSecretRequest = [
		3,
		n0$4,
		_RSRo,
		0,
		[
			_SI$1,
			_CRT,
			_RLARN,
			_RR,
			_ESRM,
			_ESRRA,
			_RI$1
		],
		[
			0,
			[0, 4],
			0,
			() => RotationRulesType,
			() => ExternalSecretRotationMetadataType,
			0,
			2
		]
	];
	var RotateSecretResponse = [
		3,
		n0$4,
		_RSRot,
		0,
		[
			_ARN,
			_N,
			_VI
		],
		[
			0,
			0,
			0
		]
	];
	var RotationRulesType = [
		3,
		n0$4,
		_RRTo,
		0,
		[
			_AAD,
			_Du,
			_SE
		],
		[
			1,
			0,
			0
		]
	];
	var SecretListEntry = [
		3,
		n0$4,
		_SLE,
		0,
		[
			_ARN,
			_N,
			_Ty,
			_D,
			_KKI,
			_RE,
			_RLARN,
			_RR,
			_ESRM,
			_ESRRA,
			_LRD,
			_LCD,
			_LAD,
			_DDe,
			_NRD,
			_T$1,
			_SVTS,
			_OS,
			_CD,
			_PR
		],
		[
			0,
			0,
			0,
			0,
			0,
			2,
			0,
			() => RotationRulesType,
			() => ExternalSecretRotationMetadataType,
			0,
			4,
			4,
			4,
			4,
			4,
			() => TagListType,
			[
				2,
				n0$4,
				_SVTSMT,
				0,
				0,
				64
			],
			0,
			4,
			0
		]
	];
	var SecretValueEntry = [
		3,
		n0$4,
		_SVE,
		0,
		[
			_ARN,
			_N,
			_VI,
			_SB,
			_SS,
			_VSe,
			_CD
		],
		[
			0,
			0,
			0,
			[() => SecretBinaryType, 0],
			[() => SecretStringType, 0],
			64,
			4
		]
	];
	var SecretVersionsListEntry = [
		3,
		n0$4,
		_SVLE,
		0,
		[
			_VI,
			_VSe,
			_LAD,
			_CD,
			_KKIm
		],
		[
			0,
			64,
			4,
			4,
			64
		]
	];
	var StopReplicationToReplicaRequest = [
		3,
		n0$4,
		_SRTRR,
		0,
		[_SI$1],
		[0]
	];
	var StopReplicationToReplicaResponse = [
		3,
		n0$4,
		_SRTRRt,
		0,
		[_ARN],
		[0]
	];
	var Tag$1 = [
		3,
		n0$4,
		_Ta$1,
		0,
		[_K$1, _V$1],
		[0, 0]
	];
	var TagResourceRequest = [
		3,
		n0$4,
		_TRR,
		0,
		[_SI$1, _T$1],
		[0, () => TagListType]
	];
	var UntagResourceRequest = [
		3,
		n0$4,
		_URR,
		0,
		[_SI$1, _TK],
		[0, 64]
	];
	var UpdateSecretRequest = [
		3,
		n0$4,
		_USR,
		0,
		[
			_SI$1,
			_CRT,
			_D,
			_KKI,
			_SB,
			_SS,
			_Ty
		],
		[
			0,
			[0, 4],
			0,
			0,
			[() => SecretBinaryType, 0],
			[() => SecretStringType, 0],
			0
		]
	];
	var UpdateSecretResponse = [
		3,
		n0$4,
		_USRp,
		0,
		[
			_ARN,
			_N,
			_VI
		],
		[
			0,
			0,
			0
		]
	];
	var UpdateSecretVersionStageRequest = [
		3,
		n0$4,
		_USVSR,
		0,
		[
			_SI$1,
			_VS,
			_RFVI,
			_MTVI
		],
		[
			0,
			0,
			0,
			0
		]
	];
	var UpdateSecretVersionStageResponse = [
		3,
		n0$4,
		_USVSRp,
		0,
		[_ARN, _N],
		[0, 0]
	];
	var ValidateResourcePolicyRequest = [
		3,
		n0$4,
		_VRPR,
		0,
		[_SI$1, _RPe],
		[0, 0]
	];
	var ValidateResourcePolicyResponse = [
		3,
		n0$4,
		_VRPRa,
		0,
		[_PVP, _VE$1],
		[2, () => ValidationErrorsType]
	];
	var ValidationErrorsEntry = [
		3,
		n0$4,
		_VEE,
		0,
		[_CN, _EM],
		[0, 0]
	];
	var __Unit$1 = "unit";
	var SecretsManagerServiceException = [
		-3,
		_sm$2,
		"SecretsManagerServiceException",
		0,
		[],
		[]
	];
	schema$1.TypeRegistry.for(_sm$2).registerError(SecretsManagerServiceException, SecretsManagerServiceException$1);
	var AddReplicaRegionListType = [
		1,
		n0$4,
		_ARRLT,
		0,
		() => ReplicaRegionType
	];
	var APIErrorListType = [
		1,
		n0$4,
		_APIELT,
		0,
		() => APIErrorType
	];
	var ExternalSecretRotationMetadataType = [
		1,
		n0$4,
		_ESRMT,
		0,
		() => ExternalSecretRotationMetadataItem
	];
	var FiltersListType = [
		1,
		n0$4,
		_FLT,
		0,
		() => Filter
	];
	var ReplicationStatusListType = [
		1,
		n0$4,
		_RSLT,
		0,
		() => ReplicationStatusType
	];
	var SecretListType = [
		1,
		n0$4,
		_SLT,
		0,
		() => SecretListEntry
	];
	var SecretValuesType = [
		1,
		n0$4,
		_SVT,
		0,
		[() => SecretValueEntry, 0]
	];
	var SecretVersionsListType = [
		1,
		n0$4,
		_SVLT,
		0,
		() => SecretVersionsListEntry
	];
	var TagListType = [
		1,
		n0$4,
		_TLT,
		0,
		() => Tag$1
	];
	var ValidationErrorsType = [
		1,
		n0$4,
		_VET,
		0,
		() => ValidationErrorsEntry
	];
	var BatchGetSecretValue = [
		9,
		n0$4,
		_BGSV,
		0,
		() => BatchGetSecretValueRequest,
		() => BatchGetSecretValueResponse
	];
	var CancelRotateSecret = [
		9,
		n0$4,
		_CRS,
		0,
		() => CancelRotateSecretRequest,
		() => CancelRotateSecretResponse
	];
	var CreateSecret = [
		9,
		n0$4,
		_CS$1,
		0,
		() => CreateSecretRequest,
		() => CreateSecretResponse
	];
	var DeleteResourcePolicy = [
		9,
		n0$4,
		_DRP,
		0,
		() => DeleteResourcePolicyRequest,
		() => DeleteResourcePolicyResponse
	];
	var DeleteSecret = [
		9,
		n0$4,
		_DS$1,
		0,
		() => DeleteSecretRequest,
		() => DeleteSecretResponse
	];
	var DescribeSecret = [
		9,
		n0$4,
		_DSe,
		0,
		() => DescribeSecretRequest,
		() => DescribeSecretResponse
	];
	var GetRandomPassword = [
		9,
		n0$4,
		_GRP,
		0,
		() => GetRandomPasswordRequest,
		() => GetRandomPasswordResponse
	];
	var GetResourcePolicy = [
		9,
		n0$4,
		_GRPe,
		0,
		() => GetResourcePolicyRequest,
		() => GetResourcePolicyResponse
	];
	var GetSecretValue = [
		9,
		n0$4,
		_GSV,
		0,
		() => GetSecretValueRequest,
		() => GetSecretValueResponse
	];
	var ListSecrets = [
		9,
		n0$4,
		_LS,
		0,
		() => ListSecretsRequest,
		() => ListSecretsResponse
	];
	var ListSecretVersionIds = [
		9,
		n0$4,
		_LSVI,
		0,
		() => ListSecretVersionIdsRequest,
		() => ListSecretVersionIdsResponse
	];
	var PutResourcePolicy = [
		9,
		n0$4,
		_PRP,
		0,
		() => PutResourcePolicyRequest,
		() => PutResourcePolicyResponse
	];
	var PutSecretValue = [
		9,
		n0$4,
		_PSV,
		0,
		() => PutSecretValueRequest,
		() => PutSecretValueResponse
	];
	var RemoveRegionsFromReplication = [
		9,
		n0$4,
		_RRFR,
		0,
		() => RemoveRegionsFromReplicationRequest,
		() => RemoveRegionsFromReplicationResponse
	];
	var ReplicateSecretToRegions = [
		9,
		n0$4,
		_RSTR,
		0,
		() => ReplicateSecretToRegionsRequest,
		() => ReplicateSecretToRegionsResponse
	];
	var RestoreSecret = [
		9,
		n0$4,
		_RSe,
		0,
		() => RestoreSecretRequest,
		() => RestoreSecretResponse
	];
	var RotateSecret = [
		9,
		n0$4,
		_RSo,
		0,
		() => RotateSecretRequest,
		() => RotateSecretResponse
	];
	var StopReplicationToReplica = [
		9,
		n0$4,
		_SRTR,
		0,
		() => StopReplicationToReplicaRequest,
		() => StopReplicationToReplicaResponse
	];
	var TagResource = [
		9,
		n0$4,
		_TR,
		0,
		() => TagResourceRequest,
		() => __Unit$1
	];
	var UntagResource = [
		9,
		n0$4,
		_UR,
		0,
		() => UntagResourceRequest,
		() => __Unit$1
	];
	var UpdateSecret = [
		9,
		n0$4,
		_US,
		0,
		() => UpdateSecretRequest,
		() => UpdateSecretResponse
	];
	var UpdateSecretVersionStage = [
		9,
		n0$4,
		_USVS,
		0,
		() => UpdateSecretVersionStageRequest,
		() => UpdateSecretVersionStageResponse
	];
	var ValidateResourcePolicy = [
		9,
		n0$4,
		_VRP,
		0,
		() => ValidateResourcePolicyRequest,
		() => ValidateResourcePolicyResponse
	];
	var BatchGetSecretValueCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "BatchGetSecretValue", {}).n("SecretsManagerClient", "BatchGetSecretValueCommand").sc(BatchGetSecretValue).build() {};
	var CancelRotateSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "CancelRotateSecret", {}).n("SecretsManagerClient", "CancelRotateSecretCommand").sc(CancelRotateSecret).build() {};
	var CreateSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "CreateSecret", {}).n("SecretsManagerClient", "CreateSecretCommand").sc(CreateSecret).build() {};
	var DeleteResourcePolicyCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "DeleteResourcePolicy", {}).n("SecretsManagerClient", "DeleteResourcePolicyCommand").sc(DeleteResourcePolicy).build() {};
	var DeleteSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "DeleteSecret", {}).n("SecretsManagerClient", "DeleteSecretCommand").sc(DeleteSecret).build() {};
	var DescribeSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "DescribeSecret", {}).n("SecretsManagerClient", "DescribeSecretCommand").sc(DescribeSecret).build() {};
	var GetRandomPasswordCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "GetRandomPassword", {}).n("SecretsManagerClient", "GetRandomPasswordCommand").sc(GetRandomPassword).build() {};
	var GetResourcePolicyCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "GetResourcePolicy", {}).n("SecretsManagerClient", "GetResourcePolicyCommand").sc(GetResourcePolicy).build() {};
	var GetSecretValueCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "GetSecretValue", {}).n("SecretsManagerClient", "GetSecretValueCommand").sc(GetSecretValue).build() {};
	var ListSecretsCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "ListSecrets", {}).n("SecretsManagerClient", "ListSecretsCommand").sc(ListSecrets).build() {};
	var ListSecretVersionIdsCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "ListSecretVersionIds", {}).n("SecretsManagerClient", "ListSecretVersionIdsCommand").sc(ListSecretVersionIds).build() {};
	var PutResourcePolicyCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "PutResourcePolicy", {}).n("SecretsManagerClient", "PutResourcePolicyCommand").sc(PutResourcePolicy).build() {};
	var PutSecretValueCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "PutSecretValue", {}).n("SecretsManagerClient", "PutSecretValueCommand").sc(PutSecretValue).build() {};
	var RemoveRegionsFromReplicationCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "RemoveRegionsFromReplication", {}).n("SecretsManagerClient", "RemoveRegionsFromReplicationCommand").sc(RemoveRegionsFromReplication).build() {};
	var ReplicateSecretToRegionsCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "ReplicateSecretToRegions", {}).n("SecretsManagerClient", "ReplicateSecretToRegionsCommand").sc(ReplicateSecretToRegions).build() {};
	var RestoreSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "RestoreSecret", {}).n("SecretsManagerClient", "RestoreSecretCommand").sc(RestoreSecret).build() {};
	var RotateSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "RotateSecret", {}).n("SecretsManagerClient", "RotateSecretCommand").sc(RotateSecret).build() {};
	var StopReplicationToReplicaCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "StopReplicationToReplica", {}).n("SecretsManagerClient", "StopReplicationToReplicaCommand").sc(StopReplicationToReplica).build() {};
	var TagResourceCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "TagResource", {}).n("SecretsManagerClient", "TagResourceCommand").sc(TagResource).build() {};
	var UntagResourceCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "UntagResource", {}).n("SecretsManagerClient", "UntagResourceCommand").sc(UntagResource).build() {};
	var UpdateSecretCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "UpdateSecret", {}).n("SecretsManagerClient", "UpdateSecretCommand").sc(UpdateSecret).build() {};
	var UpdateSecretVersionStageCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "UpdateSecretVersionStage", {}).n("SecretsManagerClient", "UpdateSecretVersionStageCommand").sc(UpdateSecretVersionStage).build() {};
	var ValidateResourcePolicyCommand = class extends smithyClient$1.Command.classBuilder().ep(commonParams$4).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint$1.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("secretsmanager", "ValidateResourcePolicy", {}).n("SecretsManagerClient", "ValidateResourcePolicyCommand").sc(ValidateResourcePolicy).build() {};
	const commands$4 = {
		BatchGetSecretValueCommand,
		CancelRotateSecretCommand,
		CreateSecretCommand,
		DeleteResourcePolicyCommand,
		DeleteSecretCommand,
		DescribeSecretCommand,
		GetRandomPasswordCommand,
		GetResourcePolicyCommand,
		GetSecretValueCommand,
		ListSecretsCommand,
		ListSecretVersionIdsCommand,
		PutResourcePolicyCommand,
		PutSecretValueCommand,
		RemoveRegionsFromReplicationCommand,
		ReplicateSecretToRegionsCommand,
		RestoreSecretCommand,
		RotateSecretCommand,
		StopReplicationToReplicaCommand,
		TagResourceCommand,
		UntagResourceCommand,
		UpdateSecretCommand,
		UpdateSecretVersionStageCommand,
		ValidateResourcePolicyCommand
	};
	var SecretsManager = class extends SecretsManagerClient {};
	smithyClient$1.createAggregatedClient(commands$4, SecretsManager);
	const paginateBatchGetSecretValue = core$1.createPaginator(SecretsManagerClient, BatchGetSecretValueCommand, "NextToken", "NextToken", "MaxResults");
	const paginateListSecretVersionIds = core$1.createPaginator(SecretsManagerClient, ListSecretVersionIdsCommand, "NextToken", "NextToken", "MaxResults");
	const paginateListSecrets = core$1.createPaginator(SecretsManagerClient, ListSecretsCommand, "NextToken", "NextToken", "MaxResults");
	Object.defineProperty(exports, "$Command", {
		enumerable: true,
		get: function() {
			return smithyClient$1.Command;
		}
	});
	Object.defineProperty(exports, "__Client", {
		enumerable: true,
		get: function() {
			return smithyClient$1.Client;
		}
	});
	exports.ResourceNotFoundException = ResourceNotFoundException$1$1;
	exports.SecretsManager = SecretsManager;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/checkUrl.js
var require_checkUrl = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.checkUrl = void 0;
	const property_provider_1$3 = require_dist_cjs$31();
	const ECS_CONTAINER_HOST = "169.254.170.2";
	const EKS_CONTAINER_HOST_IPv4 = "169.254.170.23";
	const EKS_CONTAINER_HOST_IPv6 = "[fd00:ec2::23]";
	const checkUrl = (url$1, logger$1) => {
		if (url$1.protocol === "https:") return;
		if (url$1.hostname === ECS_CONTAINER_HOST || url$1.hostname === EKS_CONTAINER_HOST_IPv4 || url$1.hostname === EKS_CONTAINER_HOST_IPv6) return;
		if (url$1.hostname.includes("[")) {
			if (url$1.hostname === "[::1]" || url$1.hostname === "[0000:0000:0000:0000:0000:0000:0000:0001]") return;
		} else {
			if (url$1.hostname === "localhost") return;
			const ipComponents = url$1.hostname.split(".");
			const inRange = (component) => {
				const num = parseInt(component, 10);
				return 0 <= num && num <= 255;
			};
			if (ipComponents[0] === "127" && inRange(ipComponents[1]) && inRange(ipComponents[2]) && inRange(ipComponents[3]) && ipComponents.length === 4) return;
		}
		throw new property_provider_1$3.CredentialsProviderError(`URL not accepted. It must either be HTTPS or match one of the following:
  - loopback CIDR 127.0.0.0/8 or [::1/128]
  - ECS container host 169.254.170.2
  - EKS container host 169.254.170.23 or [fd00:ec2::23]`, { logger: logger$1 });
	};
	exports.checkUrl = checkUrl;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/requestHelpers.js
var require_requestHelpers = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.createGetRequest = createGetRequest;
	exports.getCredentials = getCredentials;
	const property_provider_1$2 = require_dist_cjs$31();
	const protocol_http_1 = require_dist_cjs$52();
	const smithy_client_1$2 = require_dist_cjs$28();
	const util_stream_1 = require_dist_cjs$37();
	function createGetRequest(url$1) {
		return new protocol_http_1.HttpRequest({
			protocol: url$1.protocol,
			hostname: url$1.hostname,
			port: Number(url$1.port),
			path: url$1.pathname,
			query: Array.from(url$1.searchParams.entries()).reduce((acc, [k$5, v$5]) => {
				acc[k$5] = v$5;
				return acc;
			}, {}),
			fragment: url$1.hash
		});
	}
	async function getCredentials(response, logger$1) {
		const str = await (0, util_stream_1.sdkStreamMixin)(response.body).transformToString();
		if (response.statusCode === 200) {
			const parsed = JSON.parse(str);
			if (typeof parsed.AccessKeyId !== "string" || typeof parsed.SecretAccessKey !== "string" || typeof parsed.Token !== "string" || typeof parsed.Expiration !== "string") throw new property_provider_1$2.CredentialsProviderError("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }", { logger: logger$1 });
			return {
				accessKeyId: parsed.AccessKeyId,
				secretAccessKey: parsed.SecretAccessKey,
				sessionToken: parsed.Token,
				expiration: (0, smithy_client_1$2.parseRfc3339DateTime)(parsed.Expiration)
			};
		}
		if (response.statusCode >= 400 && response.statusCode < 500) {
			let parsedBody = {};
			try {
				parsedBody = JSON.parse(str);
			} catch (e$5) {}
			throw Object.assign(new property_provider_1$2.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger: logger$1 }), {
				Code: parsedBody.Code,
				Message: parsedBody.Message
			});
		}
		throw new property_provider_1$2.CredentialsProviderError(`Server responded with status: ${response.statusCode}`, { logger: logger$1 });
	}
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/retry-wrapper.js
var require_retry_wrapper = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.retryWrapper = void 0;
	const retryWrapper = (toRetry, maxRetries, delayMs) => {
		return async () => {
			for (let i$5 = 0; i$5 < maxRetries; ++i$5) try {
				return await toRetry();
			} catch (e$5) {
				await new Promise((resolve) => setTimeout(resolve, delayMs));
			}
			return await toRetry();
		};
	};
	exports.retryWrapper = retryWrapper;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-http/dist-cjs/fromHttp/fromHttp.js
var require_fromHttp = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromHttp = void 0;
	const tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
	const client_1$1 = (init_client(), __toCommonJS(client_exports));
	const node_http_handler_1$1 = require_dist_cjs$40();
	const property_provider_1$1 = require_dist_cjs$31();
	const promises_1 = tslib_1.__importDefault(__require("fs/promises"));
	const checkUrl_1 = require_checkUrl();
	const requestHelpers_1 = require_requestHelpers();
	const retry_wrapper_1 = require_retry_wrapper();
	const AWS_CONTAINER_CREDENTIALS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
	const DEFAULT_LINK_LOCAL_HOST = "http://169.254.170.2";
	const AWS_CONTAINER_CREDENTIALS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
	const AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE = "AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE";
	const AWS_CONTAINER_AUTHORIZATION_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
	const fromHttp = (options = {}) => {
		options.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");
		let host;
		const relative = options.awsContainerCredentialsRelativeUri ?? process.env[AWS_CONTAINER_CREDENTIALS_RELATIVE_URI];
		const full = options.awsContainerCredentialsFullUri ?? process.env[AWS_CONTAINER_CREDENTIALS_FULL_URI];
		const token = options.awsContainerAuthorizationToken ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN];
		const tokenFile = options.awsContainerAuthorizationTokenFile ?? process.env[AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE];
		const warn = options.logger?.constructor?.name === "NoOpLogger" || !options.logger?.warn ? console.warn : options.logger.warn.bind(options.logger);
		if (relative && full) {
			warn("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri.");
			warn("awsContainerCredentialsFullUri will take precedence.");
		}
		if (token && tokenFile) {
			warn("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile.");
			warn("awsContainerAuthorizationToken will take precedence.");
		}
		if (full) host = full;
		else if (relative) host = `${DEFAULT_LINK_LOCAL_HOST}${relative}`;
		else throw new property_provider_1$1.CredentialsProviderError(`No HTTP credential provider host provided.
Set AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.`, { logger: options.logger });
		const url$1 = new URL(host);
		(0, checkUrl_1.checkUrl)(url$1, options.logger);
		const requestHandler = node_http_handler_1$1.NodeHttpHandler.create({
			requestTimeout: options.timeout ?? 1e3,
			connectionTimeout: options.timeout ?? 1e3
		});
		return (0, retry_wrapper_1.retryWrapper)(async () => {
			const request$1 = (0, requestHelpers_1.createGetRequest)(url$1);
			if (token) request$1.headers.Authorization = token;
			else if (tokenFile) request$1.headers.Authorization = (await promises_1.default.readFile(tokenFile)).toString();
			try {
				const result = await requestHandler.handle(request$1);
				return (0, requestHelpers_1.getCredentials)(result.response).then((creds) => (0, client_1$1.setCredentialFeature)(creds, "CREDENTIALS_HTTP", "z"));
			} catch (e$5) {
				throw new property_provider_1$1.CredentialsProviderError(String(e$5), { logger: options.logger });
			}
		}, options.maxRetries ?? 3, options.timeout ?? 1e3);
	};
	exports.fromHttp = fromHttp;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-http/dist-cjs/index.js
var require_dist_cjs$8 = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromHttp = void 0;
	var fromHttp_1 = require_fromHttp();
	Object.defineProperty(exports, "fromHttp", {
		enumerable: true,
		get: function() {
			return fromHttp_1.fromHttp;
		}
	});
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-login/dist-cjs/index.js
var require_dist_cjs$7 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var client$4 = (init_client(), __toCommonJS(client_exports));
	var propertyProvider$5 = require_dist_cjs$31();
	var sharedIniFileLoader$4 = require_dist_cjs$22();
	var protocolHttp$1 = require_dist_cjs$52();
	var node_crypto = __require("node:crypto");
	var node_fs = __require("node:fs");
	var node_os = __require("node:os");
	var node_path = __require("node:path");
	var LoginCredentialsFetcher = class LoginCredentialsFetcher {
		profileData;
		init;
		callerClientConfig;
		static REFRESH_THRESHOLD = 300 * 1e3;
		constructor(profileData, init, callerClientConfig) {
			this.profileData = profileData;
			this.init = init;
			this.callerClientConfig = callerClientConfig;
		}
		async loadCredentials() {
			const token = await this.loadToken();
			if (!token) throw new propertyProvider$5.CredentialsProviderError(`Failed to load a token for session ${this.loginSession}, please re-authenticate using aws login`, {
				tryNextLink: false,
				logger: this.logger
			});
			const accessToken = token.accessToken;
			const now = Date.now();
			if (new Date(accessToken.expiresAt).getTime() - now <= LoginCredentialsFetcher.REFRESH_THRESHOLD) return this.refresh(token);
			return {
				accessKeyId: accessToken.accessKeyId,
				secretAccessKey: accessToken.secretAccessKey,
				sessionToken: accessToken.sessionToken,
				accountId: accessToken.accountId,
				expiration: new Date(accessToken.expiresAt)
			};
		}
		get logger() {
			return this.init?.logger;
		}
		get loginSession() {
			return this.profileData.login_session;
		}
		async refresh(token) {
			const { SigninClient: SigninClient$1, CreateOAuth2TokenCommand: CreateOAuth2TokenCommand$1 } = await import("./signin-Dd7liXdh.js");
			const { logger: logger$1, userAgentAppId } = this.callerClientConfig ?? {};
			const isH2$1 = (requestHandler$1) => {
				return requestHandler$1?.metadata?.handlerProtocol === "h2";
			};
			const requestHandler = isH2$1(this.callerClientConfig?.requestHandler) ? void 0 : this.callerClientConfig?.requestHandler;
			const client$6 = new SigninClient$1({
				credentials: {
					accessKeyId: "",
					secretAccessKey: ""
				},
				region: this.profileData.region ?? await this.callerClientConfig?.region?.() ?? process.env.AWS_REGION,
				requestHandler,
				logger: logger$1,
				userAgentAppId,
				...this.init?.clientConfig
			});
			this.createDPoPInterceptor(client$6.middlewareStack);
			const commandInput = { tokenInput: {
				clientId: token.clientId,
				refreshToken: token.refreshToken,
				grantType: "refresh_token"
			} };
			try {
				const response = await client$6.send(new CreateOAuth2TokenCommand$1(commandInput));
				const { accessKeyId, secretAccessKey, sessionToken } = response.tokenOutput?.accessToken ?? {};
				const { refreshToken, expiresIn } = response.tokenOutput ?? {};
				if (!accessKeyId || !secretAccessKey || !sessionToken || !refreshToken) throw new propertyProvider$5.CredentialsProviderError("Token refresh response missing required fields", {
					logger: this.logger,
					tryNextLink: false
				});
				const expiresInMs = (expiresIn ?? 900) * 1e3;
				const expiration = new Date(Date.now() + expiresInMs);
				const updatedToken = {
					...token,
					accessToken: {
						...token.accessToken,
						accessKeyId,
						secretAccessKey,
						sessionToken,
						expiresAt: expiration.toISOString()
					},
					refreshToken
				};
				await this.saveToken(updatedToken);
				const newAccessToken = updatedToken.accessToken;
				return {
					accessKeyId: newAccessToken.accessKeyId,
					secretAccessKey: newAccessToken.secretAccessKey,
					sessionToken: newAccessToken.sessionToken,
					accountId: newAccessToken.accountId,
					expiration
				};
			} catch (error$2) {
				if (error$2.name === "AccessDeniedException") {
					const errorType = error$2.error;
					let message;
					switch (errorType) {
						case "TOKEN_EXPIRED":
							message = "Your session has expired. Please reauthenticate.";
							break;
						case "USER_CREDENTIALS_CHANGED":
							message = "Unable to refresh credentials because of a change in your password. Please reauthenticate with your new password.";
							break;
						case "INSUFFICIENT_PERMISSIONS":
							message = "Unable to refresh credentials due to insufficient permissions. You may be missing permission for the 'CreateOAuth2Token' action.";
							break;
						default: message = `Failed to refresh token: ${String(error$2)}. Please re-authenticate using \`aws login\``;
					}
					throw new propertyProvider$5.CredentialsProviderError(message, {
						logger: this.logger,
						tryNextLink: false
					});
				}
				throw new propertyProvider$5.CredentialsProviderError(`Failed to refresh token: ${String(error$2)}. Please re-authenticate using aws login`, { logger: this.logger });
			}
		}
		async loadToken() {
			const tokenFilePath = this.getTokenFilePath();
			try {
				let tokenData;
				try {
					tokenData = await sharedIniFileLoader$4.readFile(tokenFilePath, { ignoreCache: this.init?.ignoreCache });
				} catch {
					tokenData = await node_fs.promises.readFile(tokenFilePath, "utf8");
				}
				const token = JSON.parse(tokenData);
				const missingFields = [
					"accessToken",
					"clientId",
					"refreshToken",
					"dpopKey"
				].filter((k$5) => !token[k$5]);
				if (!token.accessToken?.accountId) missingFields.push("accountId");
				if (missingFields.length > 0) throw new propertyProvider$5.CredentialsProviderError(`Token validation failed, missing fields: ${missingFields.join(", ")}`, {
					logger: this.logger,
					tryNextLink: false
				});
				return token;
			} catch (error$2) {
				throw new propertyProvider$5.CredentialsProviderError(`Failed to load token from ${tokenFilePath}: ${String(error$2)}`, {
					logger: this.logger,
					tryNextLink: false
				});
			}
		}
		async saveToken(token) {
			const tokenFilePath = this.getTokenFilePath();
			const directory = node_path.dirname(tokenFilePath);
			try {
				await node_fs.promises.mkdir(directory, { recursive: true });
			} catch (error$2) {}
			await node_fs.promises.writeFile(tokenFilePath, JSON.stringify(token, null, 2), "utf8");
		}
		getTokenFilePath() {
			const directory = process.env.AWS_LOGIN_CACHE_DIRECTORY ?? node_path.join(node_os.homedir(), ".aws", "login", "cache");
			const loginSessionBytes = Buffer.from(this.loginSession, "utf8");
			const loginSessionSha256 = node_crypto.createHash("sha256").update(loginSessionBytes).digest("hex");
			return node_path.join(directory, `${loginSessionSha256}.json`);
		}
		derToRawSignature(derSignature) {
			let offset = 2;
			if (derSignature[offset] !== 2) throw new Error("Invalid DER signature");
			offset++;
			const rLength = derSignature[offset++];
			let r$5 = derSignature.subarray(offset, offset + rLength);
			offset += rLength;
			if (derSignature[offset] !== 2) throw new Error("Invalid DER signature");
			offset++;
			const sLength = derSignature[offset++];
			let s$5 = derSignature.subarray(offset, offset + sLength);
			r$5 = r$5[0] === 0 ? r$5.subarray(1) : r$5;
			s$5 = s$5[0] === 0 ? s$5.subarray(1) : s$5;
			const rPadded = Buffer.concat([Buffer.alloc(32 - r$5.length), r$5]);
			const sPadded = Buffer.concat([Buffer.alloc(32 - s$5.length), s$5]);
			return Buffer.concat([rPadded, sPadded]);
		}
		createDPoPInterceptor(middlewareStack$1) {
			middlewareStack$1.add((next) => async (args) => {
				if (protocolHttp$1.HttpRequest.isInstance(args.request)) {
					const request$1 = args.request;
					const actualEndpoint = `${request$1.protocol}//${request$1.hostname}${request$1.port ? `:${request$1.port}` : ""}${request$1.path}`;
					const dpop = await this.generateDpop(request$1.method, actualEndpoint);
					request$1.headers = {
						...request$1.headers,
						DPoP: dpop
					};
				}
				return next(args);
			}, {
				step: "finalizeRequest",
				name: "dpopInterceptor",
				override: true
			});
		}
		async generateDpop(method = "POST", endpoint) {
			const token = await this.loadToken();
			try {
				const privateKey = node_crypto.createPrivateKey({
					key: token.dpopKey,
					format: "pem",
					type: "sec1"
				});
				const publicDer = node_crypto.createPublicKey(privateKey).export({
					format: "der",
					type: "spki"
				});
				let pointStart = -1;
				for (let i$5 = 0; i$5 < publicDer.length; i$5++) if (publicDer[i$5] === 4) {
					pointStart = i$5;
					break;
				}
				const x$5 = publicDer.slice(pointStart + 1, pointStart + 33);
				const y$2 = publicDer.slice(pointStart + 33, pointStart + 65);
				const header = {
					alg: "ES256",
					typ: "dpop+jwt",
					jwk: {
						kty: "EC",
						crv: "P-256",
						x: x$5.toString("base64url"),
						y: y$2.toString("base64url")
					}
				};
				const payload$1 = {
					jti: crypto.randomUUID(),
					htm: method,
					htu: endpoint,
					iat: Math.floor(Date.now() / 1e3)
				};
				const message = `${Buffer.from(JSON.stringify(header)).toString("base64url")}.${Buffer.from(JSON.stringify(payload$1)).toString("base64url")}`;
				const asn1Signature = node_crypto.sign("sha256", Buffer.from(message), privateKey);
				return `${message}.${this.derToRawSignature(asn1Signature).toString("base64url")}`;
			} catch (error$2) {
				throw new propertyProvider$5.CredentialsProviderError(`Failed to generate Dpop proof: ${error$2 instanceof Error ? error$2.message : String(error$2)}`, {
					logger: this.logger,
					tryNextLink: false
				});
			}
		}
	};
	const fromLoginCredentials = (init) => async ({ callerClientConfig } = {}) => {
		init?.logger?.debug?.("@aws-sdk/credential-providers - fromLoginCredentials");
		const profiles = await sharedIniFileLoader$4.parseKnownFiles(init || {});
		const profileName = sharedIniFileLoader$4.getProfileName({ profile: init?.profile ?? callerClientConfig?.profile });
		const profile = profiles[profileName];
		if (!profile?.login_session) throw new propertyProvider$5.CredentialsProviderError(`Profile ${profileName} does not contain login_session.`, {
			tryNextLink: true,
			logger: init?.logger
		});
		const credentials = await new LoginCredentialsFetcher(profile, init, callerClientConfig).loadCredentials();
		return client$4.setCredentialFeature(credentials, "CREDENTIALS_LOGIN", "AD");
	};
	exports.fromLoginCredentials = fromLoginCredentials;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-ini/dist-cjs/index.js
var require_dist_cjs$6 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var sharedIniFileLoader$3 = require_dist_cjs$22();
	var propertyProvider$4 = require_dist_cjs$31();
	var client$3 = (init_client(), __toCommonJS(client_exports));
	var credentialProviderLogin = require_dist_cjs$7();
	const resolveCredentialSource = (credentialSource, profileName, logger$1) => {
		const sourceProvidersMap = {
			EcsContainer: async (options) => {
				const { fromHttp: fromHttp$1 } = await import("./dist-cjs-CAYs523S.js").then(__toDynamicImportESM());
				const { fromContainerMetadata: fromContainerMetadata$1 } = await import("./dist-cjs-C7rSq7e4.js").then(__toDynamicImportESM());
				logger$1?.debug("@aws-sdk/credential-provider-ini - credential_source is EcsContainer");
				return async () => propertyProvider$4.chain(fromHttp$1(options ?? {}), fromContainerMetadata$1(options))().then(setNamedProvider);
			},
			Ec2InstanceMetadata: async (options) => {
				logger$1?.debug("@aws-sdk/credential-provider-ini - credential_source is Ec2InstanceMetadata");
				const { fromInstanceMetadata: fromInstanceMetadata$1 } = await import("./dist-cjs-C7rSq7e4.js").then(__toDynamicImportESM());
				return async () => fromInstanceMetadata$1(options)().then(setNamedProvider);
			},
			Environment: async (options) => {
				logger$1?.debug("@aws-sdk/credential-provider-ini - credential_source is Environment");
				const { fromEnv: fromEnv$2 } = await import("./dist-cjs-hBwVTnru.js").then(__toDynamicImportESM());
				return async () => fromEnv$2(options)().then(setNamedProvider);
			}
		};
		if (credentialSource in sourceProvidersMap) return sourceProvidersMap[credentialSource];
		else throw new propertyProvider$4.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, expected EcsContainer or Ec2InstanceMetadata or Environment.`, { logger: logger$1 });
	};
	const setNamedProvider = (creds) => client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_NAMED_PROVIDER", "p");
	const isAssumeRoleProfile = (arg, { profile = "default", logger: logger$1 } = {}) => {
		return Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1 && ["undefined", "string"].indexOf(typeof arg.external_id) > -1 && ["undefined", "string"].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg, {
			profile,
			logger: logger$1
		}) || isCredentialSourceProfile(arg, {
			profile,
			logger: logger$1
		}));
	};
	const isAssumeRoleWithSourceProfile = (arg, { profile, logger: logger$1 }) => {
		const withSourceProfile = typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
		if (withSourceProfile) logger$1?.debug?.(`    ${profile} isAssumeRoleWithSourceProfile source_profile=${arg.source_profile}`);
		return withSourceProfile;
	};
	const isCredentialSourceProfile = (arg, { profile, logger: logger$1 }) => {
		const withProviderProfile = typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
		if (withProviderProfile) logger$1?.debug?.(`    ${profile} isCredentialSourceProfile credential_source=${arg.credential_source}`);
		return withProviderProfile;
	};
	const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {}, resolveProfileData$1) => {
		options.logger?.debug("@aws-sdk/credential-provider-ini - resolveAssumeRoleCredentials (STS)");
		const profileData = profiles[profileName];
		const { source_profile, region } = profileData;
		if (!options.roleAssumer) {
			const { getDefaultRoleAssumer: getDefaultRoleAssumer$2 } = await import("./sts-CzMGhKw5.js");
			options.roleAssumer = getDefaultRoleAssumer$2({
				...options.clientConfig,
				credentialProviderLogger: options.logger,
				parentClientConfig: {
					...options?.parentClientConfig,
					region: region ?? options?.parentClientConfig?.region
				}
			}, options.clientPlugins);
		}
		if (source_profile && source_profile in visitedProfiles) throw new propertyProvider$4.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile ${sharedIniFileLoader$3.getProfileName(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), { logger: options.logger });
		options.logger?.debug(`@aws-sdk/credential-provider-ini - finding credential resolver using ${source_profile ? `source_profile=[${source_profile}]` : `profile=[${profileName}]`}`);
		const sourceCredsProvider = source_profile ? resolveProfileData$1(source_profile, profiles, options, {
			...visitedProfiles,
			[source_profile]: true
		}, isCredentialSourceWithoutRoleArn(profiles[source_profile] ?? {})) : (await resolveCredentialSource(profileData.credential_source, profileName, options.logger)(options))();
		if (isCredentialSourceWithoutRoleArn(profileData)) return sourceCredsProvider.then((creds) => client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
		else {
			const params = {
				RoleArn: profileData.role_arn,
				RoleSessionName: profileData.role_session_name || `aws-sdk-js-${Date.now()}`,
				ExternalId: profileData.external_id,
				DurationSeconds: parseInt(profileData.duration_seconds || "3600", 10)
			};
			const { mfa_serial } = profileData;
			if (mfa_serial) {
				if (!options.mfaCodeProvider) throw new propertyProvider$4.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, {
					logger: options.logger,
					tryNextLink: false
				});
				params.SerialNumber = mfa_serial;
				params.TokenCode = await options.mfaCodeProvider(mfa_serial);
			}
			const sourceCreds = await sourceCredsProvider;
			return options.roleAssumer(sourceCreds, params).then((creds) => client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SOURCE_PROFILE", "o"));
		}
	};
	const isCredentialSourceWithoutRoleArn = (section) => {
		return !section.role_arn && !!section.credential_source;
	};
	const isLoginProfile = (data$1) => {
		return Boolean(data$1 && data$1.login_session);
	};
	const resolveLoginCredentials = async (profileName, options) => {
		const credentials = await credentialProviderLogin.fromLoginCredentials({
			...options,
			profile: profileName
		})();
		return client$3.setCredentialFeature(credentials, "CREDENTIALS_PROFILE_LOGIN", "AC");
	};
	const isProcessProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
	const resolveProcessCredentials$1 = async (options, profile) => import("./dist-cjs-DfSXziVD.js").then(__toDynamicImportESM()).then(({ fromProcess: fromProcess$1 }) => fromProcess$1({
		...options,
		profile
	})().then((creds) => client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_PROCESS", "v")));
	const resolveSsoCredentials = async (profile, profileData, options = {}) => {
		const { fromSSO: fromSSO$1 } = await import("./dist-cjs-B-aR1-8U.js").then(__toDynamicImportESM());
		return fromSSO$1({
			profile,
			logger: options.logger,
			parentClientConfig: options.parentClientConfig,
			clientConfig: options.clientConfig
		})().then((creds) => {
			if (profileData.sso_session) return client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO", "r");
			else return client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_SSO_LEGACY", "t");
		});
	};
	const isSsoProfile$1 = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
	const isStaticCredsProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && ["undefined", "string"].indexOf(typeof arg.aws_session_token) > -1 && ["undefined", "string"].indexOf(typeof arg.aws_account_id) > -1;
	const resolveStaticCredentials = async (profile, options) => {
		options?.logger?.debug("@aws-sdk/credential-provider-ini - resolveStaticCredentials");
		const credentials = {
			accessKeyId: profile.aws_access_key_id,
			secretAccessKey: profile.aws_secret_access_key,
			sessionToken: profile.aws_session_token,
			...profile.aws_credential_scope && { credentialScope: profile.aws_credential_scope },
			...profile.aws_account_id && { accountId: profile.aws_account_id }
		};
		return client$3.setCredentialFeature(credentials, "CREDENTIALS_PROFILE", "n");
	};
	const isWebIdentityProfile = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && ["undefined", "string"].indexOf(typeof arg.role_session_name) > -1;
	const resolveWebIdentityCredentials = async (profile, options) => import("./dist-cjs-MwJhby-q.js").then(__toDynamicImportESM()).then(({ fromTokenFile: fromTokenFile$2 }) => fromTokenFile$2({
		webIdentityTokenFile: profile.web_identity_token_file,
		roleArn: profile.role_arn,
		roleSessionName: profile.role_session_name,
		roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity,
		logger: options.logger,
		parentClientConfig: options.parentClientConfig
	})().then((creds) => client$3.setCredentialFeature(creds, "CREDENTIALS_PROFILE_STS_WEB_ID_TOKEN", "q")));
	const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {}, isAssumeRoleRecursiveCall = false) => {
		const data$1 = profiles[profileName];
		if (Object.keys(visitedProfiles).length > 0 && isStaticCredsProfile(data$1)) return resolveStaticCredentials(data$1, options);
		if (isAssumeRoleRecursiveCall || isAssumeRoleProfile(data$1, {
			profile: profileName,
			logger: options.logger
		})) return resolveAssumeRoleCredentials(profileName, profiles, options, visitedProfiles, resolveProfileData);
		if (isStaticCredsProfile(data$1)) return resolveStaticCredentials(data$1, options);
		if (isWebIdentityProfile(data$1)) return resolveWebIdentityCredentials(data$1, options);
		if (isProcessProfile(data$1)) return resolveProcessCredentials$1(options, profileName);
		if (isSsoProfile$1(data$1)) return await resolveSsoCredentials(profileName, data$1, options);
		if (isLoginProfile(data$1)) return resolveLoginCredentials(profileName, options);
		throw new propertyProvider$4.CredentialsProviderError(`Could not resolve credentials using profile: [${profileName}] in configuration/credentials file(s).`, { logger: options.logger });
	};
	const fromIni = (_init = {}) => async ({ callerClientConfig } = {}) => {
		const init = {
			..._init,
			parentClientConfig: {
				...callerClientConfig,
				..._init.parentClientConfig
			}
		};
		init.logger?.debug("@aws-sdk/credential-provider-ini - fromIni");
		const profiles = await sharedIniFileLoader$3.parseKnownFiles(init);
		return resolveProfileData(sharedIniFileLoader$3.getProfileName({ profile: _init.profile ?? callerClientConfig?.profile }), profiles, init);
	};
	exports.fromIni = fromIni;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-process/dist-cjs/index.js
var require_dist_cjs$5 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var sharedIniFileLoader$2 = require_dist_cjs$22();
	var propertyProvider$3 = require_dist_cjs$31();
	var child_process = __require("child_process");
	var util = __require("util");
	var client$2 = (init_client(), __toCommonJS(client_exports));
	const getValidatedProcessCredentials = (profileName, data$1, profiles) => {
		if (data$1.Version !== 1) throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
		if (data$1.AccessKeyId === void 0 || data$1.SecretAccessKey === void 0) throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
		if (data$1.Expiration) {
			const currentTime = /* @__PURE__ */ new Date();
			if (new Date(data$1.Expiration) < currentTime) throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
		}
		let accountId = data$1.AccountId;
		if (!accountId && profiles?.[profileName]?.aws_account_id) accountId = profiles[profileName].aws_account_id;
		const credentials = {
			accessKeyId: data$1.AccessKeyId,
			secretAccessKey: data$1.SecretAccessKey,
			...data$1.SessionToken && { sessionToken: data$1.SessionToken },
			...data$1.Expiration && { expiration: new Date(data$1.Expiration) },
			...data$1.CredentialScope && { credentialScope: data$1.CredentialScope },
			...accountId && { accountId }
		};
		client$2.setCredentialFeature(credentials, "CREDENTIALS_PROCESS", "w");
		return credentials;
	};
	const resolveProcessCredentials = async (profileName, profiles, logger$1) => {
		const profile = profiles[profileName];
		if (profiles[profileName]) {
			const credentialProcess = profile["credential_process"];
			if (credentialProcess !== void 0) {
				const execPromise = util.promisify(sharedIniFileLoader$2.externalDataInterceptor?.getTokenRecord?.().exec ?? child_process.exec);
				try {
					const { stdout } = await execPromise(credentialProcess);
					let data$1;
					try {
						data$1 = JSON.parse(stdout.trim());
					} catch {
						throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
					}
					return getValidatedProcessCredentials(profileName, data$1, profiles);
				} catch (error$2) {
					throw new propertyProvider$3.CredentialsProviderError(error$2.message, { logger: logger$1 });
				}
			} else throw new propertyProvider$3.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`, { logger: logger$1 });
		} else throw new propertyProvider$3.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`, { logger: logger$1 });
	};
	const fromProcess = (init = {}) => async ({ callerClientConfig } = {}) => {
		init.logger?.debug("@aws-sdk/credential-provider-process - fromProcess");
		const profiles = await sharedIniFileLoader$2.parseKnownFiles(init);
		return resolveProcessCredentials(sharedIniFileLoader$2.getProfileName({ profile: init.profile ?? callerClientConfig?.profile }), profiles, init.logger);
	};
	exports.fromProcess = fromProcess;
}));

//#endregion
//#region node_modules/@aws-sdk/token-providers/dist-cjs/index.js
var require_dist_cjs$4 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var client$1 = (init_client(), __toCommonJS(client_exports));
	var httpAuthSchemes = (init_httpAuthSchemes(), __toCommonJS(httpAuthSchemes_exports));
	var propertyProvider$2 = require_dist_cjs$31();
	var sharedIniFileLoader$1 = require_dist_cjs$22();
	var fs = __require("fs");
	const fromEnvSigningName = ({ logger: logger$1, signingName } = {}) => async () => {
		logger$1?.debug?.("@aws-sdk/token-providers - fromEnvSigningName");
		if (!signingName) throw new propertyProvider$2.TokenProviderError("Please pass 'signingName' to compute environment variable key", { logger: logger$1 });
		const bearerTokenKey = httpAuthSchemes.getBearerTokenEnvKey(signingName);
		if (!(bearerTokenKey in process.env)) throw new propertyProvider$2.TokenProviderError(`Token not present in '${bearerTokenKey}' environment variable`, { logger: logger$1 });
		const token = { token: process.env[bearerTokenKey] };
		client$1.setTokenFeature(token, "BEARER_SERVICE_ENV_VARS", "3");
		return token;
	};
	const EXPIRE_WINDOW_MS = 300 * 1e3;
	const REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;
	const getSsoOidcClient = async (ssoRegion, init = {}) => {
		const { SSOOIDCClient: SSOOIDCClient$1 } = await import("./sso-oidc-BRhoKMsN.js");
		const coalesce = (prop) => init.clientConfig?.[prop] ?? init.parentClientConfig?.[prop];
		return new SSOOIDCClient$1(Object.assign({}, init.clientConfig ?? {}, {
			region: ssoRegion ?? init.clientConfig?.region,
			logger: coalesce("logger"),
			userAgentAppId: coalesce("userAgentAppId")
		}));
	};
	const getNewSsoOidcToken = async (ssoToken, ssoRegion, init = {}) => {
		const { CreateTokenCommand: CreateTokenCommand$1 } = await import("./sso-oidc-BRhoKMsN.js");
		return (await getSsoOidcClient(ssoRegion, init)).send(new CreateTokenCommand$1({
			clientId: ssoToken.clientId,
			clientSecret: ssoToken.clientSecret,
			refreshToken: ssoToken.refreshToken,
			grantType: "refresh_token"
		}));
	};
	const validateTokenExpiry = (token) => {
		if (token.expiration && token.expiration.getTime() < Date.now()) throw new propertyProvider$2.TokenProviderError(`Token is expired. ${REFRESH_MESSAGE}`, false);
	};
	const validateTokenKey = (key, value, forRefresh = false) => {
		if (typeof value === "undefined") throw new propertyProvider$2.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${REFRESH_MESSAGE}`, false);
	};
	const { writeFile } = fs.promises;
	const writeSSOTokenToFile = (id, ssoToken) => {
		return writeFile(sharedIniFileLoader$1.getSSOTokenFilepath(id), JSON.stringify(ssoToken, null, 2));
	};
	const lastRefreshAttemptTime = /* @__PURE__ */ new Date(0);
	const fromSso = (_init = {}) => async ({ callerClientConfig } = {}) => {
		const init = {
			..._init,
			parentClientConfig: {
				...callerClientConfig,
				..._init.parentClientConfig
			}
		};
		init.logger?.debug("@aws-sdk/token-providers - fromSso");
		const profiles = await sharedIniFileLoader$1.parseKnownFiles(init);
		const profileName = sharedIniFileLoader$1.getProfileName({ profile: init.profile ?? callerClientConfig?.profile });
		const profile = profiles[profileName];
		if (!profile) throw new propertyProvider$2.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
		else if (!profile["sso_session"]) throw new propertyProvider$2.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
		const ssoSessionName = profile["sso_session"];
		const ssoSession = (await sharedIniFileLoader$1.loadSsoSessionData(init))[ssoSessionName];
		if (!ssoSession) throw new propertyProvider$2.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
		for (const ssoSessionRequiredKey of ["sso_start_url", "sso_region"]) if (!ssoSession[ssoSessionRequiredKey]) throw new propertyProvider$2.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
		ssoSession["sso_start_url"];
		const ssoRegion = ssoSession["sso_region"];
		let ssoToken;
		try {
			ssoToken = await sharedIniFileLoader$1.getSSOTokenFromFile(ssoSessionName);
		} catch (e$5) {
			throw new propertyProvider$2.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${REFRESH_MESSAGE}`, false);
		}
		validateTokenKey("accessToken", ssoToken.accessToken);
		validateTokenKey("expiresAt", ssoToken.expiresAt);
		const { accessToken, expiresAt } = ssoToken;
		const existingToken = {
			token: accessToken,
			expiration: new Date(expiresAt)
		};
		if (existingToken.expiration.getTime() - Date.now() > EXPIRE_WINDOW_MS) return existingToken;
		if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1e3) {
			validateTokenExpiry(existingToken);
			return existingToken;
		}
		validateTokenKey("clientId", ssoToken.clientId, true);
		validateTokenKey("clientSecret", ssoToken.clientSecret, true);
		validateTokenKey("refreshToken", ssoToken.refreshToken, true);
		try {
			lastRefreshAttemptTime.setTime(Date.now());
			const newSsoOidcToken = await getNewSsoOidcToken(ssoToken, ssoRegion, init);
			validateTokenKey("accessToken", newSsoOidcToken.accessToken);
			validateTokenKey("expiresIn", newSsoOidcToken.expiresIn);
			const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1e3);
			try {
				await writeSSOTokenToFile(ssoSessionName, {
					...ssoToken,
					accessToken: newSsoOidcToken.accessToken,
					expiresAt: newTokenExpiration.toISOString(),
					refreshToken: newSsoOidcToken.refreshToken
				});
			} catch (error$2) {}
			return {
				token: newSsoOidcToken.accessToken,
				expiration: newTokenExpiration
			};
		} catch (error$2) {
			validateTokenExpiry(existingToken);
			return existingToken;
		}
	};
	const fromStatic = ({ token, logger: logger$1 }) => async () => {
		logger$1?.debug("@aws-sdk/token-providers - fromStatic");
		if (!token || !token.token) throw new propertyProvider$2.TokenProviderError(`Please pass a valid token to fromStatic`, false);
		return token;
	};
	const nodeProvider = (init = {}) => propertyProvider$2.memoize(propertyProvider$2.chain(fromSso(init), async () => {
		throw new propertyProvider$2.TokenProviderError("Could not load token from any providers", false);
	}), (token) => token.expiration !== void 0 && token.expiration.getTime() - Date.now() < 3e5, (token) => token.expiration !== void 0);
	exports.fromEnvSigningName = fromEnvSigningName;
	exports.fromSso = fromSso;
	exports.fromStatic = fromStatic;
	exports.nodeProvider = nodeProvider;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/auth/httpAuthSchemeProvider.js
var require_httpAuthSchemeProvider = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.resolveHttpAuthSchemeConfig = exports.defaultSSOHttpAuthSchemeProvider = exports.defaultSSOHttpAuthSchemeParametersProvider = void 0;
	const core_1$2 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const util_middleware_1 = require_dist_cjs$48();
	const defaultSSOHttpAuthSchemeParametersProvider = async (config, context, input) => {
		return {
			operation: (0, util_middleware_1.getSmithyContext)(context).operation,
			region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
				throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
			})()
		};
	};
	exports.defaultSSOHttpAuthSchemeParametersProvider = defaultSSOHttpAuthSchemeParametersProvider;
	function createAwsAuthSigv4HttpAuthOption$3(authParameters) {
		return {
			schemeId: "aws.auth#sigv4",
			signingProperties: {
				name: "awsssoportal",
				region: authParameters.region
			},
			propertiesExtractor: (config, context) => ({ signingProperties: {
				config,
				context
			} })
		};
	}
	function createSmithyApiNoAuthHttpAuthOption$3(authParameters) {
		return { schemeId: "smithy.api#noAuth" };
	}
	const defaultSSOHttpAuthSchemeProvider = (authParameters) => {
		const options = [];
		switch (authParameters.operation) {
			case "GetRoleCredentials":
				options.push(createSmithyApiNoAuthHttpAuthOption$3(authParameters));
				break;
			case "ListAccountRoles":
				options.push(createSmithyApiNoAuthHttpAuthOption$3(authParameters));
				break;
			case "ListAccounts":
				options.push(createSmithyApiNoAuthHttpAuthOption$3(authParameters));
				break;
			case "Logout":
				options.push(createSmithyApiNoAuthHttpAuthOption$3(authParameters));
				break;
			default: options.push(createAwsAuthSigv4HttpAuthOption$3(authParameters));
		}
		return options;
	};
	exports.defaultSSOHttpAuthSchemeProvider = defaultSSOHttpAuthSchemeProvider;
	const resolveHttpAuthSchemeConfig$3 = (config) => {
		const config_0 = (0, core_1$2.resolveAwsSdkSigV4Config)(config);
		return Object.assign(config_0, { authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? []) });
	};
	exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig$3;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/package.json
var require_package = /* @__PURE__ */ __commonJSMin(((exports, module) => {
	module.exports = {
		"name": "@aws-sdk/client-sso",
		"description": "AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native",
		"version": "3.940.0",
		"scripts": {
			"build": "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
			"build:cjs": "node ../../scripts/compilation/inline client-sso",
			"build:es": "tsc -p tsconfig.es.json",
			"build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
			"build:types": "tsc -p tsconfig.types.json",
			"build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
			"clean": "rimraf ./dist-* && rimraf *.tsbuildinfo",
			"extract:docs": "api-extractor run --local",
			"generate:client": "node ../../scripts/generate-clients/single-service --solo sso"
		},
		"main": "./dist-cjs/index.js",
		"types": "./dist-types/index.d.ts",
		"module": "./dist-es/index.js",
		"sideEffects": false,
		"dependencies": {
			"@aws-crypto/sha256-browser": "5.2.0",
			"@aws-crypto/sha256-js": "5.2.0",
			"@aws-sdk/core": "3.940.0",
			"@aws-sdk/middleware-host-header": "3.936.0",
			"@aws-sdk/middleware-logger": "3.936.0",
			"@aws-sdk/middleware-recursion-detection": "3.936.0",
			"@aws-sdk/middleware-user-agent": "3.940.0",
			"@aws-sdk/region-config-resolver": "3.936.0",
			"@aws-sdk/types": "3.936.0",
			"@aws-sdk/util-endpoints": "3.936.0",
			"@aws-sdk/util-user-agent-browser": "3.936.0",
			"@aws-sdk/util-user-agent-node": "3.940.0",
			"@smithy/config-resolver": "^4.4.3",
			"@smithy/core": "^3.18.5",
			"@smithy/fetch-http-handler": "^5.3.6",
			"@smithy/hash-node": "^4.2.5",
			"@smithy/invalid-dependency": "^4.2.5",
			"@smithy/middleware-content-length": "^4.2.5",
			"@smithy/middleware-endpoint": "^4.3.12",
			"@smithy/middleware-retry": "^4.4.12",
			"@smithy/middleware-serde": "^4.2.6",
			"@smithy/middleware-stack": "^4.2.5",
			"@smithy/node-config-provider": "^4.3.5",
			"@smithy/node-http-handler": "^4.4.5",
			"@smithy/protocol-http": "^5.3.5",
			"@smithy/smithy-client": "^4.9.8",
			"@smithy/types": "^4.9.0",
			"@smithy/url-parser": "^4.2.5",
			"@smithy/util-base64": "^4.3.0",
			"@smithy/util-body-length-browser": "^4.2.0",
			"@smithy/util-body-length-node": "^4.2.1",
			"@smithy/util-defaults-mode-browser": "^4.3.11",
			"@smithy/util-defaults-mode-node": "^4.2.14",
			"@smithy/util-endpoints": "^3.2.5",
			"@smithy/util-middleware": "^4.2.5",
			"@smithy/util-retry": "^4.2.5",
			"@smithy/util-utf8": "^4.2.0",
			"tslib": "^2.6.2"
		},
		"devDependencies": {
			"@tsconfig/node18": "18.2.4",
			"@types/node": "^18.19.69",
			"concurrently": "7.0.0",
			"downlevel-dts": "0.10.1",
			"rimraf": "3.0.2",
			"typescript": "~5.8.3"
		},
		"engines": { "node": ">=18.0.0" },
		"typesVersions": { "<4.0": { "dist-types/*": ["dist-types/ts3.4/*"] } },
		"files": ["dist-*/**"],
		"author": {
			"name": "AWS SDK for JavaScript Team",
			"url": "https://aws.amazon.com/javascript/"
		},
		"license": "Apache-2.0",
		"browser": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser" },
		"react-native": { "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native" },
		"homepage": "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso",
		"repository": {
			"type": "git",
			"url": "https://github.com/aws/aws-sdk-js-v3.git",
			"directory": "clients/client-sso"
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/ruleset.js
var require_ruleset = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ruleSet = void 0;
	const u$3 = "required", v$3 = "fn", w$3 = "argv", x$3 = "ref";
	const a$3 = true, b$3 = "isSet", c$3 = "booleanEquals", d$3 = "error", e$3 = "endpoint", f$3 = "tree", g$3 = "PartitionResult", h$3 = "getAttr", i$3 = {
		[u$3]: false,
		"type": "string"
	}, j$3 = {
		[u$3]: true,
		"default": false,
		"type": "boolean"
	}, k$3 = { [x$3]: "Endpoint" }, l$3 = {
		[v$3]: c$3,
		[w$3]: [{ [x$3]: "UseFIPS" }, true]
	}, m$3 = {
		[v$3]: c$3,
		[w$3]: [{ [x$3]: "UseDualStack" }, true]
	}, n$3 = {}, o$3 = {
		[v$3]: h$3,
		[w$3]: [{ [x$3]: g$3 }, "supportsFIPS"]
	}, p$3 = { [x$3]: g$3 }, q$3 = {
		[v$3]: c$3,
		[w$3]: [true, {
			[v$3]: h$3,
			[w$3]: [p$3, "supportsDualStack"]
		}]
	}, r$3 = [l$3], s$3 = [m$3], t$3 = [{ [x$3]: "Region" }];
	const _data$3 = {
		version: "1.0",
		parameters: {
			Region: i$3,
			UseDualStack: j$3,
			UseFIPS: j$3,
			Endpoint: i$3
		},
		rules: [
			{
				conditions: [{
					[v$3]: b$3,
					[w$3]: [k$3]
				}],
				rules: [
					{
						conditions: r$3,
						error: "Invalid Configuration: FIPS and custom endpoint are not supported",
						type: d$3
					},
					{
						conditions: s$3,
						error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
						type: d$3
					},
					{
						endpoint: {
							url: k$3,
							properties: n$3,
							headers: n$3
						},
						type: e$3
					}
				],
				type: f$3
			},
			{
				conditions: [{
					[v$3]: b$3,
					[w$3]: t$3
				}],
				rules: [{
					conditions: [{
						[v$3]: "aws.partition",
						[w$3]: t$3,
						assign: g$3
					}],
					rules: [
						{
							conditions: [l$3, m$3],
							rules: [{
								conditions: [{
									[v$3]: c$3,
									[w$3]: [a$3, o$3]
								}, q$3],
								rules: [{
									endpoint: {
										url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n$3,
										headers: n$3
									},
									type: e$3
								}],
								type: f$3
							}, {
								error: "FIPS and DualStack are enabled, but this partition does not support one or both",
								type: d$3
							}],
							type: f$3
						},
						{
							conditions: r$3,
							rules: [{
								conditions: [{
									[v$3]: c$3,
									[w$3]: [o$3, a$3]
								}],
								rules: [{
									conditions: [{
										[v$3]: "stringEquals",
										[w$3]: [{
											[v$3]: h$3,
											[w$3]: [p$3, "name"]
										}, "aws-us-gov"]
									}],
									endpoint: {
										url: "https://portal.sso.{Region}.amazonaws.com",
										properties: n$3,
										headers: n$3
									},
									type: e$3
								}, {
									endpoint: {
										url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
										properties: n$3,
										headers: n$3
									},
									type: e$3
								}],
								type: f$3
							}, {
								error: "FIPS is enabled but this partition does not support FIPS",
								type: d$3
							}],
							type: f$3
						},
						{
							conditions: s$3,
							rules: [{
								conditions: [q$3],
								rules: [{
									endpoint: {
										url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n$3,
										headers: n$3
									},
									type: e$3
								}],
								type: f$3
							}, {
								error: "DualStack is enabled but this partition does not support DualStack",
								type: d$3
							}],
							type: f$3
						},
						{
							endpoint: {
								url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
								properties: n$3,
								headers: n$3
							},
							type: e$3
						}
					],
					type: f$3
				}],
				type: f$3
			},
			{
				error: "Invalid Configuration: Missing Region",
				type: d$3
			}
		]
	};
	exports.ruleSet = _data$3;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/endpoint/endpointResolver.js
var require_endpointResolver = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.defaultEndpointResolver = void 0;
	const util_endpoints_1 = require_dist_cjs$32();
	const util_endpoints_2 = require_dist_cjs$35();
	const ruleset_1 = require_ruleset();
	const cache$3 = new util_endpoints_2.EndpointCache({
		size: 50,
		params: [
			"Endpoint",
			"Region",
			"UseDualStack",
			"UseFIPS"
		]
	});
	const defaultEndpointResolver$3 = (endpointParams, context = {}) => {
		return cache$3.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
			endpointParams,
			logger: context.logger
		}));
	};
	exports.defaultEndpointResolver = defaultEndpointResolver$3;
	util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.shared.js
var require_runtimeConfig_shared = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRuntimeConfig = void 0;
	const core_1$1 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const protocols_1 = (init_protocols(), __toCommonJS(protocols_exports));
	const core_2 = (init_dist_es$1(), __toCommonJS(dist_es_exports$1));
	const smithy_client_1$1 = require_dist_cjs$28();
	const url_parser_1 = require_dist_cjs$33();
	const util_base64_1 = require_dist_cjs$43();
	const util_utf8_1 = require_dist_cjs$44();
	const httpAuthSchemeProvider_1 = require_httpAuthSchemeProvider();
	const endpointResolver_1 = require_endpointResolver();
	const getRuntimeConfig$7 = (config) => {
		return {
			apiVersion: "2019-06-10",
			base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
			base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
			disableHostPrefix: config?.disableHostPrefix ?? false,
			endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
			extensions: config?.extensions ?? [],
			httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSOHttpAuthSchemeProvider,
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
				signer: new core_1$1.AwsSdkSigV4Signer()
			}, {
				schemeId: "smithy.api#noAuth",
				identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
				signer: new core_2.NoAuthSigner()
			}],
			logger: config?.logger ?? new smithy_client_1$1.NoOpLogger(),
			protocol: config?.protocol ?? new protocols_1.AwsRestJsonProtocol({ defaultNamespace: "com.amazonaws.sso" }),
			serviceId: config?.serviceId ?? "SSO",
			urlParser: config?.urlParser ?? url_parser_1.parseUrl,
			utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
			utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
		};
	};
	exports.getRuntimeConfig = getRuntimeConfig$7;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/runtimeConfig.js
var require_runtimeConfig = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getRuntimeConfig = void 0;
	const package_json_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports)).__importDefault(require_package());
	const core_1 = (init_dist_es(), __toCommonJS(dist_es_exports));
	const util_user_agent_node_1 = require_dist_cjs$14();
	const config_resolver_1 = require_dist_cjs$24();
	const hash_node_1 = require_dist_cjs$13();
	const middleware_retry_1 = require_dist_cjs$17();
	const node_config_provider_1 = require_dist_cjs$21();
	const node_http_handler_1 = require_dist_cjs$40();
	const util_body_length_node_1 = require_dist_cjs$12();
	const util_retry_1 = require_dist_cjs$18();
	const runtimeConfig_shared_1 = require_runtimeConfig_shared();
	const smithy_client_1 = require_dist_cjs$28();
	const util_defaults_mode_node_1 = require_dist_cjs$11();
	const smithy_client_2 = require_dist_cjs$28();
	const getRuntimeConfig$6 = (config) => {
		(0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
		const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
		const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
		const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
		(0, core_1.emitWarningIfUnsupportedVersion)(process.version);
		const loaderConfig = {
			profile: config?.profile,
			logger: clientSharedValues.logger
		};
		return {
			...clientSharedValues,
			...config,
			runtime: "node",
			defaultsMode,
			authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
			bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
			defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({
				serviceId: clientSharedValues.serviceId,
				clientVersion: package_json_1.default.version
			}),
			maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
			region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, {
				...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS,
				...loaderConfig
			}),
			requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
			retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
				...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
				default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
			}, config),
			sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
			streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
			useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
		};
	};
	exports.getRuntimeConfig = getRuntimeConfig$6;
}));

//#endregion
//#region node_modules/@aws-sdk/client-sso/dist-cjs/index.js
var require_dist_cjs$3 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var middlewareHostHeader = require_dist_cjs$51();
	var middlewareLogger = require_dist_cjs$50();
	var middlewareRecursionDetection = require_dist_cjs$49();
	var middlewareUserAgent = require_dist_cjs$26();
	var configResolver = require_dist_cjs$24();
	var core = (init_dist_es$1(), __toCommonJS(dist_es_exports$1));
	var schema = (init_schema(), __toCommonJS(schema_exports));
	var middlewareContentLength = require_dist_cjs$23();
	var middlewareEndpoint = require_dist_cjs$20();
	var middlewareRetry = require_dist_cjs$17();
	var smithyClient = require_dist_cjs$28();
	var httpAuthSchemeProvider = require_httpAuthSchemeProvider();
	var runtimeConfig = require_runtimeConfig();
	var regionConfigResolver = require_dist_cjs$10();
	var protocolHttp = require_dist_cjs$52();
	const resolveClientEndpointParameters$3 = (options) => {
		return Object.assign(options, {
			useDualstackEndpoint: options.useDualstackEndpoint ?? false,
			useFipsEndpoint: options.useFipsEndpoint ?? false,
			defaultSigningName: "awsssoportal"
		});
	};
	const commonParams$3 = {
		UseFIPS: {
			type: "builtInParams",
			name: "useFipsEndpoint"
		},
		Endpoint: {
			type: "builtInParams",
			name: "endpoint"
		},
		Region: {
			type: "builtInParams",
			name: "region"
		},
		UseDualStack: {
			type: "builtInParams",
			name: "useDualstackEndpoint"
		}
	};
	const getHttpAuthExtensionConfiguration$3 = (runtimeConfig$2) => {
		const _httpAuthSchemes = runtimeConfig$2.httpAuthSchemes;
		let _httpAuthSchemeProvider = runtimeConfig$2.httpAuthSchemeProvider;
		let _credentials = runtimeConfig$2.credentials;
		return {
			setHttpAuthScheme(httpAuthScheme) {
				const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
				if (index === -1) _httpAuthSchemes.push(httpAuthScheme);
				else _httpAuthSchemes.splice(index, 1, httpAuthScheme);
			},
			httpAuthSchemes() {
				return _httpAuthSchemes;
			},
			setHttpAuthSchemeProvider(httpAuthSchemeProvider$2) {
				_httpAuthSchemeProvider = httpAuthSchemeProvider$2;
			},
			httpAuthSchemeProvider() {
				return _httpAuthSchemeProvider;
			},
			setCredentials(credentials) {
				_credentials = credentials;
			},
			credentials() {
				return _credentials;
			}
		};
	};
	const resolveHttpAuthRuntimeConfig$3 = (config) => {
		return {
			httpAuthSchemes: config.httpAuthSchemes(),
			httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
			credentials: config.credentials()
		};
	};
	const resolveRuntimeExtensions$3 = (runtimeConfig$2, extensions) => {
		const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig$2), smithyClient.getDefaultExtensionConfiguration(runtimeConfig$2), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig$2), getHttpAuthExtensionConfiguration$3(runtimeConfig$2));
		extensions.forEach((extension) => extension.configure(extensionConfiguration));
		return Object.assign(runtimeConfig$2, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig$3(extensionConfiguration));
	};
	var SSOClient = class extends smithyClient.Client {
		config;
		constructor(...[configuration]) {
			const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
			super(_config_0);
			this.initConfig = _config_0;
			const _config_1 = resolveClientEndpointParameters$3(_config_0);
			const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
			const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
			const _config_4 = configResolver.resolveRegionConfig(_config_3);
			const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
			const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
			this.config = resolveRuntimeExtensions$3(httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6), configuration?.extensions || []);
			this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
			this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
			this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
			this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
			this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
			this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
			this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
			this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
				httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSOHttpAuthSchemeParametersProvider,
				identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({ "aws.auth#sigv4": config.credentials })
			}));
			this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
		}
		destroy() {
			super.destroy();
		}
	};
	let SSOServiceException$1 = class SSOServiceException$2 extends smithyClient.ServiceException {
		constructor(options) {
			super(options);
			Object.setPrototypeOf(this, SSOServiceException$2.prototype);
		}
	};
	let InvalidRequestException$1$1 = class InvalidRequestException$4 extends SSOServiceException$1 {
		name = "InvalidRequestException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "InvalidRequestException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidRequestException$4.prototype);
		}
	};
	let ResourceNotFoundException$1 = class ResourceNotFoundException$3 extends SSOServiceException$1 {
		name = "ResourceNotFoundException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "ResourceNotFoundException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ResourceNotFoundException$3.prototype);
		}
	};
	let TooManyRequestsException$1 = class TooManyRequestsException$2 extends SSOServiceException$1 {
		name = "TooManyRequestsException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "TooManyRequestsException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, TooManyRequestsException$2.prototype);
		}
	};
	let UnauthorizedException$1 = class UnauthorizedException$2 extends SSOServiceException$1 {
		name = "UnauthorizedException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "UnauthorizedException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, UnauthorizedException$2.prototype);
		}
	};
	const _AI = "AccountInfo";
	const _ALT = "AccountListType";
	const _ATT = "AccessTokenType";
	const _GRC = "GetRoleCredentials";
	const _GRCR = "GetRoleCredentialsRequest";
	const _GRCRe = "GetRoleCredentialsResponse";
	const _IRE$1 = "InvalidRequestException";
	const _L = "Logout";
	const _LA = "ListAccounts";
	const _LAR = "ListAccountsRequest";
	const _LARR = "ListAccountRolesRequest";
	const _LARRi = "ListAccountRolesResponse";
	const _LARi = "ListAccountsResponse";
	const _LARis = "ListAccountRoles";
	const _LR = "LogoutRequest";
	const _RC = "RoleCredentials";
	const _RI = "RoleInfo";
	const _RLT = "RoleListType";
	const _RNFE = "ResourceNotFoundException";
	const _SAKT = "SecretAccessKeyType";
	const _STT = "SessionTokenType";
	const _TMRE$1 = "TooManyRequestsException";
	const _UE = "UnauthorizedException";
	const _aI = "accountId";
	const _aKI$1 = "accessKeyId";
	const _aL = "accountList";
	const _aN = "accountName";
	const _aT$2 = "accessToken";
	const _ai = "account_id";
	const _c$3 = "client";
	const _e$3 = "error";
	const _eA = "emailAddress";
	const _ex = "expiration";
	const _h$2 = "http";
	const _hE$3 = "httpError";
	const _hH = "httpHeader";
	const _hQ = "httpQuery";
	const _m$2 = "message";
	const _mR = "maxResults";
	const _mr = "max_result";
	const _nT = "nextToken";
	const _nt = "next_token";
	const _rC = "roleCredentials";
	const _rL = "roleList";
	const _rN = "roleName";
	const _rn = "role_name";
	const _s$3 = "smithy.ts.sdk.synthetic.com.amazonaws.sso";
	const _sAK$1 = "secretAccessKey";
	const _sT$1 = "sessionToken";
	const _xasbt = "x-amz-sso_bearer_token";
	const n0$3 = "com.amazonaws.sso";
	var AccessTokenType = [
		0,
		n0$3,
		_ATT,
		8,
		0
	];
	var SecretAccessKeyType = [
		0,
		n0$3,
		_SAKT,
		8,
		0
	];
	var SessionTokenType = [
		0,
		n0$3,
		_STT,
		8,
		0
	];
	var AccountInfo = [
		3,
		n0$3,
		_AI,
		0,
		[
			_aI,
			_aN,
			_eA
		],
		[
			0,
			0,
			0
		]
	];
	var GetRoleCredentialsRequest = [
		3,
		n0$3,
		_GRCR,
		0,
		[
			_rN,
			_aI,
			_aT$2
		],
		[
			[0, { [_hQ]: _rn }],
			[0, { [_hQ]: _ai }],
			[() => AccessTokenType, { [_hH]: _xasbt }]
		]
	];
	var GetRoleCredentialsResponse = [
		3,
		n0$3,
		_GRCRe,
		0,
		[_rC],
		[[() => RoleCredentials, 0]]
	];
	var InvalidRequestException$2 = [
		-3,
		n0$3,
		_IRE$1,
		{
			[_e$3]: _c$3,
			[_hE$3]: 400
		},
		[_m$2],
		[0]
	];
	schema.TypeRegistry.for(n0$3).registerError(InvalidRequestException$2, InvalidRequestException$1$1);
	var ListAccountRolesRequest = [
		3,
		n0$3,
		_LARR,
		0,
		[
			_nT,
			_mR,
			_aT$2,
			_aI
		],
		[
			[0, { [_hQ]: _nt }],
			[1, { [_hQ]: _mr }],
			[() => AccessTokenType, { [_hH]: _xasbt }],
			[0, { [_hQ]: _ai }]
		]
	];
	var ListAccountRolesResponse = [
		3,
		n0$3,
		_LARRi,
		0,
		[_nT, _rL],
		[0, () => RoleListType]
	];
	var ListAccountsRequest = [
		3,
		n0$3,
		_LAR,
		0,
		[
			_nT,
			_mR,
			_aT$2
		],
		[
			[0, { [_hQ]: _nt }],
			[1, { [_hQ]: _mr }],
			[() => AccessTokenType, { [_hH]: _xasbt }]
		]
	];
	var ListAccountsResponse = [
		3,
		n0$3,
		_LARi,
		0,
		[_nT, _aL],
		[0, () => AccountListType]
	];
	var LogoutRequest = [
		3,
		n0$3,
		_LR,
		0,
		[_aT$2],
		[[() => AccessTokenType, { [_hH]: _xasbt }]]
	];
	var ResourceNotFoundException = [
		-3,
		n0$3,
		_RNFE,
		{
			[_e$3]: _c$3,
			[_hE$3]: 404
		},
		[_m$2],
		[0]
	];
	schema.TypeRegistry.for(n0$3).registerError(ResourceNotFoundException, ResourceNotFoundException$1);
	var RoleCredentials = [
		3,
		n0$3,
		_RC,
		0,
		[
			_aKI$1,
			_sAK$1,
			_sT$1,
			_ex
		],
		[
			0,
			[() => SecretAccessKeyType, 0],
			[() => SessionTokenType, 0],
			1
		]
	];
	var RoleInfo = [
		3,
		n0$3,
		_RI,
		0,
		[_rN, _aI],
		[0, 0]
	];
	var TooManyRequestsException = [
		-3,
		n0$3,
		_TMRE$1,
		{
			[_e$3]: _c$3,
			[_hE$3]: 429
		},
		[_m$2],
		[0]
	];
	schema.TypeRegistry.for(n0$3).registerError(TooManyRequestsException, TooManyRequestsException$1);
	var UnauthorizedException = [
		-3,
		n0$3,
		_UE,
		{
			[_e$3]: _c$3,
			[_hE$3]: 401
		},
		[_m$2],
		[0]
	];
	schema.TypeRegistry.for(n0$3).registerError(UnauthorizedException, UnauthorizedException$1);
	var __Unit = "unit";
	var SSOServiceException = [
		-3,
		_s$3,
		"SSOServiceException",
		0,
		[],
		[]
	];
	schema.TypeRegistry.for(_s$3).registerError(SSOServiceException, SSOServiceException$1);
	var AccountListType = [
		1,
		n0$3,
		_ALT,
		0,
		() => AccountInfo
	];
	var RoleListType = [
		1,
		n0$3,
		_RLT,
		0,
		() => RoleInfo
	];
	var GetRoleCredentials = [
		9,
		n0$3,
		_GRC,
		{ [_h$2]: [
			"GET",
			"/federation/credentials",
			200
		] },
		() => GetRoleCredentialsRequest,
		() => GetRoleCredentialsResponse
	];
	var ListAccountRoles = [
		9,
		n0$3,
		_LARis,
		{ [_h$2]: [
			"GET",
			"/assignment/roles",
			200
		] },
		() => ListAccountRolesRequest,
		() => ListAccountRolesResponse
	];
	var ListAccounts = [
		9,
		n0$3,
		_LA,
		{ [_h$2]: [
			"GET",
			"/assignment/accounts",
			200
		] },
		() => ListAccountsRequest,
		() => ListAccountsResponse
	];
	var Logout = [
		9,
		n0$3,
		_L,
		{ [_h$2]: [
			"POST",
			"/logout",
			200
		] },
		() => LogoutRequest,
		() => __Unit
	];
	var GetRoleCredentialsCommand = class extends smithyClient.Command.classBuilder().ep(commonParams$3).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("SWBPortalService", "GetRoleCredentials", {}).n("SSOClient", "GetRoleCredentialsCommand").sc(GetRoleCredentials).build() {};
	var ListAccountRolesCommand = class extends smithyClient.Command.classBuilder().ep(commonParams$3).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("SWBPortalService", "ListAccountRoles", {}).n("SSOClient", "ListAccountRolesCommand").sc(ListAccountRoles).build() {};
	var ListAccountsCommand = class extends smithyClient.Command.classBuilder().ep(commonParams$3).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("SWBPortalService", "ListAccounts", {}).n("SSOClient", "ListAccountsCommand").sc(ListAccounts).build() {};
	var LogoutCommand = class extends smithyClient.Command.classBuilder().ep(commonParams$3).m(function(Command$2, cs, config, o$5) {
		return [middlewareEndpoint.getEndpointPlugin(config, Command$2.getEndpointParameterInstructions())];
	}).s("SWBPortalService", "Logout", {}).n("SSOClient", "LogoutCommand").sc(Logout).build() {};
	const commands$3 = {
		GetRoleCredentialsCommand,
		ListAccountRolesCommand,
		ListAccountsCommand,
		LogoutCommand
	};
	var SSO = class extends SSOClient {};
	smithyClient.createAggregatedClient(commands$3, SSO);
	const paginateListAccountRoles = core.createPaginator(SSOClient, ListAccountRolesCommand, "nextToken", "nextToken", "maxResults");
	const paginateListAccounts = core.createPaginator(SSOClient, ListAccountsCommand, "nextToken", "nextToken", "maxResults");
	Object.defineProperty(exports, "$Command", {
		enumerable: true,
		get: function() {
			return smithyClient.Command;
		}
	});
	Object.defineProperty(exports, "__Client", {
		enumerable: true,
		get: function() {
			return smithyClient.Client;
		}
	});
	exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;
	exports.InvalidRequestException = InvalidRequestException$1$1;
	exports.ListAccountRolesCommand = ListAccountRolesCommand;
	exports.ListAccountsCommand = ListAccountsCommand;
	exports.LogoutCommand = LogoutCommand;
	exports.ResourceNotFoundException = ResourceNotFoundException$1;
	exports.SSO = SSO;
	exports.SSOClient = SSOClient;
	exports.SSOServiceException = SSOServiceException$1;
	exports.TooManyRequestsException = TooManyRequestsException$1;
	exports.UnauthorizedException = UnauthorizedException$1;
	exports.paginateListAccountRoles = paginateListAccountRoles;
	exports.paginateListAccounts = paginateListAccounts;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-sso/dist-cjs/loadSso-CVy8iqsZ.js
var require_loadSso_CVy8iqsZ = /* @__PURE__ */ __commonJSMin(((exports) => {
	var clientSso = require_dist_cjs$3();
	Object.defineProperty(exports, "GetRoleCredentialsCommand", {
		enumerable: true,
		get: function() {
			return clientSso.GetRoleCredentialsCommand;
		}
	});
	Object.defineProperty(exports, "SSOClient", {
		enumerable: true,
		get: function() {
			return clientSso.SSOClient;
		}
	});
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-sso/dist-cjs/index.js
var require_dist_cjs$2 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var propertyProvider$1 = require_dist_cjs$31();
	var sharedIniFileLoader = require_dist_cjs$22();
	var client = (init_client(), __toCommonJS(client_exports));
	var tokenProviders = require_dist_cjs$4();
	const isSsoProfile = (arg) => arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
	const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
	const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, clientConfig, parentClientConfig, profile, filepath, configFilepath, ignoreCache, logger: logger$1 }) => {
		let token;
		const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
		if (ssoSession) try {
			const _token = await tokenProviders.fromSso({
				profile,
				filepath,
				configFilepath,
				ignoreCache
			})();
			token = {
				accessToken: _token.token,
				expiresAt: new Date(_token.expiration).toISOString()
			};
		} catch (e$5) {
			throw new propertyProvider$1.CredentialsProviderError(e$5.message, {
				tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
				logger: logger$1
			});
		}
		else try {
			token = await sharedIniFileLoader.getSSOTokenFromFile(ssoStartUrl);
		} catch (e$5) {
			throw new propertyProvider$1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, {
				tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
				logger: logger$1
			});
		}
		if (new Date(token.expiresAt).getTime() - Date.now() <= 0) throw new propertyProvider$1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, {
			tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
			logger: logger$1
		});
		const { accessToken } = token;
		const { SSOClient: SSOClient$1, GetRoleCredentialsCommand: GetRoleCredentialsCommand$1 } = await Promise.resolve().then(function() {
			return require_loadSso_CVy8iqsZ();
		});
		const sso = ssoClient || new SSOClient$1(Object.assign({}, clientConfig ?? {}, {
			logger: clientConfig?.logger ?? parentClientConfig?.logger,
			region: clientConfig?.region ?? ssoRegion,
			userAgentAppId: clientConfig?.userAgentAppId ?? parentClientConfig?.userAgentAppId
		}));
		let ssoResp;
		try {
			ssoResp = await sso.send(new GetRoleCredentialsCommand$1({
				accountId: ssoAccountId,
				roleName: ssoRoleName,
				accessToken
			}));
		} catch (e$5) {
			throw new propertyProvider$1.CredentialsProviderError(e$5, {
				tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
				logger: logger$1
			});
		}
		const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration, credentialScope, accountId } = {} } = ssoResp;
		if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) throw new propertyProvider$1.CredentialsProviderError("SSO returns an invalid temporary credential.", {
			tryNextLink: SHOULD_FAIL_CREDENTIAL_CHAIN,
			logger: logger$1
		});
		const credentials = {
			accessKeyId,
			secretAccessKey,
			sessionToken,
			expiration: new Date(expiration),
			...credentialScope && { credentialScope },
			...accountId && { accountId }
		};
		if (ssoSession) client.setCredentialFeature(credentials, "CREDENTIALS_SSO", "s");
		else client.setCredentialFeature(credentials, "CREDENTIALS_SSO_LEGACY", "u");
		return credentials;
	};
	const validateSsoProfile = (profile, logger$1) => {
		const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
		if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) throw new propertyProvider$1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", "sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, {
			tryNextLink: false,
			logger: logger$1
		});
		return profile;
	};
	const fromSSO = (init = {}) => async ({ callerClientConfig } = {}) => {
		init.logger?.debug("@aws-sdk/credential-provider-sso - fromSSO");
		const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
		const { ssoClient } = init;
		const profileName = sharedIniFileLoader.getProfileName({ profile: init.profile ?? callerClientConfig?.profile });
		if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
			const profile = (await sharedIniFileLoader.parseKnownFiles(init))[profileName];
			if (!profile) throw new propertyProvider$1.CredentialsProviderError(`Profile ${profileName} was not found.`, { logger: init.logger });
			if (!isSsoProfile(profile)) throw new propertyProvider$1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`, { logger: init.logger });
			if (profile?.sso_session) {
				const session = (await sharedIniFileLoader.loadSsoSessionData(init))[profile.sso_session];
				const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
				if (ssoRegion && ssoRegion !== session.sso_region) throw new propertyProvider$1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, {
					tryNextLink: false,
					logger: init.logger
				});
				if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) throw new propertyProvider$1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, {
					tryNextLink: false,
					logger: init.logger
				});
				profile.sso_region = session.sso_region;
				profile.sso_start_url = session.sso_start_url;
			}
			const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = validateSsoProfile(profile, init.logger);
			return resolveSSOCredentials({
				ssoStartUrl: sso_start_url,
				ssoSession: sso_session,
				ssoAccountId: sso_account_id,
				ssoRegion: sso_region,
				ssoRoleName: sso_role_name,
				ssoClient,
				clientConfig: init.clientConfig,
				parentClientConfig: init.parentClientConfig,
				profile: profileName,
				filepath: init.filepath,
				configFilepath: init.configFilepath,
				ignoreCache: init.ignoreCache,
				logger: init.logger
			});
		} else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) throw new propertyProvider$1.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include \"ssoStartUrl\", \"ssoAccountId\", \"ssoRegion\", \"ssoRoleName\"", {
			tryNextLink: false,
			logger: init.logger
		});
		else return resolveSSOCredentials({
			ssoStartUrl,
			ssoSession,
			ssoAccountId,
			ssoRegion,
			ssoRoleName,
			ssoClient,
			clientConfig: init.clientConfig,
			parentClientConfig: init.parentClientConfig,
			profile: profileName,
			filepath: init.filepath,
			configFilepath: init.configFilepath,
			ignoreCache: init.ignoreCache,
			logger: init.logger
		});
	};
	exports.fromSSO = fromSSO;
	exports.isSsoProfile = isSsoProfile;
	exports.validateSsoProfile = validateSsoProfile;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption$2(authParameters) {
	return {
		schemeId: "aws.auth#sigv4",
		signingProperties: {
			name: "sts",
			region: authParameters.region
		},
		propertiesExtractor: (config, context) => ({ signingProperties: {
			config,
			context
		} })
	};
}
function createSmithyApiNoAuthHttpAuthOption$2(authParameters) {
	return { schemeId: "smithy.api#noAuth" };
}
var import_dist_cjs$105, defaultSTSHttpAuthSchemeParametersProvider, defaultSTSHttpAuthSchemeProvider, resolveStsAuthConfig, resolveHttpAuthSchemeConfig$2;
var init_httpAuthSchemeProvider$2 = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$105 = require_dist_cjs$48();
	init_STSClient();
	defaultSTSHttpAuthSchemeParametersProvider = async (config, context, input) => {
		return {
			operation: (0, import_dist_cjs$105.getSmithyContext)(context).operation,
			region: await (0, import_dist_cjs$105.normalizeProvider)(config.region)() || (() => {
				throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
			})()
		};
	};
	defaultSTSHttpAuthSchemeProvider = (authParameters) => {
		const options = [];
		switch (authParameters.operation) {
			case "AssumeRoleWithWebIdentity":
				options.push(createSmithyApiNoAuthHttpAuthOption$2(authParameters));
				break;
			default: options.push(createAwsAuthSigv4HttpAuthOption$2(authParameters));
		}
		return options;
	};
	resolveStsAuthConfig = (input) => Object.assign(input, { stsClientCtor: STSClient });
	resolveHttpAuthSchemeConfig$2 = (config) => {
		const config_1 = resolveAwsSdkSigV4Config(resolveStsAuthConfig(config));
		return Object.assign(config_1, { authSchemePreference: (0, import_dist_cjs$105.normalizeProvider)(config.authSchemePreference ?? []) });
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/EndpointParameters.js
var resolveClientEndpointParameters$2, commonParams$2;
var init_EndpointParameters$2 = __esmMin((() => {
	resolveClientEndpointParameters$2 = (options) => {
		return Object.assign(options, {
			useDualstackEndpoint: options.useDualstackEndpoint ?? false,
			useFipsEndpoint: options.useFipsEndpoint ?? false,
			useGlobalEndpoint: options.useGlobalEndpoint ?? false,
			defaultSigningName: "sts"
		});
	};
	commonParams$2 = {
		UseGlobalEndpoint: {
			type: "builtInParams",
			name: "useGlobalEndpoint"
		},
		UseFIPS: {
			type: "builtInParams",
			name: "useFipsEndpoint"
		},
		Endpoint: {
			type: "builtInParams",
			name: "endpoint"
		},
		Region: {
			type: "builtInParams",
			name: "region"
		},
		UseDualStack: {
			type: "builtInParams",
			name: "useDualstackEndpoint"
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/package.json
var version = "3.940.0";

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/ruleset.js
var F, G, H, I, J, a$2, b$2, c$2, d$2, e$2, f$2, g$2, h$2, i$2, j$2, k$2, l$2, m$2, n$2, o$2, p$2, q$2, r$2, s$2, t$2, u$2, v$2, w$2, x$2, y, z, A, B, C, D, E, _data$2, ruleSet$2;
var init_ruleset$2 = __esmMin((() => {
	F = "required", G = "type", H = "fn", I = "argv", J = "ref";
	a$2 = false, b$2 = true, c$2 = "booleanEquals", d$2 = "stringEquals", e$2 = "sigv4", f$2 = "sts", g$2 = "us-east-1", h$2 = "endpoint", i$2 = "https://sts.{Region}.{PartitionResult#dnsSuffix}", j$2 = "tree", k$2 = "error", l$2 = "getAttr", m$2 = {
		[F]: false,
		[G]: "string"
	}, n$2 = {
		[F]: true,
		"default": false,
		[G]: "boolean"
	}, o$2 = { [J]: "Endpoint" }, p$2 = {
		[H]: "isSet",
		[I]: [{ [J]: "Region" }]
	}, q$2 = { [J]: "Region" }, r$2 = {
		[H]: "aws.partition",
		[I]: [q$2],
		"assign": "PartitionResult"
	}, s$2 = { [J]: "UseFIPS" }, t$2 = { [J]: "UseDualStack" }, u$2 = {
		"url": "https://sts.amazonaws.com",
		"properties": { "authSchemes": [{
			"name": e$2,
			"signingName": f$2,
			"signingRegion": g$2
		}] },
		"headers": {}
	}, v$2 = {}, w$2 = {
		"conditions": [{
			[H]: d$2,
			[I]: [q$2, "aws-global"]
		}],
		[h$2]: u$2,
		[G]: h$2
	}, x$2 = {
		[H]: c$2,
		[I]: [s$2, true]
	}, y = {
		[H]: c$2,
		[I]: [t$2, true]
	}, z = {
		[H]: l$2,
		[I]: [{ [J]: "PartitionResult" }, "supportsFIPS"]
	}, A = { [J]: "PartitionResult" }, B = {
		[H]: c$2,
		[I]: [true, {
			[H]: l$2,
			[I]: [A, "supportsDualStack"]
		}]
	}, C = [{
		[H]: "isSet",
		[I]: [o$2]
	}], D = [x$2], E = [y];
	_data$2 = {
		version: "1.0",
		parameters: {
			Region: m$2,
			UseDualStack: n$2,
			UseFIPS: n$2,
			Endpoint: m$2,
			UseGlobalEndpoint: n$2
		},
		rules: [
			{
				conditions: [
					{
						[H]: c$2,
						[I]: [{ [J]: "UseGlobalEndpoint" }, b$2]
					},
					{
						[H]: "not",
						[I]: C
					},
					p$2,
					r$2,
					{
						[H]: c$2,
						[I]: [s$2, a$2]
					},
					{
						[H]: c$2,
						[I]: [t$2, a$2]
					}
				],
				rules: [
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "ap-northeast-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "ap-south-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "ap-southeast-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "ap-southeast-2"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					w$2,
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "ca-central-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "eu-central-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "eu-north-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "eu-west-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "eu-west-2"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "eu-west-3"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "sa-east-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, g$2]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "us-east-2"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "us-west-1"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						conditions: [{
							[H]: d$2,
							[I]: [q$2, "us-west-2"]
						}],
						endpoint: u$2,
						[G]: h$2
					},
					{
						endpoint: {
							url: i$2,
							properties: { authSchemes: [{
								name: e$2,
								signingName: f$2,
								signingRegion: "{Region}"
							}] },
							headers: v$2
						},
						[G]: h$2
					}
				],
				[G]: j$2
			},
			{
				conditions: C,
				rules: [
					{
						conditions: D,
						error: "Invalid Configuration: FIPS and custom endpoint are not supported",
						[G]: k$2
					},
					{
						conditions: E,
						error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
						[G]: k$2
					},
					{
						endpoint: {
							url: o$2,
							properties: v$2,
							headers: v$2
						},
						[G]: h$2
					}
				],
				[G]: j$2
			},
			{
				conditions: [p$2],
				rules: [{
					conditions: [r$2],
					rules: [
						{
							conditions: [x$2, y],
							rules: [{
								conditions: [{
									[H]: c$2,
									[I]: [b$2, z]
								}, B],
								rules: [{
									endpoint: {
										url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: v$2,
										headers: v$2
									},
									[G]: h$2
								}],
								[G]: j$2
							}, {
								error: "FIPS and DualStack are enabled, but this partition does not support one or both",
								[G]: k$2
							}],
							[G]: j$2
						},
						{
							conditions: D,
							rules: [{
								conditions: [{
									[H]: c$2,
									[I]: [z, b$2]
								}],
								rules: [{
									conditions: [{
										[H]: d$2,
										[I]: [{
											[H]: l$2,
											[I]: [A, "name"]
										}, "aws-us-gov"]
									}],
									endpoint: {
										url: "https://sts.{Region}.amazonaws.com",
										properties: v$2,
										headers: v$2
									},
									[G]: h$2
								}, {
									endpoint: {
										url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
										properties: v$2,
										headers: v$2
									},
									[G]: h$2
								}],
								[G]: j$2
							}, {
								error: "FIPS is enabled but this partition does not support FIPS",
								[G]: k$2
							}],
							[G]: j$2
						},
						{
							conditions: E,
							rules: [{
								conditions: [B],
								rules: [{
									endpoint: {
										url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: v$2,
										headers: v$2
									},
									[G]: h$2
								}],
								[G]: j$2
							}, {
								error: "DualStack is enabled but this partition does not support DualStack",
								[G]: k$2
							}],
							[G]: j$2
						},
						w$2,
						{
							endpoint: {
								url: i$2,
								properties: v$2,
								headers: v$2
							},
							[G]: h$2
						}
					],
					[G]: j$2
				}],
				[G]: j$2
			},
			{
				error: "Invalid Configuration: Missing Region",
				[G]: k$2
			}
		]
	};
	ruleSet$2 = _data$2;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/endpoint/endpointResolver.js
var import_dist_cjs$103, import_dist_cjs$104, cache$2, defaultEndpointResolver$2;
var init_endpointResolver$2 = __esmMin((() => {
	import_dist_cjs$103 = require_dist_cjs$32();
	import_dist_cjs$104 = require_dist_cjs$35();
	init_ruleset$2();
	cache$2 = new import_dist_cjs$104.EndpointCache({
		size: 50,
		params: [
			"Endpoint",
			"Region",
			"UseDualStack",
			"UseFIPS",
			"UseGlobalEndpoint"
		]
	});
	defaultEndpointResolver$2 = (endpointParams, context = {}) => {
		return cache$2.get(endpointParams, () => (0, import_dist_cjs$104.resolveEndpoint)(ruleSet$2, {
			endpointParams,
			logger: context.logger
		}));
	};
	import_dist_cjs$104.customEndpointFunctions.aws = import_dist_cjs$103.awsEndpointFunctions;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.shared.js
var import_dist_cjs$99, import_dist_cjs$100, import_dist_cjs$101, import_dist_cjs$102, getRuntimeConfig$5;
var init_runtimeConfig_shared$2 = __esmMin((() => {
	init_dist_es();
	init_protocols();
	init_dist_es$1();
	import_dist_cjs$99 = require_dist_cjs$28();
	import_dist_cjs$100 = require_dist_cjs$33();
	import_dist_cjs$101 = require_dist_cjs$43();
	import_dist_cjs$102 = require_dist_cjs$44();
	init_httpAuthSchemeProvider$2();
	init_endpointResolver$2();
	getRuntimeConfig$5 = (config) => {
		return {
			apiVersion: "2011-06-15",
			base64Decoder: config?.base64Decoder ?? import_dist_cjs$101.fromBase64,
			base64Encoder: config?.base64Encoder ?? import_dist_cjs$101.toBase64,
			disableHostPrefix: config?.disableHostPrefix ?? false,
			endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$2,
			extensions: config?.extensions ?? [],
			httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSTSHttpAuthSchemeProvider,
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
				signer: new AwsSdkSigV4Signer()
			}, {
				schemeId: "smithy.api#noAuth",
				identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
				signer: new NoAuthSigner()
			}],
			logger: config?.logger ?? new import_dist_cjs$99.NoOpLogger(),
			protocol: config?.protocol ?? new AwsQueryProtocol({
				defaultNamespace: "com.amazonaws.sts",
				xmlNamespace: "https://sts.amazonaws.com/doc/2011-06-15/",
				version: "2011-06-15"
			}),
			serviceId: config?.serviceId ?? "STS",
			urlParser: config?.urlParser ?? import_dist_cjs$100.parseUrl,
			utf8Decoder: config?.utf8Decoder ?? import_dist_cjs$102.fromUtf8,
			utf8Encoder: config?.utf8Encoder ?? import_dist_cjs$102.toUtf8
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeConfig.js
var import_dist_cjs$88, import_dist_cjs$89, import_dist_cjs$90, import_dist_cjs$91, import_dist_cjs$92, import_dist_cjs$93, import_dist_cjs$94, import_dist_cjs$95, import_dist_cjs$96, import_dist_cjs$97, import_dist_cjs$98, getRuntimeConfig$4;
var init_runtimeConfig$2 = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$88 = require_dist_cjs$14();
	import_dist_cjs$89 = require_dist_cjs$24();
	init_dist_es$1();
	import_dist_cjs$90 = require_dist_cjs$13();
	import_dist_cjs$91 = require_dist_cjs$17();
	import_dist_cjs$92 = require_dist_cjs$21();
	import_dist_cjs$93 = require_dist_cjs$40();
	import_dist_cjs$94 = require_dist_cjs$12();
	import_dist_cjs$95 = require_dist_cjs$18();
	init_runtimeConfig_shared$2();
	import_dist_cjs$96 = require_dist_cjs$28();
	import_dist_cjs$97 = require_dist_cjs$11();
	import_dist_cjs$98 = require_dist_cjs$28();
	getRuntimeConfig$4 = (config) => {
		(0, import_dist_cjs$98.emitWarningIfUnsupportedVersion)(process.version);
		const defaultsMode = (0, import_dist_cjs$97.resolveDefaultsModeConfig)(config);
		const defaultConfigProvider = () => defaultsMode().then(import_dist_cjs$96.loadConfigsForDefaultMode);
		const clientSharedValues = getRuntimeConfig$5(config);
		emitWarningIfUnsupportedVersion(process.version);
		const loaderConfig = {
			profile: config?.profile,
			logger: clientSharedValues.logger
		};
		return {
			...clientSharedValues,
			...config,
			runtime: "node",
			defaultsMode,
			authSchemePreference: config?.authSchemePreference ?? (0, import_dist_cjs$92.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
			bodyLengthChecker: config?.bodyLengthChecker ?? import_dist_cjs$94.calculateBodyLength,
			defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_dist_cjs$88.createDefaultUserAgentProvider)({
				serviceId: clientSharedValues.serviceId,
				clientVersion: version
			}),
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4") || (async (idProps) => await config.credentialDefaultProvider(idProps?.__config || {})()),
				signer: new AwsSdkSigV4Signer()
			}, {
				schemeId: "smithy.api#noAuth",
				identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
				signer: new NoAuthSigner()
			}],
			maxAttempts: config?.maxAttempts ?? (0, import_dist_cjs$92.loadConfig)(import_dist_cjs$91.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
			region: config?.region ?? (0, import_dist_cjs$92.loadConfig)(import_dist_cjs$89.NODE_REGION_CONFIG_OPTIONS, {
				...import_dist_cjs$89.NODE_REGION_CONFIG_FILE_OPTIONS,
				...loaderConfig
			}),
			requestHandler: import_dist_cjs$93.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
			retryMode: config?.retryMode ?? (0, import_dist_cjs$92.loadConfig)({
				...import_dist_cjs$91.NODE_RETRY_MODE_CONFIG_OPTIONS,
				default: async () => (await defaultConfigProvider()).retryMode || import_dist_cjs$95.DEFAULT_RETRY_MODE
			}, config),
			sha256: config?.sha256 ?? import_dist_cjs$90.Hash.bind(null, "sha256"),
			streamCollector: config?.streamCollector ?? import_dist_cjs$93.streamCollector,
			useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_dist_cjs$92.loadConfig)(import_dist_cjs$89.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_dist_cjs$92.loadConfig)(import_dist_cjs$89.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			userAgentAppId: config?.userAgentAppId ?? (0, import_dist_cjs$92.loadConfig)(import_dist_cjs$88.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration$2, resolveHttpAuthRuntimeConfig$2;
var init_httpAuthExtensionConfiguration$2 = __esmMin((() => {
	getHttpAuthExtensionConfiguration$2 = (runtimeConfig$2) => {
		const _httpAuthSchemes = runtimeConfig$2.httpAuthSchemes;
		let _httpAuthSchemeProvider = runtimeConfig$2.httpAuthSchemeProvider;
		let _credentials = runtimeConfig$2.credentials;
		return {
			setHttpAuthScheme(httpAuthScheme) {
				const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
				if (index === -1) _httpAuthSchemes.push(httpAuthScheme);
				else _httpAuthSchemes.splice(index, 1, httpAuthScheme);
			},
			httpAuthSchemes() {
				return _httpAuthSchemes;
			},
			setHttpAuthSchemeProvider(httpAuthSchemeProvider$2) {
				_httpAuthSchemeProvider = httpAuthSchemeProvider$2;
			},
			httpAuthSchemeProvider() {
				return _httpAuthSchemeProvider;
			},
			setCredentials(credentials) {
				_credentials = credentials;
			},
			credentials() {
				return _credentials;
			}
		};
	};
	resolveHttpAuthRuntimeConfig$2 = (config) => {
		return {
			httpAuthSchemes: config.httpAuthSchemes(),
			httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
			credentials: config.credentials()
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/runtimeExtensions.js
var import_dist_cjs$85, import_dist_cjs$86, import_dist_cjs$87, resolveRuntimeExtensions$2;
var init_runtimeExtensions$2 = __esmMin((() => {
	import_dist_cjs$85 = require_dist_cjs$10();
	import_dist_cjs$86 = require_dist_cjs$52();
	import_dist_cjs$87 = require_dist_cjs$28();
	init_httpAuthExtensionConfiguration$2();
	resolveRuntimeExtensions$2 = (runtimeConfig$2, extensions) => {
		const extensionConfiguration = Object.assign((0, import_dist_cjs$85.getAwsRegionExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$87.getDefaultExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$86.getHttpHandlerExtensionConfiguration)(runtimeConfig$2), getHttpAuthExtensionConfiguration$2(runtimeConfig$2));
		extensions.forEach((extension) => extension.configure(extensionConfiguration));
		return Object.assign(runtimeConfig$2, (0, import_dist_cjs$85.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_dist_cjs$87.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_dist_cjs$86.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig$2(extensionConfiguration));
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STSClient.js
var import_dist_cjs$76, import_dist_cjs$77, import_dist_cjs$78, import_dist_cjs$79, import_dist_cjs$80, import_dist_cjs$81, import_dist_cjs$82, import_dist_cjs$83, import_dist_cjs$84, STSClient;
var init_STSClient = __esmMin((() => {
	import_dist_cjs$76 = require_dist_cjs$51();
	import_dist_cjs$77 = require_dist_cjs$50();
	import_dist_cjs$78 = require_dist_cjs$49();
	import_dist_cjs$79 = require_dist_cjs$26();
	import_dist_cjs$80 = require_dist_cjs$24();
	init_dist_es$1();
	init_schema();
	import_dist_cjs$81 = require_dist_cjs$23();
	import_dist_cjs$82 = require_dist_cjs$20();
	import_dist_cjs$83 = require_dist_cjs$17();
	import_dist_cjs$84 = require_dist_cjs$28();
	init_httpAuthSchemeProvider$2();
	init_EndpointParameters$2();
	init_runtimeConfig$2();
	init_runtimeExtensions$2();
	STSClient = class extends import_dist_cjs$84.Client {
		config;
		constructor(...[configuration]) {
			const _config_0 = getRuntimeConfig$4(configuration || {});
			super(_config_0);
			this.initConfig = _config_0;
			this.config = resolveRuntimeExtensions$2(resolveHttpAuthSchemeConfig$2((0, import_dist_cjs$82.resolveEndpointConfig)((0, import_dist_cjs$76.resolveHostHeaderConfig)((0, import_dist_cjs$80.resolveRegionConfig)((0, import_dist_cjs$83.resolveRetryConfig)((0, import_dist_cjs$79.resolveUserAgentConfig)(resolveClientEndpointParameters$2(_config_0))))))), configuration?.extensions || []);
			this.middlewareStack.use(getSchemaSerdePlugin(this.config));
			this.middlewareStack.use((0, import_dist_cjs$79.getUserAgentPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$83.getRetryPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$81.getContentLengthPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$76.getHostHeaderPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$77.getLoggerPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$78.getRecursionDetectionPlugin)(this.config));
			this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
				httpAuthSchemeParametersProvider: defaultSTSHttpAuthSchemeParametersProvider,
				identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({ "aws.auth#sigv4": config.credentials })
			}));
			this.middlewareStack.use(getHttpSigningPlugin(this.config));
		}
		destroy() {
			super.destroy();
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/STSServiceException.js
var import_dist_cjs$75, STSServiceException;
var init_STSServiceException = __esmMin((() => {
	import_dist_cjs$75 = require_dist_cjs$28();
	STSServiceException = class STSServiceException extends import_dist_cjs$75.ServiceException {
		constructor(options) {
			super(options);
			Object.setPrototypeOf(this, STSServiceException.prototype);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/models/errors.js
var ExpiredTokenException$2, MalformedPolicyDocumentException, PackedPolicyTooLargeException, RegionDisabledException, IDPRejectedClaimException, InvalidIdentityTokenException, IDPCommunicationErrorException;
var init_errors$2 = __esmMin((() => {
	init_STSServiceException();
	ExpiredTokenException$2 = class ExpiredTokenException$2 extends STSServiceException {
		name = "ExpiredTokenException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "ExpiredTokenException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ExpiredTokenException$2.prototype);
		}
	};
	MalformedPolicyDocumentException = class MalformedPolicyDocumentException extends STSServiceException {
		name = "MalformedPolicyDocumentException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "MalformedPolicyDocumentException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
		}
	};
	PackedPolicyTooLargeException = class PackedPolicyTooLargeException extends STSServiceException {
		name = "PackedPolicyTooLargeException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "PackedPolicyTooLargeException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
		}
	};
	RegionDisabledException = class RegionDisabledException extends STSServiceException {
		name = "RegionDisabledException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "RegionDisabledException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, RegionDisabledException.prototype);
		}
	};
	IDPRejectedClaimException = class IDPRejectedClaimException extends STSServiceException {
		name = "IDPRejectedClaimException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "IDPRejectedClaimException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
		}
	};
	InvalidIdentityTokenException = class InvalidIdentityTokenException extends STSServiceException {
		name = "InvalidIdentityTokenException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "InvalidIdentityTokenException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
		}
	};
	IDPCommunicationErrorException = class IDPCommunicationErrorException extends STSServiceException {
		name = "IDPCommunicationErrorException";
		$fault = "client";
		constructor(opts) {
			super({
				name: "IDPCommunicationErrorException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/schemas/schemas_0.js
var _A, _AKI, _AR, _ARI, _ARR, _ARRs, _ARU, _ARWWI, _ARWWIR, _ARWWIRs, _Au, _C, _CA, _DS, _E, _EI, _ETE$1, _IDPCEE, _IDPRCE, _IITE, _K, _MPDE, _P, _PA, _PAr, _PC, _PCLT, _PCr, _PDT, _PI, _PPS, _PPTLE, _Pr, _RA, _RDE, _RSN, _SAK, _SFWIT, _SI, _SN, _ST, _T, _TC, _TTK, _Ta, _V, _WIT, _a, _aKST, _aQE, _c$2, _cTT, _e$2, _hE$2, _m$1, _pDLT, _s$2, _tLT, n0$2, accessKeySecretType, clientTokenType, AssumedRoleUser, AssumeRoleRequest, AssumeRoleResponse, AssumeRoleWithWebIdentityRequest, AssumeRoleWithWebIdentityResponse, Credentials, ExpiredTokenException$3, IDPCommunicationErrorException$1, IDPRejectedClaimException$1, InvalidIdentityTokenException$1, MalformedPolicyDocumentException$1, PackedPolicyTooLargeException$1, PolicyDescriptorType, ProvidedContext, RegionDisabledException$1, Tag, STSServiceException$1, policyDescriptorListType, ProvidedContextsListType, tagListType, AssumeRole, AssumeRoleWithWebIdentity;
var init_schemas_0$2 = __esmMin((() => {
	init_schema();
	init_errors$2();
	init_STSServiceException();
	_A = "Arn";
	_AKI = "AccessKeyId";
	_AR = "AssumeRole";
	_ARI = "AssumedRoleId";
	_ARR = "AssumeRoleRequest";
	_ARRs = "AssumeRoleResponse";
	_ARU = "AssumedRoleUser";
	_ARWWI = "AssumeRoleWithWebIdentity";
	_ARWWIR = "AssumeRoleWithWebIdentityRequest";
	_ARWWIRs = "AssumeRoleWithWebIdentityResponse";
	_Au = "Audience";
	_C = "Credentials";
	_CA = "ContextAssertion";
	_DS = "DurationSeconds";
	_E = "Expiration";
	_EI = "ExternalId";
	_ETE$1 = "ExpiredTokenException";
	_IDPCEE = "IDPCommunicationErrorException";
	_IDPRCE = "IDPRejectedClaimException";
	_IITE = "InvalidIdentityTokenException";
	_K = "Key";
	_MPDE = "MalformedPolicyDocumentException";
	_P = "Policy";
	_PA = "PolicyArns";
	_PAr = "ProviderArn";
	_PC = "ProvidedContexts";
	_PCLT = "ProvidedContextsListType";
	_PCr = "ProvidedContext";
	_PDT = "PolicyDescriptorType";
	_PI = "ProviderId";
	_PPS = "PackedPolicySize";
	_PPTLE = "PackedPolicyTooLargeException";
	_Pr = "Provider";
	_RA = "RoleArn";
	_RDE = "RegionDisabledException";
	_RSN = "RoleSessionName";
	_SAK = "SecretAccessKey";
	_SFWIT = "SubjectFromWebIdentityToken";
	_SI = "SourceIdentity";
	_SN = "SerialNumber";
	_ST = "SessionToken";
	_T = "Tags";
	_TC = "TokenCode";
	_TTK = "TransitiveTagKeys";
	_Ta = "Tag";
	_V = "Value";
	_WIT = "WebIdentityToken";
	_a = "arn";
	_aKST = "accessKeySecretType";
	_aQE = "awsQueryError";
	_c$2 = "client";
	_cTT = "clientTokenType";
	_e$2 = "error";
	_hE$2 = "httpError";
	_m$1 = "message";
	_pDLT = "policyDescriptorListType";
	_s$2 = "smithy.ts.sdk.synthetic.com.amazonaws.sts";
	_tLT = "tagListType";
	n0$2 = "com.amazonaws.sts";
	accessKeySecretType = [
		0,
		n0$2,
		_aKST,
		8,
		0
	];
	clientTokenType = [
		0,
		n0$2,
		_cTT,
		8,
		0
	];
	AssumedRoleUser = [
		3,
		n0$2,
		_ARU,
		0,
		[_ARI, _A],
		[0, 0]
	];
	AssumeRoleRequest = [
		3,
		n0$2,
		_ARR,
		0,
		[
			_RA,
			_RSN,
			_PA,
			_P,
			_DS,
			_T,
			_TTK,
			_EI,
			_SN,
			_TC,
			_SI,
			_PC
		],
		[
			0,
			0,
			() => policyDescriptorListType,
			0,
			1,
			() => tagListType,
			64,
			0,
			0,
			0,
			0,
			() => ProvidedContextsListType
		]
	];
	AssumeRoleResponse = [
		3,
		n0$2,
		_ARRs,
		0,
		[
			_C,
			_ARU,
			_PPS,
			_SI
		],
		[
			[() => Credentials, 0],
			() => AssumedRoleUser,
			1,
			0
		]
	];
	AssumeRoleWithWebIdentityRequest = [
		3,
		n0$2,
		_ARWWIR,
		0,
		[
			_RA,
			_RSN,
			_WIT,
			_PI,
			_PA,
			_P,
			_DS
		],
		[
			0,
			0,
			[() => clientTokenType, 0],
			0,
			() => policyDescriptorListType,
			0,
			1
		]
	];
	AssumeRoleWithWebIdentityResponse = [
		3,
		n0$2,
		_ARWWIRs,
		0,
		[
			_C,
			_SFWIT,
			_ARU,
			_PPS,
			_Pr,
			_Au,
			_SI
		],
		[
			[() => Credentials, 0],
			0,
			() => AssumedRoleUser,
			1,
			0,
			0,
			0
		]
	];
	Credentials = [
		3,
		n0$2,
		_C,
		0,
		[
			_AKI,
			_SAK,
			_ST,
			_E
		],
		[
			0,
			[() => accessKeySecretType, 0],
			0,
			4
		]
	];
	ExpiredTokenException$3 = [
		-3,
		n0$2,
		_ETE$1,
		{
			[_e$2]: _c$2,
			[_hE$2]: 400,
			[_aQE]: [`ExpiredTokenException`, 400]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(ExpiredTokenException$3, ExpiredTokenException$2);
	IDPCommunicationErrorException$1 = [
		-3,
		n0$2,
		_IDPCEE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 400,
			[_aQE]: [`IDPCommunicationError`, 400]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(IDPCommunicationErrorException$1, IDPCommunicationErrorException);
	IDPRejectedClaimException$1 = [
		-3,
		n0$2,
		_IDPRCE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 403,
			[_aQE]: [`IDPRejectedClaim`, 403]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(IDPRejectedClaimException$1, IDPRejectedClaimException);
	InvalidIdentityTokenException$1 = [
		-3,
		n0$2,
		_IITE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 400,
			[_aQE]: [`InvalidIdentityToken`, 400]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(InvalidIdentityTokenException$1, InvalidIdentityTokenException);
	MalformedPolicyDocumentException$1 = [
		-3,
		n0$2,
		_MPDE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 400,
			[_aQE]: [`MalformedPolicyDocument`, 400]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(MalformedPolicyDocumentException$1, MalformedPolicyDocumentException);
	PackedPolicyTooLargeException$1 = [
		-3,
		n0$2,
		_PPTLE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 400,
			[_aQE]: [`PackedPolicyTooLarge`, 400]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(PackedPolicyTooLargeException$1, PackedPolicyTooLargeException);
	PolicyDescriptorType = [
		3,
		n0$2,
		_PDT,
		0,
		[_a],
		[0]
	];
	ProvidedContext = [
		3,
		n0$2,
		_PCr,
		0,
		[_PAr, _CA],
		[0, 0]
	];
	RegionDisabledException$1 = [
		-3,
		n0$2,
		_RDE,
		{
			[_e$2]: _c$2,
			[_hE$2]: 403,
			[_aQE]: [`RegionDisabledException`, 403]
		},
		[_m$1],
		[0]
	];
	TypeRegistry.for(n0$2).registerError(RegionDisabledException$1, RegionDisabledException);
	Tag = [
		3,
		n0$2,
		_Ta,
		0,
		[_K, _V],
		[0, 0]
	];
	STSServiceException$1 = [
		-3,
		_s$2,
		"STSServiceException",
		0,
		[],
		[]
	];
	TypeRegistry.for(_s$2).registerError(STSServiceException$1, STSServiceException);
	policyDescriptorListType = [
		1,
		n0$2,
		_pDLT,
		0,
		() => PolicyDescriptorType
	];
	ProvidedContextsListType = [
		1,
		n0$2,
		_PCLT,
		0,
		() => ProvidedContext
	];
	tagListType = [
		1,
		n0$2,
		_tLT,
		0,
		() => Tag
	];
	AssumeRole = [
		9,
		n0$2,
		_AR,
		0,
		() => AssumeRoleRequest,
		() => AssumeRoleResponse
	];
	AssumeRoleWithWebIdentity = [
		9,
		n0$2,
		_ARWWI,
		0,
		() => AssumeRoleWithWebIdentityRequest,
		() => AssumeRoleWithWebIdentityResponse
	];
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleCommand.js
var import_dist_cjs$73, import_dist_cjs$74, AssumeRoleCommand;
var init_AssumeRoleCommand = __esmMin((() => {
	import_dist_cjs$73 = require_dist_cjs$20();
	import_dist_cjs$74 = require_dist_cjs$28();
	init_EndpointParameters$2();
	init_schemas_0$2();
	AssumeRoleCommand = class extends import_dist_cjs$74.Command.classBuilder().ep(commonParams$2).m(function(Command$2, cs, config, o$5) {
		return [(0, import_dist_cjs$73.getEndpointPlugin)(config, Command$2.getEndpointParameterInstructions())];
	}).s("AWSSecurityTokenServiceV20110615", "AssumeRole", {}).n("STSClient", "AssumeRoleCommand").sc(AssumeRole).build() {};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/AssumeRoleWithWebIdentityCommand.js
var import_dist_cjs$71, import_dist_cjs$72, AssumeRoleWithWebIdentityCommand;
var init_AssumeRoleWithWebIdentityCommand = __esmMin((() => {
	import_dist_cjs$71 = require_dist_cjs$20();
	import_dist_cjs$72 = require_dist_cjs$28();
	init_EndpointParameters$2();
	init_schemas_0$2();
	AssumeRoleWithWebIdentityCommand = class extends import_dist_cjs$72.Command.classBuilder().ep(commonParams$2).m(function(Command$2, cs, config, o$5) {
		return [(0, import_dist_cjs$71.getEndpointPlugin)(config, Command$2.getEndpointParameterInstructions())];
	}).s("AWSSecurityTokenServiceV20110615", "AssumeRoleWithWebIdentity", {}).n("STSClient", "AssumeRoleWithWebIdentityCommand").sc(AssumeRoleWithWebIdentity).build() {};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/STS.js
var import_dist_cjs$70, commands$2, STS;
var init_STS = __esmMin((() => {
	import_dist_cjs$70 = require_dist_cjs$28();
	init_AssumeRoleCommand();
	init_AssumeRoleWithWebIdentityCommand();
	init_STSClient();
	commands$2 = {
		AssumeRoleCommand,
		AssumeRoleWithWebIdentityCommand
	};
	STS = class extends STSClient {};
	(0, import_dist_cjs$70.createAggregatedClient)(commands$2, STS);
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/commands/index.js
var init_commands$2 = __esmMin((() => {
	init_AssumeRoleCommand();
	init_AssumeRoleWithWebIdentityCommand();
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultStsRoleAssumers.js
var import_dist_cjs$69, getAccountIdFromAssumedRoleUser, resolveRegion, getDefaultRoleAssumer, getDefaultRoleAssumerWithWebIdentity, isH2;
var init_defaultStsRoleAssumers = __esmMin((() => {
	init_client();
	import_dist_cjs$69 = require_dist_cjs$10();
	init_AssumeRoleCommand();
	init_AssumeRoleWithWebIdentityCommand();
	getAccountIdFromAssumedRoleUser = (assumedRoleUser) => {
		if (typeof assumedRoleUser?.Arn === "string") {
			const arnComponents = assumedRoleUser.Arn.split(":");
			if (arnComponents.length > 4 && arnComponents[4] !== "") return arnComponents[4];
		}
	};
	resolveRegion = async (_region, _parentRegion, credentialProviderLogger, loaderConfig = {}) => {
		const region = typeof _region === "function" ? await _region() : _region;
		const parentRegion = typeof _parentRegion === "function" ? await _parentRegion() : _parentRegion;
		const stsDefaultRegion = await (0, import_dist_cjs$69.stsRegionDefaultResolver)(loaderConfig)();
		credentialProviderLogger?.debug?.("@aws-sdk/client-sts::resolveRegion", "accepting first of:", `${region} (credential provider clientConfig)`, `${parentRegion} (contextual client)`, `${stsDefaultRegion} (STS default: AWS_REGION, profile region, or us-east-1)`);
		return region ?? parentRegion ?? stsDefaultRegion;
	};
	getDefaultRoleAssumer = (stsOptions, STSClient$1) => {
		let stsClient;
		let closureSourceCreds;
		return async (sourceCreds, params) => {
			closureSourceCreds = sourceCreds;
			if (!stsClient) {
				const { logger: logger$1 = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
				const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
					logger: logger$1,
					profile
				});
				const isCompatibleRequestHandler = !isH2(requestHandler);
				stsClient = new STSClient$1({
					...stsOptions,
					userAgentAppId,
					profile,
					credentialDefaultProvider: () => async () => closureSourceCreds,
					region: resolvedRegion,
					requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
					logger: logger$1
				});
			}
			const { Credentials: Credentials$1, AssumedRoleUser: AssumedRoleUser$1 } = await stsClient.send(new AssumeRoleCommand(params));
			if (!Credentials$1 || !Credentials$1.AccessKeyId || !Credentials$1.SecretAccessKey) throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
			const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser$1);
			const credentials = {
				accessKeyId: Credentials$1.AccessKeyId,
				secretAccessKey: Credentials$1.SecretAccessKey,
				sessionToken: Credentials$1.SessionToken,
				expiration: Credentials$1.Expiration,
				...Credentials$1.CredentialScope && { credentialScope: Credentials$1.CredentialScope },
				...accountId && { accountId }
			};
			setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE", "i");
			return credentials;
		};
	};
	getDefaultRoleAssumerWithWebIdentity = (stsOptions, STSClient$1) => {
		let stsClient;
		return async (params) => {
			if (!stsClient) {
				const { logger: logger$1 = stsOptions?.parentClientConfig?.logger, profile = stsOptions?.parentClientConfig?.profile, region, requestHandler = stsOptions?.parentClientConfig?.requestHandler, credentialProviderLogger, userAgentAppId = stsOptions?.parentClientConfig?.userAgentAppId } = stsOptions;
				const resolvedRegion = await resolveRegion(region, stsOptions?.parentClientConfig?.region, credentialProviderLogger, {
					logger: logger$1,
					profile
				});
				const isCompatibleRequestHandler = !isH2(requestHandler);
				stsClient = new STSClient$1({
					...stsOptions,
					userAgentAppId,
					profile,
					region: resolvedRegion,
					requestHandler: isCompatibleRequestHandler ? requestHandler : void 0,
					logger: logger$1
				});
			}
			const { Credentials: Credentials$1, AssumedRoleUser: AssumedRoleUser$1 } = await stsClient.send(new AssumeRoleWithWebIdentityCommand(params));
			if (!Credentials$1 || !Credentials$1.AccessKeyId || !Credentials$1.SecretAccessKey) throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
			const accountId = getAccountIdFromAssumedRoleUser(AssumedRoleUser$1);
			const credentials = {
				accessKeyId: Credentials$1.AccessKeyId,
				secretAccessKey: Credentials$1.SecretAccessKey,
				sessionToken: Credentials$1.SessionToken,
				expiration: Credentials$1.Expiration,
				...Credentials$1.CredentialScope && { credentialScope: Credentials$1.CredentialScope },
				...accountId && { accountId }
			};
			if (accountId) setCredentialFeature(credentials, "RESOLVED_ACCOUNT_ID", "T");
			setCredentialFeature(credentials, "CREDENTIALS_STS_ASSUME_ROLE_WEB_ID", "k");
			return credentials;
		};
	};
	isH2 = (requestHandler) => {
		return requestHandler?.metadata?.handlerProtocol === "h2";
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/defaultRoleAssumers.js
var getCustomizableStsClientCtor, getDefaultRoleAssumer$1, getDefaultRoleAssumerWithWebIdentity$1, decorateDefaultCredentialProvider;
var init_defaultRoleAssumers = __esmMin((() => {
	init_defaultStsRoleAssumers();
	init_STSClient();
	getCustomizableStsClientCtor = (baseCtor, customizations) => {
		if (!customizations) return baseCtor;
		else return class CustomizableSTSClient extends baseCtor {
			constructor(config) {
				super(config);
				for (const customization of customizations) this.middlewareStack.use(customization);
			}
		};
	};
	getDefaultRoleAssumer$1 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumer(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
	getDefaultRoleAssumerWithWebIdentity$1 = (stsOptions = {}, stsPlugins) => getDefaultRoleAssumerWithWebIdentity(stsOptions, getCustomizableStsClientCtor(STSClient, stsPlugins));
	decorateDefaultCredentialProvider = (provider) => (input) => provider({
		roleAssumer: getDefaultRoleAssumer$1(input),
		roleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity$1(input),
		...input
	});
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sts/index.js
var sts_exports = /* @__PURE__ */ __export({
	AssumeRoleCommand: () => AssumeRoleCommand,
	AssumeRoleWithWebIdentityCommand: () => AssumeRoleWithWebIdentityCommand,
	ExpiredTokenException: () => ExpiredTokenException$2,
	IDPCommunicationErrorException: () => IDPCommunicationErrorException,
	IDPRejectedClaimException: () => IDPRejectedClaimException,
	InvalidIdentityTokenException: () => InvalidIdentityTokenException,
	MalformedPolicyDocumentException: () => MalformedPolicyDocumentException,
	PackedPolicyTooLargeException: () => PackedPolicyTooLargeException,
	RegionDisabledException: () => RegionDisabledException,
	STS: () => STS,
	STSClient: () => STSClient,
	STSServiceException: () => STSServiceException,
	__Client: () => import_dist_cjs$84.Client,
	decorateDefaultCredentialProvider: () => decorateDefaultCredentialProvider,
	getDefaultRoleAssumer: () => getDefaultRoleAssumer$1,
	getDefaultRoleAssumerWithWebIdentity: () => getDefaultRoleAssumerWithWebIdentity$1
});
var init_sts = __esmMin((() => {
	init_STSClient();
	init_STS();
	init_commands$2();
	init_errors$2();
	init_defaultRoleAssumers();
	init_STSServiceException();
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromWebToken.js
var require_fromWebToken = /* @__PURE__ */ __commonJSMin(((exports) => {
	var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		var desc = Object.getOwnPropertyDescriptor(m$5, k$5);
		if (!desc || ("get" in desc ? !m$5.__esModule : desc.writable || desc.configurable)) desc = {
			enumerable: true,
			get: function() {
				return m$5[k$5];
			}
		};
		Object.defineProperty(o$5, k2, desc);
	}) : (function(o$5, m$5, k$5, k2) {
		if (k2 === void 0) k2 = k$5;
		o$5[k2] = m$5[k$5];
	}));
	var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o$5, v$5) {
		Object.defineProperty(o$5, "default", {
			enumerable: true,
			value: v$5
		});
	}) : function(o$5, v$5) {
		o$5["default"] = v$5;
	});
	var __importStar = exports && exports.__importStar || (function() {
		var ownKeys$1 = function(o$5) {
			ownKeys$1 = Object.getOwnPropertyNames || function(o$6) {
				var ar = [];
				for (var k$5 in o$6) if (Object.prototype.hasOwnProperty.call(o$6, k$5)) ar[ar.length] = k$5;
				return ar;
			};
			return ownKeys$1(o$5);
		};
		return function(mod) {
			if (mod && mod.__esModule) return mod;
			var result = {};
			if (mod != null) {
				for (var k$5 = ownKeys$1(mod), i$5 = 0; i$5 < k$5.length; i$5++) if (k$5[i$5] !== "default") __createBinding(result, mod, k$5[i$5]);
			}
			__setModuleDefault(result, mod);
			return result;
		};
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromWebToken = void 0;
	const fromWebToken$1 = (init) => async (awsIdentityProperties) => {
		init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromWebToken");
		const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds } = init;
		let { roleAssumerWithWebIdentity } = init;
		if (!roleAssumerWithWebIdentity) {
			const { getDefaultRoleAssumerWithWebIdentity: getDefaultRoleAssumerWithWebIdentity$2 } = await Promise.resolve().then(() => __importStar((init_sts(), __toCommonJS(sts_exports))));
			roleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity$2({
				...init.clientConfig,
				credentialProviderLogger: init.logger,
				parentClientConfig: {
					...awsIdentityProperties?.callerClientConfig,
					...init.parentClientConfig
				}
			}, init.clientPlugins);
		}
		return roleAssumerWithWebIdentity({
			RoleArn: roleArn,
			RoleSessionName: roleSessionName ?? `aws-sdk-js-session-${Date.now()}`,
			WebIdentityToken: webIdentityToken,
			ProviderId: providerId,
			PolicyArns: policyArns,
			Policy: policy,
			DurationSeconds: durationSeconds
		});
	};
	exports.fromWebToken = fromWebToken$1;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/fromTokenFile.js
var require_fromTokenFile = /* @__PURE__ */ __commonJSMin(((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.fromTokenFile = void 0;
	const client_1 = (init_client(), __toCommonJS(client_exports));
	const property_provider_1 = require_dist_cjs$31();
	const shared_ini_file_loader_1 = require_dist_cjs$22();
	const fs_1 = __require("fs");
	const fromWebToken_1 = require_fromWebToken();
	const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
	const ENV_ROLE_ARN = "AWS_ROLE_ARN";
	const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
	const fromTokenFile$1 = (init = {}) => async (awsIdentityProperties) => {
		init.logger?.debug("@aws-sdk/credential-provider-web-identity - fromTokenFile");
		const webIdentityTokenFile = init?.webIdentityTokenFile ?? process.env[ENV_TOKEN_FILE];
		const roleArn = init?.roleArn ?? process.env[ENV_ROLE_ARN];
		const roleSessionName = init?.roleSessionName ?? process.env[ENV_ROLE_SESSION_NAME];
		if (!webIdentityTokenFile || !roleArn) throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified", { logger: init.logger });
		const credentials = await (0, fromWebToken_1.fromWebToken)({
			...init,
			webIdentityToken: shared_ini_file_loader_1.externalDataInterceptor?.getTokenRecord?.()[webIdentityTokenFile] ?? (0, fs_1.readFileSync)(webIdentityTokenFile, { encoding: "ascii" }),
			roleArn,
			roleSessionName
		})(awsIdentityProperties);
		if (webIdentityTokenFile === process.env[ENV_TOKEN_FILE]) (0, client_1.setCredentialFeature)(credentials, "CREDENTIALS_ENV_VARS_STS_WEB_ID_TOKEN", "h");
		return credentials;
	};
	exports.fromTokenFile = fromTokenFile$1;
}));

//#endregion
//#region node_modules/@aws-sdk/credential-provider-web-identity/dist-cjs/index.js
var require_dist_cjs$1 = /* @__PURE__ */ __commonJSMin(((exports) => {
	var fromTokenFile = require_fromTokenFile();
	var fromWebToken = require_fromWebToken();
	Object.keys(fromTokenFile).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return fromTokenFile[k$5];
			}
		});
	});
	Object.keys(fromWebToken).forEach(function(k$5) {
		if (k$5 !== "default" && !Object.prototype.hasOwnProperty.call(exports, k$5)) Object.defineProperty(exports, k$5, {
			enumerable: true,
			get: function() {
				return fromWebToken[k$5];
			}
		});
	});
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption$1(authParameters) {
	return {
		schemeId: "aws.auth#sigv4",
		signingProperties: {
			name: "signin",
			region: authParameters.region
		},
		propertiesExtractor: (config, context) => ({ signingProperties: {
			config,
			context
		} })
	};
}
function createSmithyApiNoAuthHttpAuthOption$1(authParameters) {
	return { schemeId: "smithy.api#noAuth" };
}
var import_dist_cjs$68, defaultSigninHttpAuthSchemeParametersProvider, defaultSigninHttpAuthSchemeProvider, resolveHttpAuthSchemeConfig$1;
var init_httpAuthSchemeProvider$1 = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$68 = require_dist_cjs$48();
	defaultSigninHttpAuthSchemeParametersProvider = async (config, context, input) => {
		return {
			operation: (0, import_dist_cjs$68.getSmithyContext)(context).operation,
			region: await (0, import_dist_cjs$68.normalizeProvider)(config.region)() || (() => {
				throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
			})()
		};
	};
	defaultSigninHttpAuthSchemeProvider = (authParameters) => {
		const options = [];
		switch (authParameters.operation) {
			case "CreateOAuth2Token":
				options.push(createSmithyApiNoAuthHttpAuthOption$1(authParameters));
				break;
			default: options.push(createAwsAuthSigv4HttpAuthOption$1(authParameters));
		}
		return options;
	};
	resolveHttpAuthSchemeConfig$1 = (config) => {
		const config_0 = resolveAwsSdkSigV4Config(config);
		return Object.assign(config_0, { authSchemePreference: (0, import_dist_cjs$68.normalizeProvider)(config.authSchemePreference ?? []) });
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/EndpointParameters.js
var resolveClientEndpointParameters$1, commonParams$1;
var init_EndpointParameters$1 = __esmMin((() => {
	resolveClientEndpointParameters$1 = (options) => {
		return Object.assign(options, {
			useDualstackEndpoint: options.useDualstackEndpoint ?? false,
			useFipsEndpoint: options.useFipsEndpoint ?? false,
			defaultSigningName: "signin"
		});
	};
	commonParams$1 = {
		UseFIPS: {
			type: "builtInParams",
			name: "useFipsEndpoint"
		},
		Endpoint: {
			type: "builtInParams",
			name: "endpoint"
		},
		Region: {
			type: "builtInParams",
			name: "region"
		},
		UseDualStack: {
			type: "builtInParams",
			name: "useDualstackEndpoint"
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/ruleset.js
var u$1, v$1, w$1, x$1, a$1, b$1, c$1, d$1, e$1, f$1, g$1, h$1, i$1, j$1, k$1, l$1, m$1, n$1, o$1, p$1, q$1, r$1, s$1, t$1, _data$1, ruleSet$1;
var init_ruleset$1 = __esmMin((() => {
	u$1 = "required", v$1 = "fn", w$1 = "argv", x$1 = "ref";
	a$1 = true, b$1 = "isSet", c$1 = "booleanEquals", d$1 = "error", e$1 = "endpoint", f$1 = "tree", g$1 = "PartitionResult", h$1 = "stringEquals", i$1 = {
		[u$1]: true,
		"default": false,
		"type": "boolean"
	}, j$1 = {
		[u$1]: false,
		"type": "string"
	}, k$1 = { [x$1]: "Endpoint" }, l$1 = {
		[v$1]: c$1,
		[w$1]: [{ [x$1]: "UseFIPS" }, true]
	}, m$1 = {
		[v$1]: c$1,
		[w$1]: [{ [x$1]: "UseDualStack" }, true]
	}, n$1 = {}, o$1 = {
		[v$1]: "getAttr",
		[w$1]: [{ [x$1]: g$1 }, "name"]
	}, p$1 = {
		[v$1]: c$1,
		[w$1]: [{ [x$1]: "UseFIPS" }, false]
	}, q$1 = {
		[v$1]: c$1,
		[w$1]: [{ [x$1]: "UseDualStack" }, false]
	}, r$1 = {
		[v$1]: "getAttr",
		[w$1]: [{ [x$1]: g$1 }, "supportsFIPS"]
	}, s$1 = {
		[v$1]: c$1,
		[w$1]: [true, {
			[v$1]: "getAttr",
			[w$1]: [{ [x$1]: g$1 }, "supportsDualStack"]
		}]
	}, t$1 = [{ [x$1]: "Region" }];
	_data$1 = {
		version: "1.0",
		parameters: {
			UseDualStack: i$1,
			UseFIPS: i$1,
			Endpoint: j$1,
			Region: j$1
		},
		rules: [{
			conditions: [{
				[v$1]: b$1,
				[w$1]: [k$1]
			}],
			rules: [{
				conditions: [l$1],
				error: "Invalid Configuration: FIPS and custom endpoint are not supported",
				type: d$1
			}, {
				rules: [{
					conditions: [m$1],
					error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
					type: d$1
				}, {
					endpoint: {
						url: k$1,
						properties: n$1,
						headers: n$1
					},
					type: e$1
				}],
				type: f$1
			}],
			type: f$1
		}, {
			rules: [{
				conditions: [{
					[v$1]: b$1,
					[w$1]: t$1
				}],
				rules: [{
					conditions: [{
						[v$1]: "aws.partition",
						[w$1]: t$1,
						assign: g$1
					}],
					rules: [
						{
							conditions: [
								{
									[v$1]: h$1,
									[w$1]: [o$1, "aws"]
								},
								p$1,
								q$1
							],
							endpoint: {
								url: "https://{Region}.signin.aws.amazon.com",
								properties: n$1,
								headers: n$1
							},
							type: e$1
						},
						{
							conditions: [
								{
									[v$1]: h$1,
									[w$1]: [o$1, "aws-cn"]
								},
								p$1,
								q$1
							],
							endpoint: {
								url: "https://{Region}.signin.amazonaws.cn",
								properties: n$1,
								headers: n$1
							},
							type: e$1
						},
						{
							conditions: [
								{
									[v$1]: h$1,
									[w$1]: [o$1, "aws-us-gov"]
								},
								p$1,
								q$1
							],
							endpoint: {
								url: "https://{Region}.signin.amazonaws-us-gov.com",
								properties: n$1,
								headers: n$1
							},
							type: e$1
						},
						{
							conditions: [l$1, m$1],
							rules: [{
								conditions: [{
									[v$1]: c$1,
									[w$1]: [a$1, r$1]
								}, s$1],
								rules: [{
									endpoint: {
										url: "https://signin-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n$1,
										headers: n$1
									},
									type: e$1
								}],
								type: f$1
							}, {
								error: "FIPS and DualStack are enabled, but this partition does not support one or both",
								type: d$1
							}],
							type: f$1
						},
						{
							conditions: [l$1, q$1],
							rules: [{
								conditions: [{
									[v$1]: c$1,
									[w$1]: [r$1, a$1]
								}],
								rules: [{
									endpoint: {
										url: "https://signin-fips.{Region}.{PartitionResult#dnsSuffix}",
										properties: n$1,
										headers: n$1
									},
									type: e$1
								}],
								type: f$1
							}, {
								error: "FIPS is enabled but this partition does not support FIPS",
								type: d$1
							}],
							type: f$1
						},
						{
							conditions: [p$1, m$1],
							rules: [{
								conditions: [s$1],
								rules: [{
									endpoint: {
										url: "https://signin.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n$1,
										headers: n$1
									},
									type: e$1
								}],
								type: f$1
							}, {
								error: "DualStack is enabled but this partition does not support DualStack",
								type: d$1
							}],
							type: f$1
						},
						{
							endpoint: {
								url: "https://signin.{Region}.{PartitionResult#dnsSuffix}",
								properties: n$1,
								headers: n$1
							},
							type: e$1
						}
					],
					type: f$1
				}],
				type: f$1
			}, {
				error: "Invalid Configuration: Missing Region",
				type: d$1
			}],
			type: f$1
		}]
	};
	ruleSet$1 = _data$1;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/endpoint/endpointResolver.js
var import_dist_cjs$66, import_dist_cjs$67, cache$1, defaultEndpointResolver$1;
var init_endpointResolver$1 = __esmMin((() => {
	import_dist_cjs$66 = require_dist_cjs$32();
	import_dist_cjs$67 = require_dist_cjs$35();
	init_ruleset$1();
	cache$1 = new import_dist_cjs$67.EndpointCache({
		size: 50,
		params: [
			"Endpoint",
			"Region",
			"UseDualStack",
			"UseFIPS"
		]
	});
	defaultEndpointResolver$1 = (endpointParams, context = {}) => {
		return cache$1.get(endpointParams, () => (0, import_dist_cjs$67.resolveEndpoint)(ruleSet$1, {
			endpointParams,
			logger: context.logger
		}));
	};
	import_dist_cjs$67.customEndpointFunctions.aws = import_dist_cjs$66.awsEndpointFunctions;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.shared.js
var import_dist_cjs$62, import_dist_cjs$63, import_dist_cjs$64, import_dist_cjs$65, getRuntimeConfig$3;
var init_runtimeConfig_shared$1 = __esmMin((() => {
	init_dist_es();
	init_protocols();
	init_dist_es$1();
	import_dist_cjs$62 = require_dist_cjs$28();
	import_dist_cjs$63 = require_dist_cjs$33();
	import_dist_cjs$64 = require_dist_cjs$43();
	import_dist_cjs$65 = require_dist_cjs$44();
	init_httpAuthSchemeProvider$1();
	init_endpointResolver$1();
	getRuntimeConfig$3 = (config) => {
		return {
			apiVersion: "2023-01-01",
			base64Decoder: config?.base64Decoder ?? import_dist_cjs$64.fromBase64,
			base64Encoder: config?.base64Encoder ?? import_dist_cjs$64.toBase64,
			disableHostPrefix: config?.disableHostPrefix ?? false,
			endpointProvider: config?.endpointProvider ?? defaultEndpointResolver$1,
			extensions: config?.extensions ?? [],
			httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSigninHttpAuthSchemeProvider,
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
				signer: new AwsSdkSigV4Signer()
			}, {
				schemeId: "smithy.api#noAuth",
				identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
				signer: new NoAuthSigner()
			}],
			logger: config?.logger ?? new import_dist_cjs$62.NoOpLogger(),
			protocol: config?.protocol ?? new AwsRestJsonProtocol({ defaultNamespace: "com.amazonaws.signin" }),
			serviceId: config?.serviceId ?? "Signin",
			urlParser: config?.urlParser ?? import_dist_cjs$63.parseUrl,
			utf8Decoder: config?.utf8Decoder ?? import_dist_cjs$65.fromUtf8,
			utf8Encoder: config?.utf8Encoder ?? import_dist_cjs$65.toUtf8
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeConfig.js
var import_dist_cjs$51, import_dist_cjs$52, import_dist_cjs$53, import_dist_cjs$54, import_dist_cjs$55, import_dist_cjs$56, import_dist_cjs$57, import_dist_cjs$58, import_dist_cjs$59, import_dist_cjs$60, import_dist_cjs$61, getRuntimeConfig$2;
var init_runtimeConfig$1 = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$51 = require_dist_cjs$14();
	import_dist_cjs$52 = require_dist_cjs$24();
	import_dist_cjs$53 = require_dist_cjs$13();
	import_dist_cjs$54 = require_dist_cjs$17();
	import_dist_cjs$55 = require_dist_cjs$21();
	import_dist_cjs$56 = require_dist_cjs$40();
	import_dist_cjs$57 = require_dist_cjs$12();
	import_dist_cjs$58 = require_dist_cjs$18();
	init_runtimeConfig_shared$1();
	import_dist_cjs$59 = require_dist_cjs$28();
	import_dist_cjs$60 = require_dist_cjs$11();
	import_dist_cjs$61 = require_dist_cjs$28();
	getRuntimeConfig$2 = (config) => {
		(0, import_dist_cjs$61.emitWarningIfUnsupportedVersion)(process.version);
		const defaultsMode = (0, import_dist_cjs$60.resolveDefaultsModeConfig)(config);
		const defaultConfigProvider = () => defaultsMode().then(import_dist_cjs$59.loadConfigsForDefaultMode);
		const clientSharedValues = getRuntimeConfig$3(config);
		emitWarningIfUnsupportedVersion(process.version);
		const loaderConfig = {
			profile: config?.profile,
			logger: clientSharedValues.logger
		};
		return {
			...clientSharedValues,
			...config,
			runtime: "node",
			defaultsMode,
			authSchemePreference: config?.authSchemePreference ?? (0, import_dist_cjs$55.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
			bodyLengthChecker: config?.bodyLengthChecker ?? import_dist_cjs$57.calculateBodyLength,
			defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_dist_cjs$51.createDefaultUserAgentProvider)({
				serviceId: clientSharedValues.serviceId,
				clientVersion: version
			}),
			maxAttempts: config?.maxAttempts ?? (0, import_dist_cjs$55.loadConfig)(import_dist_cjs$54.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
			region: config?.region ?? (0, import_dist_cjs$55.loadConfig)(import_dist_cjs$52.NODE_REGION_CONFIG_OPTIONS, {
				...import_dist_cjs$52.NODE_REGION_CONFIG_FILE_OPTIONS,
				...loaderConfig
			}),
			requestHandler: import_dist_cjs$56.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
			retryMode: config?.retryMode ?? (0, import_dist_cjs$55.loadConfig)({
				...import_dist_cjs$54.NODE_RETRY_MODE_CONFIG_OPTIONS,
				default: async () => (await defaultConfigProvider()).retryMode || import_dist_cjs$58.DEFAULT_RETRY_MODE
			}, config),
			sha256: config?.sha256 ?? import_dist_cjs$53.Hash.bind(null, "sha256"),
			streamCollector: config?.streamCollector ?? import_dist_cjs$56.streamCollector,
			useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_dist_cjs$55.loadConfig)(import_dist_cjs$52.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_dist_cjs$55.loadConfig)(import_dist_cjs$52.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			userAgentAppId: config?.userAgentAppId ?? (0, import_dist_cjs$55.loadConfig)(import_dist_cjs$51.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration$1, resolveHttpAuthRuntimeConfig$1;
var init_httpAuthExtensionConfiguration$1 = __esmMin((() => {
	getHttpAuthExtensionConfiguration$1 = (runtimeConfig$2) => {
		const _httpAuthSchemes = runtimeConfig$2.httpAuthSchemes;
		let _httpAuthSchemeProvider = runtimeConfig$2.httpAuthSchemeProvider;
		let _credentials = runtimeConfig$2.credentials;
		return {
			setHttpAuthScheme(httpAuthScheme) {
				const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
				if (index === -1) _httpAuthSchemes.push(httpAuthScheme);
				else _httpAuthSchemes.splice(index, 1, httpAuthScheme);
			},
			httpAuthSchemes() {
				return _httpAuthSchemes;
			},
			setHttpAuthSchemeProvider(httpAuthSchemeProvider$2) {
				_httpAuthSchemeProvider = httpAuthSchemeProvider$2;
			},
			httpAuthSchemeProvider() {
				return _httpAuthSchemeProvider;
			},
			setCredentials(credentials) {
				_credentials = credentials;
			},
			credentials() {
				return _credentials;
			}
		};
	};
	resolveHttpAuthRuntimeConfig$1 = (config) => {
		return {
			httpAuthSchemes: config.httpAuthSchemes(),
			httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
			credentials: config.credentials()
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/runtimeExtensions.js
var import_dist_cjs$48, import_dist_cjs$49, import_dist_cjs$50, resolveRuntimeExtensions$1;
var init_runtimeExtensions$1 = __esmMin((() => {
	import_dist_cjs$48 = require_dist_cjs$10();
	import_dist_cjs$49 = require_dist_cjs$52();
	import_dist_cjs$50 = require_dist_cjs$28();
	init_httpAuthExtensionConfiguration$1();
	resolveRuntimeExtensions$1 = (runtimeConfig$2, extensions) => {
		const extensionConfiguration = Object.assign((0, import_dist_cjs$48.getAwsRegionExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$50.getDefaultExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$49.getHttpHandlerExtensionConfiguration)(runtimeConfig$2), getHttpAuthExtensionConfiguration$1(runtimeConfig$2));
		extensions.forEach((extension) => extension.configure(extensionConfiguration));
		return Object.assign(runtimeConfig$2, (0, import_dist_cjs$48.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_dist_cjs$50.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_dist_cjs$49.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig$1(extensionConfiguration));
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/SigninClient.js
var import_dist_cjs$39, import_dist_cjs$40, import_dist_cjs$41, import_dist_cjs$42, import_dist_cjs$43, import_dist_cjs$44, import_dist_cjs$45, import_dist_cjs$46, import_dist_cjs$47, SigninClient;
var init_SigninClient = __esmMin((() => {
	import_dist_cjs$39 = require_dist_cjs$51();
	import_dist_cjs$40 = require_dist_cjs$50();
	import_dist_cjs$41 = require_dist_cjs$49();
	import_dist_cjs$42 = require_dist_cjs$26();
	import_dist_cjs$43 = require_dist_cjs$24();
	init_dist_es$1();
	init_schema();
	import_dist_cjs$44 = require_dist_cjs$23();
	import_dist_cjs$45 = require_dist_cjs$20();
	import_dist_cjs$46 = require_dist_cjs$17();
	import_dist_cjs$47 = require_dist_cjs$28();
	init_httpAuthSchemeProvider$1();
	init_EndpointParameters$1();
	init_runtimeConfig$1();
	init_runtimeExtensions$1();
	SigninClient = class extends import_dist_cjs$47.Client {
		config;
		constructor(...[configuration]) {
			const _config_0 = getRuntimeConfig$2(configuration || {});
			super(_config_0);
			this.initConfig = _config_0;
			this.config = resolveRuntimeExtensions$1(resolveHttpAuthSchemeConfig$1((0, import_dist_cjs$45.resolveEndpointConfig)((0, import_dist_cjs$39.resolveHostHeaderConfig)((0, import_dist_cjs$43.resolveRegionConfig)((0, import_dist_cjs$46.resolveRetryConfig)((0, import_dist_cjs$42.resolveUserAgentConfig)(resolveClientEndpointParameters$1(_config_0))))))), configuration?.extensions || []);
			this.middlewareStack.use(getSchemaSerdePlugin(this.config));
			this.middlewareStack.use((0, import_dist_cjs$42.getUserAgentPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$46.getRetryPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$44.getContentLengthPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$39.getHostHeaderPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$40.getLoggerPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$41.getRecursionDetectionPlugin)(this.config));
			this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
				httpAuthSchemeParametersProvider: defaultSigninHttpAuthSchemeParametersProvider,
				identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({ "aws.auth#sigv4": config.credentials })
			}));
			this.middlewareStack.use(getHttpSigningPlugin(this.config));
		}
		destroy() {
			super.destroy();
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/SigninServiceException.js
var import_dist_cjs$38, SigninServiceException;
var init_SigninServiceException = __esmMin((() => {
	import_dist_cjs$38 = require_dist_cjs$28();
	SigninServiceException = class SigninServiceException extends import_dist_cjs$38.ServiceException {
		constructor(options) {
			super(options);
			Object.setPrototypeOf(this, SigninServiceException.prototype);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/errors.js
var AccessDeniedException$2, InternalServerException$2, TooManyRequestsError, ValidationException;
var init_errors$1 = __esmMin((() => {
	init_SigninServiceException();
	AccessDeniedException$2 = class AccessDeniedException$2 extends SigninServiceException {
		name = "AccessDeniedException";
		$fault = "client";
		error;
		constructor(opts) {
			super({
				name: "AccessDeniedException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, AccessDeniedException$2.prototype);
			this.error = opts.error;
		}
	};
	InternalServerException$2 = class InternalServerException$2 extends SigninServiceException {
		name = "InternalServerException";
		$fault = "server";
		error;
		constructor(opts) {
			super({
				name: "InternalServerException",
				$fault: "server",
				...opts
			});
			Object.setPrototypeOf(this, InternalServerException$2.prototype);
			this.error = opts.error;
		}
	};
	TooManyRequestsError = class TooManyRequestsError extends SigninServiceException {
		name = "TooManyRequestsError";
		$fault = "client";
		error;
		constructor(opts) {
			super({
				name: "TooManyRequestsError",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, TooManyRequestsError.prototype);
			this.error = opts.error;
		}
	};
	ValidationException = class ValidationException extends SigninServiceException {
		name = "ValidationException";
		$fault = "client";
		error;
		constructor(opts) {
			super({
				name: "ValidationException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ValidationException.prototype);
			this.error = opts.error;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/schemas/schemas_0.js
var _ADE$1, _AT$1, _COAT, _COATR, _COATRB, _COATRBr, _COATRr, _ISE$1, _RT$1, _TMRE, _VE, _aKI, _aT$1, _c$1, _cI$1, _cV$1, _co$1, _e$1, _eI$1, _gT$1, _h$1, _hE$1, _iT$1, _jN, _m, _rT$1, _rU$1, _s$1, _sAK, _sT, _sm$1, _tI, _tO, _tT$1, n0$1, RefreshToken$1, AccessDeniedException$3, AccessToken$1, CreateOAuth2TokenRequest, CreateOAuth2TokenRequestBody, CreateOAuth2TokenResponse, CreateOAuth2TokenResponseBody, InternalServerException$3, TooManyRequestsError$1, ValidationException$1, SigninServiceException$1, CreateOAuth2Token;
var init_schemas_0$1 = __esmMin((() => {
	init_schema();
	init_errors$1();
	init_SigninServiceException();
	_ADE$1 = "AccessDeniedException";
	_AT$1 = "AccessToken";
	_COAT = "CreateOAuth2Token";
	_COATR = "CreateOAuth2TokenRequest";
	_COATRB = "CreateOAuth2TokenRequestBody";
	_COATRBr = "CreateOAuth2TokenResponseBody";
	_COATRr = "CreateOAuth2TokenResponse";
	_ISE$1 = "InternalServerException";
	_RT$1 = "RefreshToken";
	_TMRE = "TooManyRequestsError";
	_VE = "ValidationException";
	_aKI = "accessKeyId";
	_aT$1 = "accessToken";
	_c$1 = "client";
	_cI$1 = "clientId";
	_cV$1 = "codeVerifier";
	_co$1 = "code";
	_e$1 = "error";
	_eI$1 = "expiresIn";
	_gT$1 = "grantType";
	_h$1 = "http";
	_hE$1 = "httpError";
	_iT$1 = "idToken";
	_jN = "jsonName";
	_m = "message";
	_rT$1 = "refreshToken";
	_rU$1 = "redirectUri";
	_s$1 = "server";
	_sAK = "secretAccessKey";
	_sT = "sessionToken";
	_sm$1 = "smithy.ts.sdk.synthetic.com.amazonaws.signin";
	_tI = "tokenInput";
	_tO = "tokenOutput";
	_tT$1 = "tokenType";
	n0$1 = "com.amazonaws.signin";
	RefreshToken$1 = [
		0,
		n0$1,
		_RT$1,
		8,
		0
	];
	AccessDeniedException$3 = [
		-3,
		n0$1,
		_ADE$1,
		{ [_e$1]: _c$1 },
		[_e$1, _m],
		[0, 0]
	];
	TypeRegistry.for(n0$1).registerError(AccessDeniedException$3, AccessDeniedException$2);
	AccessToken$1 = [
		3,
		n0$1,
		_AT$1,
		8,
		[
			_aKI,
			_sAK,
			_sT
		],
		[
			[0, { [_jN]: _aKI }],
			[0, { [_jN]: _sAK }],
			[0, { [_jN]: _sT }]
		]
	];
	CreateOAuth2TokenRequest = [
		3,
		n0$1,
		_COATR,
		0,
		[_tI],
		[[() => CreateOAuth2TokenRequestBody, 16]]
	];
	CreateOAuth2TokenRequestBody = [
		3,
		n0$1,
		_COATRB,
		0,
		[
			_cI$1,
			_gT$1,
			_co$1,
			_rU$1,
			_cV$1,
			_rT$1
		],
		[
			[0, { [_jN]: _cI$1 }],
			[0, { [_jN]: _gT$1 }],
			0,
			[0, { [_jN]: _rU$1 }],
			[0, { [_jN]: _cV$1 }],
			[() => RefreshToken$1, { [_jN]: _rT$1 }]
		]
	];
	CreateOAuth2TokenResponse = [
		3,
		n0$1,
		_COATRr,
		0,
		[_tO],
		[[() => CreateOAuth2TokenResponseBody, 16]]
	];
	CreateOAuth2TokenResponseBody = [
		3,
		n0$1,
		_COATRBr,
		0,
		[
			_aT$1,
			_tT$1,
			_eI$1,
			_rT$1,
			_iT$1
		],
		[
			[() => AccessToken$1, { [_jN]: _aT$1 }],
			[0, { [_jN]: _tT$1 }],
			[1, { [_jN]: _eI$1 }],
			[() => RefreshToken$1, { [_jN]: _rT$1 }],
			[0, { [_jN]: _iT$1 }]
		]
	];
	InternalServerException$3 = [
		-3,
		n0$1,
		_ISE$1,
		{
			[_e$1]: _s$1,
			[_hE$1]: 500
		},
		[_e$1, _m],
		[0, 0]
	];
	TypeRegistry.for(n0$1).registerError(InternalServerException$3, InternalServerException$2);
	TooManyRequestsError$1 = [
		-3,
		n0$1,
		_TMRE,
		{
			[_e$1]: _c$1,
			[_hE$1]: 429
		},
		[_e$1, _m],
		[0, 0]
	];
	TypeRegistry.for(n0$1).registerError(TooManyRequestsError$1, TooManyRequestsError);
	ValidationException$1 = [
		-3,
		n0$1,
		_VE,
		{
			[_e$1]: _c$1,
			[_hE$1]: 400
		},
		[_e$1, _m],
		[0, 0]
	];
	TypeRegistry.for(n0$1).registerError(ValidationException$1, ValidationException);
	SigninServiceException$1 = [
		-3,
		_sm$1,
		"SigninServiceException",
		0,
		[],
		[]
	];
	TypeRegistry.for(_sm$1).registerError(SigninServiceException$1, SigninServiceException);
	CreateOAuth2Token = [
		9,
		n0$1,
		_COAT,
		{ [_h$1]: [
			"POST",
			"/v1/token",
			200
		] },
		() => CreateOAuth2TokenRequest,
		() => CreateOAuth2TokenResponse
	];
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/CreateOAuth2TokenCommand.js
var import_dist_cjs$36, import_dist_cjs$37, CreateOAuth2TokenCommand;
var init_CreateOAuth2TokenCommand = __esmMin((() => {
	import_dist_cjs$36 = require_dist_cjs$20();
	import_dist_cjs$37 = require_dist_cjs$28();
	init_EndpointParameters$1();
	init_schemas_0$1();
	CreateOAuth2TokenCommand = class extends import_dist_cjs$37.Command.classBuilder().ep(commonParams$1).m(function(Command$2, cs, config, o$5) {
		return [(0, import_dist_cjs$36.getEndpointPlugin)(config, Command$2.getEndpointParameterInstructions())];
	}).s("Signin", "CreateOAuth2Token", {}).n("SigninClient", "CreateOAuth2TokenCommand").sc(CreateOAuth2Token).build() {};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/Signin.js
var import_dist_cjs$35, commands$1, Signin;
var init_Signin = __esmMin((() => {
	import_dist_cjs$35 = require_dist_cjs$28();
	init_CreateOAuth2TokenCommand();
	init_SigninClient();
	commands$1 = { CreateOAuth2TokenCommand };
	Signin = class extends SigninClient {};
	(0, import_dist_cjs$35.createAggregatedClient)(commands$1, Signin);
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/commands/index.js
var init_commands$1 = __esmMin((() => {
	init_CreateOAuth2TokenCommand();
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/models/enums.js
var init_enums$1 = __esmMin((() => {}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/signin/index.js
var init_signin = __esmMin((() => {
	init_SigninClient();
	init_Signin();
	init_commands$1();
	init_enums$1();
	init_errors$1();
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthSchemeProvider.js
function createAwsAuthSigv4HttpAuthOption(authParameters) {
	return {
		schemeId: "aws.auth#sigv4",
		signingProperties: {
			name: "sso-oauth",
			region: authParameters.region
		},
		propertiesExtractor: (config, context) => ({ signingProperties: {
			config,
			context
		} })
	};
}
function createSmithyApiNoAuthHttpAuthOption(authParameters) {
	return { schemeId: "smithy.api#noAuth" };
}
var import_dist_cjs$34, defaultSSOOIDCHttpAuthSchemeParametersProvider, defaultSSOOIDCHttpAuthSchemeProvider, resolveHttpAuthSchemeConfig;
var init_httpAuthSchemeProvider = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$34 = require_dist_cjs$48();
	defaultSSOOIDCHttpAuthSchemeParametersProvider = async (config, context, input) => {
		return {
			operation: (0, import_dist_cjs$34.getSmithyContext)(context).operation,
			region: await (0, import_dist_cjs$34.normalizeProvider)(config.region)() || (() => {
				throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
			})()
		};
	};
	defaultSSOOIDCHttpAuthSchemeProvider = (authParameters) => {
		const options = [];
		switch (authParameters.operation) {
			case "CreateToken":
				options.push(createSmithyApiNoAuthHttpAuthOption(authParameters));
				break;
			default: options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
		}
		return options;
	};
	resolveHttpAuthSchemeConfig = (config) => {
		const config_0 = resolveAwsSdkSigV4Config(config);
		return Object.assign(config_0, { authSchemePreference: (0, import_dist_cjs$34.normalizeProvider)(config.authSchemePreference ?? []) });
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/EndpointParameters.js
var resolveClientEndpointParameters, commonParams;
var init_EndpointParameters = __esmMin((() => {
	resolveClientEndpointParameters = (options) => {
		return Object.assign(options, {
			useDualstackEndpoint: options.useDualstackEndpoint ?? false,
			useFipsEndpoint: options.useFipsEndpoint ?? false,
			defaultSigningName: "sso-oauth"
		});
	};
	commonParams = {
		UseFIPS: {
			type: "builtInParams",
			name: "useFipsEndpoint"
		},
		Endpoint: {
			type: "builtInParams",
			name: "endpoint"
		},
		Region: {
			type: "builtInParams",
			name: "region"
		},
		UseDualStack: {
			type: "builtInParams",
			name: "useDualstackEndpoint"
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/ruleset.js
var u, v, w, x, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, _data, ruleSet;
var init_ruleset = __esmMin((() => {
	u = "required", v = "fn", w = "argv", x = "ref";
	a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = {
		[u]: false,
		"type": "string"
	}, j = {
		[u]: true,
		"default": false,
		"type": "boolean"
	}, k = { [x]: "Endpoint" }, l = {
		[v]: c,
		[w]: [{ [x]: "UseFIPS" }, true]
	}, m = {
		[v]: c,
		[w]: [{ [x]: "UseDualStack" }, true]
	}, n = {}, o = {
		[v]: h,
		[w]: [{ [x]: g }, "supportsFIPS"]
	}, p = { [x]: g }, q = {
		[v]: c,
		[w]: [true, {
			[v]: h,
			[w]: [p, "supportsDualStack"]
		}]
	}, r = [l], s = [m], t = [{ [x]: "Region" }];
	_data = {
		version: "1.0",
		parameters: {
			Region: i,
			UseDualStack: j,
			UseFIPS: j,
			Endpoint: i
		},
		rules: [
			{
				conditions: [{
					[v]: b,
					[w]: [k]
				}],
				rules: [
					{
						conditions: r,
						error: "Invalid Configuration: FIPS and custom endpoint are not supported",
						type: d
					},
					{
						conditions: s,
						error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
						type: d
					},
					{
						endpoint: {
							url: k,
							properties: n,
							headers: n
						},
						type: e
					}
				],
				type: f
			},
			{
				conditions: [{
					[v]: b,
					[w]: t
				}],
				rules: [{
					conditions: [{
						[v]: "aws.partition",
						[w]: t,
						assign: g
					}],
					rules: [
						{
							conditions: [l, m],
							rules: [{
								conditions: [{
									[v]: c,
									[w]: [a, o]
								}, q],
								rules: [{
									endpoint: {
										url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n,
										headers: n
									},
									type: e
								}],
								type: f
							}, {
								error: "FIPS and DualStack are enabled, but this partition does not support one or both",
								type: d
							}],
							type: f
						},
						{
							conditions: r,
							rules: [{
								conditions: [{
									[v]: c,
									[w]: [o, a]
								}],
								rules: [{
									conditions: [{
										[v]: "stringEquals",
										[w]: [{
											[v]: h,
											[w]: [p, "name"]
										}, "aws-us-gov"]
									}],
									endpoint: {
										url: "https://oidc.{Region}.amazonaws.com",
										properties: n,
										headers: n
									},
									type: e
								}, {
									endpoint: {
										url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
										properties: n,
										headers: n
									},
									type: e
								}],
								type: f
							}, {
								error: "FIPS is enabled but this partition does not support FIPS",
								type: d
							}],
							type: f
						},
						{
							conditions: s,
							rules: [{
								conditions: [q],
								rules: [{
									endpoint: {
										url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
										properties: n,
										headers: n
									},
									type: e
								}],
								type: f
							}, {
								error: "DualStack is enabled but this partition does not support DualStack",
								type: d
							}],
							type: f
						},
						{
							endpoint: {
								url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
								properties: n,
								headers: n
							},
							type: e
						}
					],
					type: f
				}],
				type: f
			},
			{
				error: "Invalid Configuration: Missing Region",
				type: d
			}
		]
	};
	ruleSet = _data;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/endpoint/endpointResolver.js
var import_dist_cjs$32, import_dist_cjs$33, cache, defaultEndpointResolver;
var init_endpointResolver = __esmMin((() => {
	import_dist_cjs$32 = require_dist_cjs$32();
	import_dist_cjs$33 = require_dist_cjs$35();
	init_ruleset();
	cache = new import_dist_cjs$33.EndpointCache({
		size: 50,
		params: [
			"Endpoint",
			"Region",
			"UseDualStack",
			"UseFIPS"
		]
	});
	defaultEndpointResolver = (endpointParams, context = {}) => {
		return cache.get(endpointParams, () => (0, import_dist_cjs$33.resolveEndpoint)(ruleSet, {
			endpointParams,
			logger: context.logger
		}));
	};
	import_dist_cjs$33.customEndpointFunctions.aws = import_dist_cjs$32.awsEndpointFunctions;
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.shared.js
var import_dist_cjs$28, import_dist_cjs$29, import_dist_cjs$30, import_dist_cjs$31, getRuntimeConfig$1;
var init_runtimeConfig_shared = __esmMin((() => {
	init_dist_es();
	init_protocols();
	init_dist_es$1();
	import_dist_cjs$28 = require_dist_cjs$28();
	import_dist_cjs$29 = require_dist_cjs$33();
	import_dist_cjs$30 = require_dist_cjs$43();
	import_dist_cjs$31 = require_dist_cjs$44();
	init_httpAuthSchemeProvider();
	init_endpointResolver();
	getRuntimeConfig$1 = (config) => {
		return {
			apiVersion: "2019-06-10",
			base64Decoder: config?.base64Decoder ?? import_dist_cjs$30.fromBase64,
			base64Encoder: config?.base64Encoder ?? import_dist_cjs$30.toBase64,
			disableHostPrefix: config?.disableHostPrefix ?? false,
			endpointProvider: config?.endpointProvider ?? defaultEndpointResolver,
			extensions: config?.extensions ?? [],
			httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? defaultSSOOIDCHttpAuthSchemeProvider,
			httpAuthSchemes: config?.httpAuthSchemes ?? [{
				schemeId: "aws.auth#sigv4",
				identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
				signer: new AwsSdkSigV4Signer()
			}, {
				schemeId: "smithy.api#noAuth",
				identityProvider: (ipc) => ipc.getIdentityProvider("smithy.api#noAuth") || (async () => ({})),
				signer: new NoAuthSigner()
			}],
			logger: config?.logger ?? new import_dist_cjs$28.NoOpLogger(),
			protocol: config?.protocol ?? new AwsRestJsonProtocol({ defaultNamespace: "com.amazonaws.ssooidc" }),
			serviceId: config?.serviceId ?? "SSO OIDC",
			urlParser: config?.urlParser ?? import_dist_cjs$29.parseUrl,
			utf8Decoder: config?.utf8Decoder ?? import_dist_cjs$31.fromUtf8,
			utf8Encoder: config?.utf8Encoder ?? import_dist_cjs$31.toUtf8
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeConfig.js
var import_dist_cjs$17, import_dist_cjs$18, import_dist_cjs$19, import_dist_cjs$20, import_dist_cjs$21, import_dist_cjs$22, import_dist_cjs$23, import_dist_cjs$24, import_dist_cjs$25, import_dist_cjs$26, import_dist_cjs$27, getRuntimeConfig;
var init_runtimeConfig = __esmMin((() => {
	init_dist_es();
	import_dist_cjs$17 = require_dist_cjs$14();
	import_dist_cjs$18 = require_dist_cjs$24();
	import_dist_cjs$19 = require_dist_cjs$13();
	import_dist_cjs$20 = require_dist_cjs$17();
	import_dist_cjs$21 = require_dist_cjs$21();
	import_dist_cjs$22 = require_dist_cjs$40();
	import_dist_cjs$23 = require_dist_cjs$12();
	import_dist_cjs$24 = require_dist_cjs$18();
	init_runtimeConfig_shared();
	import_dist_cjs$25 = require_dist_cjs$28();
	import_dist_cjs$26 = require_dist_cjs$11();
	import_dist_cjs$27 = require_dist_cjs$28();
	getRuntimeConfig = (config) => {
		(0, import_dist_cjs$27.emitWarningIfUnsupportedVersion)(process.version);
		const defaultsMode = (0, import_dist_cjs$26.resolveDefaultsModeConfig)(config);
		const defaultConfigProvider = () => defaultsMode().then(import_dist_cjs$25.loadConfigsForDefaultMode);
		const clientSharedValues = getRuntimeConfig$1(config);
		emitWarningIfUnsupportedVersion(process.version);
		const loaderConfig = {
			profile: config?.profile,
			logger: clientSharedValues.logger
		};
		return {
			...clientSharedValues,
			...config,
			runtime: "node",
			defaultsMode,
			authSchemePreference: config?.authSchemePreference ?? (0, import_dist_cjs$21.loadConfig)(NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
			bodyLengthChecker: config?.bodyLengthChecker ?? import_dist_cjs$23.calculateBodyLength,
			defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, import_dist_cjs$17.createDefaultUserAgentProvider)({
				serviceId: clientSharedValues.serviceId,
				clientVersion: version
			}),
			maxAttempts: config?.maxAttempts ?? (0, import_dist_cjs$21.loadConfig)(import_dist_cjs$20.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
			region: config?.region ?? (0, import_dist_cjs$21.loadConfig)(import_dist_cjs$18.NODE_REGION_CONFIG_OPTIONS, {
				...import_dist_cjs$18.NODE_REGION_CONFIG_FILE_OPTIONS,
				...loaderConfig
			}),
			requestHandler: import_dist_cjs$22.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
			retryMode: config?.retryMode ?? (0, import_dist_cjs$21.loadConfig)({
				...import_dist_cjs$20.NODE_RETRY_MODE_CONFIG_OPTIONS,
				default: async () => (await defaultConfigProvider()).retryMode || import_dist_cjs$24.DEFAULT_RETRY_MODE
			}, config),
			sha256: config?.sha256 ?? import_dist_cjs$19.Hash.bind(null, "sha256"),
			streamCollector: config?.streamCollector ?? import_dist_cjs$22.streamCollector,
			useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, import_dist_cjs$21.loadConfig)(import_dist_cjs$18.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			useFipsEndpoint: config?.useFipsEndpoint ?? (0, import_dist_cjs$21.loadConfig)(import_dist_cjs$18.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
			userAgentAppId: config?.userAgentAppId ?? (0, import_dist_cjs$21.loadConfig)(import_dist_cjs$17.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig)
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/auth/httpAuthExtensionConfiguration.js
var getHttpAuthExtensionConfiguration, resolveHttpAuthRuntimeConfig;
var init_httpAuthExtensionConfiguration = __esmMin((() => {
	getHttpAuthExtensionConfiguration = (runtimeConfig$2) => {
		const _httpAuthSchemes = runtimeConfig$2.httpAuthSchemes;
		let _httpAuthSchemeProvider = runtimeConfig$2.httpAuthSchemeProvider;
		let _credentials = runtimeConfig$2.credentials;
		return {
			setHttpAuthScheme(httpAuthScheme) {
				const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
				if (index === -1) _httpAuthSchemes.push(httpAuthScheme);
				else _httpAuthSchemes.splice(index, 1, httpAuthScheme);
			},
			httpAuthSchemes() {
				return _httpAuthSchemes;
			},
			setHttpAuthSchemeProvider(httpAuthSchemeProvider$2) {
				_httpAuthSchemeProvider = httpAuthSchemeProvider$2;
			},
			httpAuthSchemeProvider() {
				return _httpAuthSchemeProvider;
			},
			setCredentials(credentials) {
				_credentials = credentials;
			},
			credentials() {
				return _credentials;
			}
		};
	};
	resolveHttpAuthRuntimeConfig = (config) => {
		return {
			httpAuthSchemes: config.httpAuthSchemes(),
			httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
			credentials: config.credentials()
		};
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/runtimeExtensions.js
var import_dist_cjs$14, import_dist_cjs$15, import_dist_cjs$16, resolveRuntimeExtensions;
var init_runtimeExtensions = __esmMin((() => {
	import_dist_cjs$14 = require_dist_cjs$10();
	import_dist_cjs$15 = require_dist_cjs$52();
	import_dist_cjs$16 = require_dist_cjs$28();
	init_httpAuthExtensionConfiguration();
	resolveRuntimeExtensions = (runtimeConfig$2, extensions) => {
		const extensionConfiguration = Object.assign((0, import_dist_cjs$14.getAwsRegionExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$16.getDefaultExtensionConfiguration)(runtimeConfig$2), (0, import_dist_cjs$15.getHttpHandlerExtensionConfiguration)(runtimeConfig$2), getHttpAuthExtensionConfiguration(runtimeConfig$2));
		extensions.forEach((extension) => extension.configure(extensionConfiguration));
		return Object.assign(runtimeConfig$2, (0, import_dist_cjs$14.resolveAwsRegionExtensionConfiguration)(extensionConfiguration), (0, import_dist_cjs$16.resolveDefaultRuntimeConfig)(extensionConfiguration), (0, import_dist_cjs$15.resolveHttpHandlerRuntimeConfig)(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDCClient.js
var import_dist_cjs$5, import_dist_cjs$6, import_dist_cjs$7, import_dist_cjs$8, import_dist_cjs$9, import_dist_cjs$10, import_dist_cjs$11, import_dist_cjs$12, import_dist_cjs$13, SSOOIDCClient;
var init_SSOOIDCClient = __esmMin((() => {
	import_dist_cjs$5 = require_dist_cjs$51();
	import_dist_cjs$6 = require_dist_cjs$50();
	import_dist_cjs$7 = require_dist_cjs$49();
	import_dist_cjs$8 = require_dist_cjs$26();
	import_dist_cjs$9 = require_dist_cjs$24();
	init_dist_es$1();
	init_schema();
	import_dist_cjs$10 = require_dist_cjs$23();
	import_dist_cjs$11 = require_dist_cjs$20();
	import_dist_cjs$12 = require_dist_cjs$17();
	import_dist_cjs$13 = require_dist_cjs$28();
	init_httpAuthSchemeProvider();
	init_EndpointParameters();
	init_runtimeConfig();
	init_runtimeExtensions();
	SSOOIDCClient = class extends import_dist_cjs$13.Client {
		config;
		constructor(...[configuration]) {
			const _config_0 = getRuntimeConfig(configuration || {});
			super(_config_0);
			this.initConfig = _config_0;
			this.config = resolveRuntimeExtensions(resolveHttpAuthSchemeConfig((0, import_dist_cjs$11.resolveEndpointConfig)((0, import_dist_cjs$5.resolveHostHeaderConfig)((0, import_dist_cjs$9.resolveRegionConfig)((0, import_dist_cjs$12.resolveRetryConfig)((0, import_dist_cjs$8.resolveUserAgentConfig)(resolveClientEndpointParameters(_config_0))))))), configuration?.extensions || []);
			this.middlewareStack.use(getSchemaSerdePlugin(this.config));
			this.middlewareStack.use((0, import_dist_cjs$8.getUserAgentPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$12.getRetryPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$10.getContentLengthPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$5.getHostHeaderPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$6.getLoggerPlugin)(this.config));
			this.middlewareStack.use((0, import_dist_cjs$7.getRecursionDetectionPlugin)(this.config));
			this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
				httpAuthSchemeParametersProvider: defaultSSOOIDCHttpAuthSchemeParametersProvider,
				identityProviderConfigProvider: async (config) => new DefaultIdentityProviderConfig({ "aws.auth#sigv4": config.credentials })
			}));
			this.middlewareStack.use(getHttpSigningPlugin(this.config));
		}
		destroy() {
			super.destroy();
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/SSOOIDCServiceException.js
var import_dist_cjs$4, SSOOIDCServiceException;
var init_SSOOIDCServiceException = __esmMin((() => {
	import_dist_cjs$4 = require_dist_cjs$28();
	SSOOIDCServiceException = class SSOOIDCServiceException extends import_dist_cjs$4.ServiceException {
		constructor(options) {
			super(options);
			Object.setPrototypeOf(this, SSOOIDCServiceException.prototype);
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/errors.js
var AccessDeniedException, AuthorizationPendingException, ExpiredTokenException, InternalServerException, InvalidClientException, InvalidGrantException, InvalidRequestException, InvalidScopeException, SlowDownException, UnauthorizedClientException, UnsupportedGrantTypeException;
var init_errors = __esmMin((() => {
	init_SSOOIDCServiceException();
	AccessDeniedException = class AccessDeniedException extends SSOOIDCServiceException {
		name = "AccessDeniedException";
		$fault = "client";
		error;
		reason;
		error_description;
		constructor(opts) {
			super({
				name: "AccessDeniedException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, AccessDeniedException.prototype);
			this.error = opts.error;
			this.reason = opts.reason;
			this.error_description = opts.error_description;
		}
	};
	AuthorizationPendingException = class AuthorizationPendingException extends SSOOIDCServiceException {
		name = "AuthorizationPendingException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "AuthorizationPendingException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, AuthorizationPendingException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	ExpiredTokenException = class ExpiredTokenException extends SSOOIDCServiceException {
		name = "ExpiredTokenException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "ExpiredTokenException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, ExpiredTokenException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	InternalServerException = class InternalServerException extends SSOOIDCServiceException {
		name = "InternalServerException";
		$fault = "server";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "InternalServerException",
				$fault: "server",
				...opts
			});
			Object.setPrototypeOf(this, InternalServerException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	InvalidClientException = class InvalidClientException extends SSOOIDCServiceException {
		name = "InvalidClientException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "InvalidClientException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidClientException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	InvalidGrantException = class InvalidGrantException extends SSOOIDCServiceException {
		name = "InvalidGrantException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "InvalidGrantException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidGrantException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	InvalidRequestException = class InvalidRequestException extends SSOOIDCServiceException {
		name = "InvalidRequestException";
		$fault = "client";
		error;
		reason;
		error_description;
		constructor(opts) {
			super({
				name: "InvalidRequestException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidRequestException.prototype);
			this.error = opts.error;
			this.reason = opts.reason;
			this.error_description = opts.error_description;
		}
	};
	InvalidScopeException = class InvalidScopeException extends SSOOIDCServiceException {
		name = "InvalidScopeException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "InvalidScopeException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, InvalidScopeException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	SlowDownException = class SlowDownException extends SSOOIDCServiceException {
		name = "SlowDownException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "SlowDownException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, SlowDownException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	UnauthorizedClientException = class UnauthorizedClientException extends SSOOIDCServiceException {
		name = "UnauthorizedClientException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "UnauthorizedClientException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, UnauthorizedClientException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
	UnsupportedGrantTypeException = class UnsupportedGrantTypeException extends SSOOIDCServiceException {
		name = "UnsupportedGrantTypeException";
		$fault = "client";
		error;
		error_description;
		constructor(opts) {
			super({
				name: "UnsupportedGrantTypeException",
				$fault: "client",
				...opts
			});
			Object.setPrototypeOf(this, UnsupportedGrantTypeException.prototype);
			this.error = opts.error;
			this.error_description = opts.error_description;
		}
	};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/schemas/schemas_0.js
var _ADE, _APE, _AT, _CS, _CT, _CTR, _CTRr, _CV, _ETE, _ICE, _IGE, _IRE, _ISE, _ISEn, _IT, _RT, _SDE, _UCE, _UGTE, _aT, _c, _cI, _cS, _cV, _co, _dC, _e, _eI, _ed, _gT, _h, _hE, _iT, _r, _rT, _rU, _s, _se, _sm, _tT, n0, AccessToken, ClientSecret, CodeVerifier, IdToken, RefreshToken, AccessDeniedException$1, AuthorizationPendingException$1, CreateTokenRequest, CreateTokenResponse, ExpiredTokenException$1, InternalServerException$1, InvalidClientException$1, InvalidGrantException$1, InvalidRequestException$1, InvalidScopeException$1, SlowDownException$1, UnauthorizedClientException$1, UnsupportedGrantTypeException$1, SSOOIDCServiceException$1, CreateToken;
var init_schemas_0 = __esmMin((() => {
	init_schema();
	init_errors();
	init_SSOOIDCServiceException();
	_ADE = "AccessDeniedException";
	_APE = "AuthorizationPendingException";
	_AT = "AccessToken";
	_CS = "ClientSecret";
	_CT = "CreateToken";
	_CTR = "CreateTokenRequest";
	_CTRr = "CreateTokenResponse";
	_CV = "CodeVerifier";
	_ETE = "ExpiredTokenException";
	_ICE = "InvalidClientException";
	_IGE = "InvalidGrantException";
	_IRE = "InvalidRequestException";
	_ISE = "InternalServerException";
	_ISEn = "InvalidScopeException";
	_IT = "IdToken";
	_RT = "RefreshToken";
	_SDE = "SlowDownException";
	_UCE = "UnauthorizedClientException";
	_UGTE = "UnsupportedGrantTypeException";
	_aT = "accessToken";
	_c = "client";
	_cI = "clientId";
	_cS = "clientSecret";
	_cV = "codeVerifier";
	_co = "code";
	_dC = "deviceCode";
	_e = "error";
	_eI = "expiresIn";
	_ed = "error_description";
	_gT = "grantType";
	_h = "http";
	_hE = "httpError";
	_iT = "idToken";
	_r = "reason";
	_rT = "refreshToken";
	_rU = "redirectUri";
	_s = "scope";
	_se = "server";
	_sm = "smithy.ts.sdk.synthetic.com.amazonaws.ssooidc";
	_tT = "tokenType";
	n0 = "com.amazonaws.ssooidc";
	AccessToken = [
		0,
		n0,
		_AT,
		8,
		0
	];
	ClientSecret = [
		0,
		n0,
		_CS,
		8,
		0
	];
	CodeVerifier = [
		0,
		n0,
		_CV,
		8,
		0
	];
	IdToken = [
		0,
		n0,
		_IT,
		8,
		0
	];
	RefreshToken = [
		0,
		n0,
		_RT,
		8,
		0
	];
	AccessDeniedException$1 = [
		-3,
		n0,
		_ADE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[
			_e,
			_r,
			_ed
		],
		[
			0,
			0,
			0
		]
	];
	TypeRegistry.for(n0).registerError(AccessDeniedException$1, AccessDeniedException);
	AuthorizationPendingException$1 = [
		-3,
		n0,
		_APE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(AuthorizationPendingException$1, AuthorizationPendingException);
	CreateTokenRequest = [
		3,
		n0,
		_CTR,
		0,
		[
			_cI,
			_cS,
			_gT,
			_dC,
			_co,
			_rT,
			_s,
			_rU,
			_cV
		],
		[
			0,
			[() => ClientSecret, 0],
			0,
			0,
			0,
			[() => RefreshToken, 0],
			64,
			0,
			[() => CodeVerifier, 0]
		]
	];
	CreateTokenResponse = [
		3,
		n0,
		_CTRr,
		0,
		[
			_aT,
			_tT,
			_eI,
			_rT,
			_iT
		],
		[
			[() => AccessToken, 0],
			0,
			1,
			[() => RefreshToken, 0],
			[() => IdToken, 0]
		]
	];
	ExpiredTokenException$1 = [
		-3,
		n0,
		_ETE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(ExpiredTokenException$1, ExpiredTokenException);
	InternalServerException$1 = [
		-3,
		n0,
		_ISE,
		{
			[_e]: _se,
			[_hE]: 500
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(InternalServerException$1, InternalServerException);
	InvalidClientException$1 = [
		-3,
		n0,
		_ICE,
		{
			[_e]: _c,
			[_hE]: 401
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(InvalidClientException$1, InvalidClientException);
	InvalidGrantException$1 = [
		-3,
		n0,
		_IGE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(InvalidGrantException$1, InvalidGrantException);
	InvalidRequestException$1 = [
		-3,
		n0,
		_IRE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[
			_e,
			_r,
			_ed
		],
		[
			0,
			0,
			0
		]
	];
	TypeRegistry.for(n0).registerError(InvalidRequestException$1, InvalidRequestException);
	InvalidScopeException$1 = [
		-3,
		n0,
		_ISEn,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(InvalidScopeException$1, InvalidScopeException);
	SlowDownException$1 = [
		-3,
		n0,
		_SDE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(SlowDownException$1, SlowDownException);
	UnauthorizedClientException$1 = [
		-3,
		n0,
		_UCE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(UnauthorizedClientException$1, UnauthorizedClientException);
	UnsupportedGrantTypeException$1 = [
		-3,
		n0,
		_UGTE,
		{
			[_e]: _c,
			[_hE]: 400
		},
		[_e, _ed],
		[0, 0]
	];
	TypeRegistry.for(n0).registerError(UnsupportedGrantTypeException$1, UnsupportedGrantTypeException);
	SSOOIDCServiceException$1 = [
		-3,
		_sm,
		"SSOOIDCServiceException",
		0,
		[],
		[]
	];
	TypeRegistry.for(_sm).registerError(SSOOIDCServiceException$1, SSOOIDCServiceException);
	CreateToken = [
		9,
		n0,
		_CT,
		{ [_h]: [
			"POST",
			"/token",
			200
		] },
		() => CreateTokenRequest,
		() => CreateTokenResponse
	];
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/CreateTokenCommand.js
var import_dist_cjs$2, import_dist_cjs$3, CreateTokenCommand;
var init_CreateTokenCommand = __esmMin((() => {
	import_dist_cjs$2 = require_dist_cjs$20();
	import_dist_cjs$3 = require_dist_cjs$28();
	init_EndpointParameters();
	init_schemas_0();
	CreateTokenCommand = class extends import_dist_cjs$3.Command.classBuilder().ep(commonParams).m(function(Command$2, cs, config, o$5) {
		return [(0, import_dist_cjs$2.getEndpointPlugin)(config, Command$2.getEndpointParameterInstructions())];
	}).s("AWSSSOOIDCService", "CreateToken", {}).n("SSOOIDCClient", "CreateTokenCommand").sc(CreateToken).build() {};
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/SSOOIDC.js
var import_dist_cjs$1, commands, SSOOIDC;
var init_SSOOIDC = __esmMin((() => {
	import_dist_cjs$1 = require_dist_cjs$28();
	init_CreateTokenCommand();
	init_SSOOIDCClient();
	commands = { CreateTokenCommand };
	SSOOIDC = class extends SSOOIDCClient {};
	(0, import_dist_cjs$1.createAggregatedClient)(commands, SSOOIDC);
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/commands/index.js
var init_commands = __esmMin((() => {
	init_CreateTokenCommand();
}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/models/enums.js
var init_enums = __esmMin((() => {}));

//#endregion
//#region node_modules/@aws-sdk/nested-clients/dist-es/submodules/sso-oidc/index.js
var init_sso_oidc = __esmMin((() => {
	init_SSOOIDCClient();
	init_SSOOIDC();
	init_commands();
	init_enums();
	init_errors();
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/event-streams/EventStreamSerde.js
var import_dist_cjs, EventStreamSerde;
var init_EventStreamSerde = __esmMin((() => {
	import_dist_cjs = require_dist_cjs$44();
	EventStreamSerde = class {
		marshaller;
		serializer;
		deserializer;
		serdeContext;
		defaultContentType;
		constructor({ marshaller, serializer, deserializer, serdeContext, defaultContentType }) {
			this.marshaller = marshaller;
			this.serializer = serializer;
			this.deserializer = deserializer;
			this.serdeContext = serdeContext;
			this.defaultContentType = defaultContentType;
		}
		async serializeEventStream({ eventStream, requestSchema, initialRequest }) {
			const marshaller = this.marshaller;
			const eventStreamMember = requestSchema.getEventStreamMember();
			const unionSchema = requestSchema.getMemberSchema(eventStreamMember);
			const serializer = this.serializer;
			const defaultContentType = this.defaultContentType;
			const initialRequestMarker = Symbol("initialRequestMarker");
			const eventStreamIterable = { async *[Symbol.asyncIterator]() {
				if (initialRequest) {
					const headers = {
						":event-type": {
							type: "string",
							value: "initial-request"
						},
						":message-type": {
							type: "string",
							value: "event"
						},
						":content-type": {
							type: "string",
							value: defaultContentType
						}
					};
					serializer.write(requestSchema, initialRequest);
					const body = serializer.flush();
					yield {
						[initialRequestMarker]: true,
						headers,
						body
					};
				}
				for await (const page of eventStream) yield page;
			} };
			return marshaller.serialize(eventStreamIterable, (event) => {
				if (event[initialRequestMarker]) return {
					headers: event.headers,
					body: event.body
				};
				const unionMember = Object.keys(event).find((key) => {
					return key !== "__type";
				}) ?? "";
				const { additionalHeaders, body, eventType, explicitPayloadContentType } = this.writeEventBody(unionMember, unionSchema, event);
				return {
					headers: {
						":event-type": {
							type: "string",
							value: eventType
						},
						":message-type": {
							type: "string",
							value: "event"
						},
						":content-type": {
							type: "string",
							value: explicitPayloadContentType ?? defaultContentType
						},
						...additionalHeaders
					},
					body
				};
			});
		}
		async deserializeEventStream({ response, responseSchema, initialResponseContainer }) {
			const marshaller = this.marshaller;
			const eventStreamMember = responseSchema.getEventStreamMember();
			const memberSchemas = responseSchema.getMemberSchema(eventStreamMember).getMemberSchemas();
			const initialResponseMarker = Symbol("initialResponseMarker");
			const asyncIterable = marshaller.deserialize(response.body, async (event) => {
				const unionMember = Object.keys(event).find((key) => {
					return key !== "__type";
				}) ?? "";
				const body = event[unionMember].body;
				if (unionMember === "initial-response") {
					const dataObject = await this.deserializer.read(responseSchema, body);
					delete dataObject[eventStreamMember];
					return {
						[initialResponseMarker]: true,
						...dataObject
					};
				} else if (unionMember in memberSchemas) {
					const eventStreamSchema = memberSchemas[unionMember];
					if (eventStreamSchema.isStructSchema()) {
						const out = {};
						let hasBindings = false;
						for (const [name, member$1] of eventStreamSchema.structIterator()) {
							const { eventHeader, eventPayload } = member$1.getMergedTraits();
							hasBindings = hasBindings || Boolean(eventHeader || eventPayload);
							if (eventPayload) {
								if (member$1.isBlobSchema()) out[name] = body;
								else if (member$1.isStringSchema()) out[name] = (this.serdeContext?.utf8Encoder ?? import_dist_cjs.toUtf8)(body);
								else if (member$1.isStructSchema()) out[name] = await this.deserializer.read(member$1, body);
							} else if (eventHeader) {
								const value = event[unionMember].headers[name]?.value;
								if (value != null) if (member$1.isNumericSchema()) if (value && typeof value === "object" && "bytes" in value) out[name] = BigInt(value.toString());
								else out[name] = Number(value);
								else out[name] = value;
							}
						}
						if (hasBindings) return { [unionMember]: out };
					}
					return { [unionMember]: await this.deserializer.read(eventStreamSchema, body) };
				} else return { $unknown: event };
			});
			const asyncIterator = asyncIterable[Symbol.asyncIterator]();
			const firstEvent = await asyncIterator.next();
			if (firstEvent.done) return asyncIterable;
			if (firstEvent.value?.[initialResponseMarker]) {
				if (!responseSchema) throw new Error("@smithy::core/protocols - initial-response event encountered in event stream but no response schema given.");
				for (const [key, value] of Object.entries(firstEvent.value)) initialResponseContainer[key] = value;
			}
			return { async *[Symbol.asyncIterator]() {
				if (!firstEvent?.value?.[initialResponseMarker]) yield firstEvent.value;
				while (true) {
					const { done, value } = await asyncIterator.next();
					if (done) break;
					yield value;
				}
			} };
		}
		writeEventBody(unionMember, unionSchema, event) {
			const serializer = this.serializer;
			let eventType = unionMember;
			let explicitPayloadMember = null;
			let explicitPayloadContentType;
			const isKnownSchema = (() => {
				return unionSchema.getSchema()[4].includes(unionMember);
			})();
			const additionalHeaders = {};
			if (!isKnownSchema) {
				const [type, value] = event[unionMember];
				eventType = type;
				serializer.write(15, value);
			} else {
				const eventSchema = unionSchema.getMemberSchema(unionMember);
				if (eventSchema.isStructSchema()) {
					for (const [memberName, memberSchema] of eventSchema.structIterator()) {
						const { eventHeader, eventPayload } = memberSchema.getMergedTraits();
						if (eventPayload) {
							explicitPayloadMember = memberName;
							break;
						} else if (eventHeader) {
							const value = event[unionMember][memberName];
							let type = "binary";
							if (memberSchema.isNumericSchema()) if ((-2) ** 31 <= value && value <= 2 ** 31 - 1) type = "integer";
							else type = "long";
							else if (memberSchema.isTimestampSchema()) type = "timestamp";
							else if (memberSchema.isStringSchema()) type = "string";
							else if (memberSchema.isBooleanSchema()) type = "boolean";
							if (value != null) {
								additionalHeaders[memberName] = {
									type,
									value
								};
								delete event[unionMember][memberName];
							}
						}
					}
					if (explicitPayloadMember !== null) {
						const payloadSchema = eventSchema.getMemberSchema(explicitPayloadMember);
						if (payloadSchema.isBlobSchema()) explicitPayloadContentType = "application/octet-stream";
						else if (payloadSchema.isStringSchema()) explicitPayloadContentType = "text/plain";
						serializer.write(payloadSchema, event[unionMember][explicitPayloadMember]);
					} else serializer.write(eventSchema, event[unionMember]);
				} else throw new Error("@smithy/core/event-streams - non-struct member not supported in event stream union.");
			}
			const messageSerialization = serializer.flush();
			return {
				body: typeof messageSerialization === "string" ? (this.serdeContext?.utf8Decoder ?? import_dist_cjs.fromUtf8)(messageSerialization) : messageSerialization,
				eventType,
				explicitPayloadContentType,
				additionalHeaders
			};
		}
	};
}));

//#endregion
//#region node_modules/@smithy/core/dist-es/submodules/event-streams/index.js
var init_event_streams = __esmMin((() => {
	init_EventStreamSerde();
}));

//#endregion
//#region node_modules/@smithy/credential-provider-imds/dist-cjs/index.js
var require_dist_cjs = /* @__PURE__ */ __commonJSMin(((exports) => {
	var propertyProvider = require_dist_cjs$31();
	var url = __require("url");
	var buffer = __require("buffer");
	var http = __require("http");
	var nodeConfigProvider = require_dist_cjs$21();
	var urlParser = require_dist_cjs$33();
	function httpRequest(options) {
		return new Promise((resolve, reject) => {
			const req = http.request({
				method: "GET",
				...options,
				hostname: options.hostname?.replace(/^\[(.+)\]$/, "$1")
			});
			req.on("error", (err) => {
				reject(Object.assign(new propertyProvider.ProviderError("Unable to connect to instance metadata service"), err));
				req.destroy();
			});
			req.on("timeout", () => {
				reject(new propertyProvider.ProviderError("TimeoutError from instance metadata service"));
				req.destroy();
			});
			req.on("response", (res) => {
				const { statusCode = 400 } = res;
				if (statusCode < 200 || 300 <= statusCode) {
					reject(Object.assign(new propertyProvider.ProviderError("Error response received from instance metadata service"), { statusCode }));
					req.destroy();
				}
				const chunks = [];
				res.on("data", (chunk) => {
					chunks.push(chunk);
				});
				res.on("end", () => {
					resolve(buffer.Buffer.concat(chunks));
					req.destroy();
				});
			});
			req.end();
		});
	}
	const isImdsCredentials = (arg) => Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
	const fromImdsCredentials = (creds) => ({
		accessKeyId: creds.AccessKeyId,
		secretAccessKey: creds.SecretAccessKey,
		sessionToken: creds.Token,
		expiration: new Date(creds.Expiration),
		...creds.AccountId && { accountId: creds.AccountId }
	});
	const DEFAULT_TIMEOUT = 1e3;
	const DEFAULT_MAX_RETRIES = 0;
	const providerConfigFromInit = ({ maxRetries = DEFAULT_MAX_RETRIES, timeout = DEFAULT_TIMEOUT }) => ({
		maxRetries,
		timeout
	});
	const retry = (toRetry, maxRetries) => {
		let promise = toRetry();
		for (let i$5 = 0; i$5 < maxRetries; i$5++) promise = promise.catch(toRetry);
		return promise;
	};
	const ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
	const ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
	const ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
	const fromContainerMetadata = (init = {}) => {
		const { timeout, maxRetries } = providerConfigFromInit(init);
		return () => retry(async () => {
			const requestOptions = await getCmdsUri({ logger: init.logger });
			const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
			if (!isImdsCredentials(credsResponse)) throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", { logger: init.logger });
			return fromImdsCredentials(credsResponse);
		}, maxRetries);
	};
	const requestFromEcsImds = async (timeout, options) => {
		if (process.env[ENV_CMDS_AUTH_TOKEN]) options.headers = {
			...options.headers,
			Authorization: process.env[ENV_CMDS_AUTH_TOKEN]
		};
		return (await httpRequest({
			...options,
			timeout
		})).toString();
	};
	const CMDS_IP = "169.254.170.2";
	const GREENGRASS_HOSTS = {
		localhost: true,
		"127.0.0.1": true
	};
	const GREENGRASS_PROTOCOLS = {
		"http:": true,
		"https:": true
	};
	const getCmdsUri = async ({ logger: logger$1 }) => {
		if (process.env[ENV_CMDS_RELATIVE_URI]) return {
			hostname: CMDS_IP,
			path: process.env[ENV_CMDS_RELATIVE_URI]
		};
		if (process.env[ENV_CMDS_FULL_URI]) {
			const parsed = url.parse(process.env[ENV_CMDS_FULL_URI]);
			if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) throw new propertyProvider.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, {
				tryNextLink: false,
				logger: logger$1
			});
			if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) throw new propertyProvider.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, {
				tryNextLink: false,
				logger: logger$1
			});
			return {
				...parsed,
				port: parsed.port ? parseInt(parsed.port, 10) : void 0
			};
		}
		throw new propertyProvider.CredentialsProviderError(`The container metadata credential provider cannot be used unless the ${ENV_CMDS_RELATIVE_URI} or ${ENV_CMDS_FULL_URI} environment variable is set`, {
			tryNextLink: false,
			logger: logger$1
		});
	};
	var InstanceMetadataV1FallbackError = class InstanceMetadataV1FallbackError extends propertyProvider.CredentialsProviderError {
		tryNextLink;
		name = "InstanceMetadataV1FallbackError";
		constructor(message, tryNextLink = true) {
			super(message, tryNextLink);
			this.tryNextLink = tryNextLink;
			Object.setPrototypeOf(this, InstanceMetadataV1FallbackError.prototype);
		}
	};
	exports.Endpoint = void 0;
	(function(Endpoint) {
		Endpoint["IPv4"] = "http://169.254.169.254";
		Endpoint["IPv6"] = "http://[fd00:ec2::254]";
	})(exports.Endpoint || (exports.Endpoint = {}));
	const ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
	const CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
	const ENDPOINT_CONFIG_OPTIONS = {
		environmentVariableSelector: (env) => env[ENV_ENDPOINT_NAME],
		configFileSelector: (profile) => profile[CONFIG_ENDPOINT_NAME],
		default: void 0
	};
	var EndpointMode;
	(function(EndpointMode$1) {
		EndpointMode$1["IPv4"] = "IPv4";
		EndpointMode$1["IPv6"] = "IPv6";
	})(EndpointMode || (EndpointMode = {}));
	const ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
	const CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
	const ENDPOINT_MODE_CONFIG_OPTIONS = {
		environmentVariableSelector: (env) => env[ENV_ENDPOINT_MODE_NAME],
		configFileSelector: (profile) => profile[CONFIG_ENDPOINT_MODE_NAME],
		default: EndpointMode.IPv4
	};
	const getInstanceMetadataEndpoint = async () => urlParser.parseUrl(await getFromEndpointConfig() || await getFromEndpointModeConfig());
	const getFromEndpointConfig = async () => nodeConfigProvider.loadConfig(ENDPOINT_CONFIG_OPTIONS)();
	const getFromEndpointModeConfig = async () => {
		const endpointMode = await nodeConfigProvider.loadConfig(ENDPOINT_MODE_CONFIG_OPTIONS)();
		switch (endpointMode) {
			case EndpointMode.IPv4: return exports.Endpoint.IPv4;
			case EndpointMode.IPv6: return exports.Endpoint.IPv6;
			default: throw new Error(`Unsupported endpoint mode: ${endpointMode}. Select from ${Object.values(EndpointMode)}`);
		}
	};
	const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 300;
	const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 300;
	const getExtendedInstanceMetadataCredentials = (credentials, logger$1) => {
		const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
		const newExpiration = new Date(Date.now() + refreshInterval * 1e3);
		logger$1.warn(`Attempting credential expiration extension due to a credential service availability issue. A refresh of these credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html`);
		const originalExpiration = credentials.originalExpiration ?? credentials.expiration;
		return {
			...credentials,
			...originalExpiration ? { originalExpiration } : {},
			expiration: newExpiration
		};
	};
	const staticStabilityProvider = (provider, options = {}) => {
		const logger$1 = options?.logger || console;
		let pastCredentials;
		return async () => {
			let credentials;
			try {
				credentials = await provider();
				if (credentials.expiration && credentials.expiration.getTime() < Date.now()) credentials = getExtendedInstanceMetadataCredentials(credentials, logger$1);
			} catch (e$5) {
				if (pastCredentials) {
					logger$1.warn("Credential renew failed: ", e$5);
					credentials = getExtendedInstanceMetadataCredentials(pastCredentials, logger$1);
				} else throw e$5;
			}
			pastCredentials = credentials;
			return credentials;
		};
	};
	const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
	const IMDS_TOKEN_PATH = "/latest/api/token";
	const AWS_EC2_METADATA_V1_DISABLED = "AWS_EC2_METADATA_V1_DISABLED";
	const PROFILE_AWS_EC2_METADATA_V1_DISABLED = "ec2_metadata_v1_disabled";
	const X_AWS_EC2_METADATA_TOKEN = "x-aws-ec2-metadata-token";
	const fromInstanceMetadata = (init = {}) => staticStabilityProvider(getInstanceMetadataProvider(init), { logger: init.logger });
	const getInstanceMetadataProvider = (init = {}) => {
		let disableFetchToken = false;
		const { logger: logger$1, profile } = init;
		const { timeout, maxRetries } = providerConfigFromInit(init);
		const getCredentials$1 = async (maxRetries$1, options) => {
			if (disableFetchToken || options.headers?.[X_AWS_EC2_METADATA_TOKEN] == null) {
				let fallbackBlockedFromProfile = false;
				let fallbackBlockedFromProcessEnv = false;
				const configValue = await nodeConfigProvider.loadConfig({
					environmentVariableSelector: (env) => {
						const envValue = env[AWS_EC2_METADATA_V1_DISABLED];
						fallbackBlockedFromProcessEnv = !!envValue && envValue !== "false";
						if (envValue === void 0) throw new propertyProvider.CredentialsProviderError(`${AWS_EC2_METADATA_V1_DISABLED} not set in env, checking config file next.`, { logger: init.logger });
						return fallbackBlockedFromProcessEnv;
					},
					configFileSelector: (profile$1) => {
						const profileValue = profile$1[PROFILE_AWS_EC2_METADATA_V1_DISABLED];
						fallbackBlockedFromProfile = !!profileValue && profileValue !== "false";
						return fallbackBlockedFromProfile;
					},
					default: false
				}, { profile })();
				if (init.ec2MetadataV1Disabled || configValue) {
					const causes = [];
					if (init.ec2MetadataV1Disabled) causes.push("credential provider initialization (runtime option ec2MetadataV1Disabled)");
					if (fallbackBlockedFromProfile) causes.push(`config file profile (${PROFILE_AWS_EC2_METADATA_V1_DISABLED})`);
					if (fallbackBlockedFromProcessEnv) causes.push(`process environment variable (${AWS_EC2_METADATA_V1_DISABLED})`);
					throw new InstanceMetadataV1FallbackError(`AWS EC2 Metadata v1 fallback has been blocked by AWS SDK configuration in the following: [${causes.join(", ")}].`);
				}
			}
			const imdsProfile = (await retry(async () => {
				let profile$1;
				try {
					profile$1 = await getProfile(options);
				} catch (err) {
					if (err.statusCode === 401) disableFetchToken = false;
					throw err;
				}
				return profile$1;
			}, maxRetries$1)).trim();
			return retry(async () => {
				let creds;
				try {
					creds = await getCredentialsFromProfile(imdsProfile, options, init);
				} catch (err) {
					if (err.statusCode === 401) disableFetchToken = false;
					throw err;
				}
				return creds;
			}, maxRetries$1);
		};
		return async () => {
			const endpoint = await getInstanceMetadataEndpoint();
			if (disableFetchToken) {
				logger$1?.debug("AWS SDK Instance Metadata", "using v1 fallback (no token fetch)");
				return getCredentials$1(maxRetries, {
					...endpoint,
					timeout
				});
			} else {
				let token;
				try {
					token = (await getMetadataToken({
						...endpoint,
						timeout
					})).toString();
				} catch (error$2) {
					if (error$2?.statusCode === 400) throw Object.assign(error$2, { message: "EC2 Metadata token request returned error" });
					else if (error$2.message === "TimeoutError" || [
						403,
						404,
						405
					].includes(error$2.statusCode)) disableFetchToken = true;
					logger$1?.debug("AWS SDK Instance Metadata", "using v1 fallback (initial)");
					return getCredentials$1(maxRetries, {
						...endpoint,
						timeout
					});
				}
				return getCredentials$1(maxRetries, {
					...endpoint,
					headers: { [X_AWS_EC2_METADATA_TOKEN]: token },
					timeout
				});
			}
		};
	};
	const getMetadataToken = async (options) => httpRequest({
		...options,
		path: IMDS_TOKEN_PATH,
		method: "PUT",
		headers: { "x-aws-ec2-metadata-token-ttl-seconds": "21600" }
	});
	const getProfile = async (options) => (await httpRequest({
		...options,
		path: IMDS_PATH
	})).toString();
	const getCredentialsFromProfile = async (profile, options, init) => {
		const credentialsResponse = JSON.parse((await httpRequest({
			...options,
			path: IMDS_PATH + profile
		})).toString());
		if (!isImdsCredentials(credentialsResponse)) throw new propertyProvider.CredentialsProviderError("Invalid response received from instance metadata service.", { logger: init.logger });
		return fromImdsCredentials(credentialsResponse);
	};
	exports.DEFAULT_MAX_RETRIES = DEFAULT_MAX_RETRIES;
	exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
	exports.ENV_CMDS_AUTH_TOKEN = ENV_CMDS_AUTH_TOKEN;
	exports.ENV_CMDS_FULL_URI = ENV_CMDS_FULL_URI;
	exports.ENV_CMDS_RELATIVE_URI = ENV_CMDS_RELATIVE_URI;
	exports.fromContainerMetadata = fromContainerMetadata;
	exports.fromInstanceMetadata = fromInstanceMetadata;
	exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
	exports.httpRequest = httpRequest;
	exports.providerConfigFromInit = providerConfigFromInit;
}));

//#endregion
export { require_dist_cjs$5 as $, SigninServiceException as A, AssumeRoleCommand as B, Signin as C, InternalServerException$2 as D, AccessDeniedException$2 as E, decorateDefaultCredentialProvider as F, InvalidIdentityTokenException as G, ExpiredTokenException$2 as H, getDefaultRoleAssumer$1 as I, RegionDisabledException as J, MalformedPolicyDocumentException as K, getDefaultRoleAssumerWithWebIdentity$1 as L, import_dist_cjs$47 as M, require_dist_cjs$1 as N, TooManyRequestsError as O, init_sts as P, require_dist_cjs$2 as Q, STS as R, init_signin as S, import_dist_cjs$37 as T, IDPCommunicationErrorException as U, import_dist_cjs$74 as V, IDPRejectedClaimException as W, STSClient as X, STSServiceException as Y, import_dist_cjs$84 as Z, UnauthorizedClientException as _, SSOOIDC as a, SSOOIDCClient as b, AccessDeniedException as c, InternalServerException as d, require_dist_cjs$6 as et, InvalidClientException as f, SlowDownException as g, InvalidScopeException as h, init_sso_oidc as i, require_core as it, SigninClient as j, ValidationException as k, AuthorizationPendingException as l, InvalidRequestException as m, init_event_streams as n, require_dist_cjs$9 as nt, CreateTokenCommand as o, InvalidGrantException as p, PackedPolicyTooLargeException as q, EventStreamSerde as r, require_dist_cjs$16 as rt, import_dist_cjs$3 as s, require_dist_cjs as t, require_dist_cjs$8 as tt, ExpiredTokenException as u, UnsupportedGrantTypeException as v, CreateOAuth2TokenCommand as w, import_dist_cjs$13 as x, SSOOIDCServiceException as y, AssumeRoleWithWebIdentityCommand as z };